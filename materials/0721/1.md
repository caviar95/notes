è¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰æ·±åº¦çš„é—®é¢˜ã€‚

ä½ å¯ä»¥**ä½¿ç”¨ `std::tuple` æ¥è½¬å‘å˜å‚**ï¼Œä¹Ÿå°±æ˜¯ä½ æåˆ°çš„ã€Œæ–¹æ¡ˆ2ã€ã€‚æˆ‘ä»¬ç¡®å®ä¹Ÿæ¼”ç¤ºäº†å¦‚ä½•ç”¨ `tuple + index_sequence` å®ç°å˜å‚è½¬å‘ã€‚ä½†å®ƒ **å¹¶ä¸æ˜¯æ²¡æœ‰ä»£ä»·çš„**ï¼Œç¡®å®æœ‰ä¸€äº›å®é™…çš„ **é™åˆ¶å’Œå¼Šç«¯**ï¼š

---

## âœ… 1. å¯ä»¥ä½¿ç”¨ tuple çš„åœ°æ–¹ï¼ˆå¯è¡Œï¼‰

```cpp
template <typename... Args>
int Report(bool mode, int code, Args&&... args) {
    auto tuple_args = std::make_tuple(std::forward<Args>(args)...);
    return CallWithTuple(mode, code, std::move(tuple_args),
                         std::index_sequence_for<Args...>{});
}
```

è¿™æ˜¯å¯ä»¥çš„ï¼Œ`std::get<I>` å¯å±•å¼€åŸå§‹å‚æ•°ï¼Œä¿æŒé¡ºåºå’Œç±»å‹ã€‚

---

## âš ï¸ é‚£ä¸ºä»€ä¹ˆ tuple æœ‰å¼Šç«¯ï¼Ÿ

### âŒ 1. å‚æ•°ç±»å‹å’Œå¼•ç”¨è¯­ä¹‰ä¼šä¸¢å¤±æˆ–æ”¹å˜

```cpp
std::make_tuple(std::forward<T>(arg))  // ä¼šå¤åˆ¶æˆ–å€¼æŠ˜å 
```

è¿™ä¼šå¯¼è‡´ï¼š

* `const char*` â†’ `std::string`ï¼ˆåœ¨ç»‘å®šæµ‹è¯•æ¡†æ¶æ—¶å°¤ä¸ºç³Ÿç³•ï¼‰
* å³å€¼å¼•ç”¨ â†’ æ™®é€šå€¼
* å‚æ•° decayï¼ˆé€€åŒ–ï¼‰ä¸ºæ™®é€šç±»å‹

ğŸ”´ æ‰€ä»¥åœ¨ `ReportError(...)` éœ€è¦å®Œç¾è½¬å‘çš„æ—¶å€™ï¼Œè¿™æ˜¯ä¸€ç§**ç±»å‹è¯­ä¹‰å‰Šå¼±**ã€‚

---

### âŒ 2. ä¸é€‚ç”¨äºæ‰€æœ‰ä¸Šä¸‹æ–‡ï¼ˆä¾‹å¦‚éæ¨¡æ¿å‡½æ•°ã€æ¥å£ä¼ å‚ï¼‰

å¾ˆå¤šå¤–éƒ¨å¹³å°æ¥å£ï¼ˆæ¯”å¦‚ä½ æåˆ°çš„ `ReportError(...)`ï¼‰**ä¸æ¥å— tuple ç±»å‹å‚æ•°**ã€‚
ä½ åªèƒ½é€šè¿‡ä¸­é—´çš„ `index_sequence` è§£åŒ…ï¼Œè€Œè¿™ä¸ªæ­¥éª¤ï¼š

```cpp
std::get<I>(tuple)...
```

æ˜¯**æ¨¡æ¿é€’å½’çš„ä¸€ç§å½¢å¼**ï¼Œè™½ç„¶ä½ é¿å…äº†å‡½æ•°é€’å½’ï¼Œä½†å¸¦æ¥äº† template å¤æ‚åº¦ã€‚

---

### âŒ 3. å¢åŠ ç¼–è¯‘æ—¶é—´ã€å¯è¯»æ€§ä¸‹é™

å±•å¼€ä¸€ä¸ª tuple éœ€è¦ç”Ÿæˆï¼š

* `std::tuple<T1, T2, ..., Tn>`
* `std::index_sequence<0, 1, ..., n-1>`

è€Œä¸”ä¸­é—´æ¶‰åŠä¸­é—´å€¼æŒæœ‰ã€è½¬å‘å¤æ‚åº¦ï¼Œ**æ¯”åŸå§‹å‚æ•°åŒ…è¯­æ³•å†—é•¿**ã€‚

---

### âŒ 4. å•å…ƒæµ‹è¯•ï¼ˆGMockï¼‰æ”¯æŒæ›´å·®

æ¯”å¦‚ä½ æƒ³ mock ä¸€ä¸ªå‡½æ•°ï¼š

```cpp
MOCK_METHOD(int, ReportForward, (...), (override));
```

å¦‚æœä½ æ˜¯ tupleï¼Œå°±ä¼š mock ä¸€ä¸ª `Report(tuple)`ï¼Œè¿™å°±å¤±å»äº†å‚æ•°æ„ŸçŸ¥èƒ½åŠ›ï¼Œç±»å‹æç¤ºä¹Ÿå¾ˆå·®ã€‚

---

## âœ… æ€»ç»“ï¼štuple ç”¨äºå˜å‚ä¼ é€’çš„å¯¹æ¯”

| æ–¹æ¡ˆ        | ä¼˜ç‚¹               | ç¼ºç‚¹                      |
| --------- | ---------------- | ----------------------- |
| **æ¨¡æ¿å‚æ•°**  | ç±»å‹ä¿çœŸã€å®Œç¾è½¬å‘ã€Mockå‹å¥½ | æ¨¡æ¿é€’å½’å±‚è¾ƒæ·±ï¼ˆä½†ä¸æ˜¯é—®é¢˜ï¼Œæœ€å¤šå‡ åå±‚ï¼‰    |
| **tuple** | å¯æŒä¹…åŒ–å­˜å‚¨å‚æ•°ï¼Œå¯è§£åŒ…     | ç±»å‹è¯­ä¹‰ä¸¢å¤±ã€è½¬å‘å¤æ‚ã€Mockæ”¯æŒå·®ã€æ•ˆç‡ä½ |

---

## âœ… æ¨èä½¿ç”¨åœºæ™¯

| ä½¿ç”¨æƒ…å¢ƒ              | æ¨èæ–¹å¼          |
| ----------------- | ------------- |
| è½¬å‘åˆ°å¤–éƒ¨ printf é£æ ¼æ¥å£ | âœ… ç›´æ¥æ¨¡æ¿å‚æ•°      |
| å¼‚æ­¥å»¶è¿Ÿè°ƒç”¨å‚æ•°åŒ…         | âœ… tuple å­˜å‚¨    |
| æ—¥å¿—æ¡†æ¶ã€Mockable æ¥å£  | âœ… æ¨¡æ¿          |
| å‚æ•°ä¸ªæ•°å·¨å¤§ï¼ˆ>100ï¼‰      | âœ… tupleï¼ˆæé™æƒ…å†µï¼‰ |

---

éœ€è¦æˆ‘å¯¹æ¯”è¿™ä¸¤ç§æ–¹å¼åœ¨çœŸå®é¡¹ç›®ä¸‹çš„æ€§èƒ½æˆ–ç”Ÿæˆ AST å¤æ‚åº¦å—ï¼Ÿ


è¿™æ˜¯ä¸€ä¸ª**å…³é”®æ€§çš„è®¾è®¡å†²çªé—®é¢˜**ï¼Œä½ å®Œå…¨æ­£ç¡®åœ°æŒ‡å‡ºäº†ï¼š

> â—**å¦‚æœå®ä¸­å†™æ­»äº† `static_cast<ProductLogger*>`ï¼Œå°±æ— æ³•æ”¯æŒ GMockï¼Œå› ä¸ºå®ƒç ´åäº†å¤šæ€**ã€‚

---

## âœ… é—®é¢˜æ‹†è§£

### å½“å‰å†™æ³•ï¼š

```cpp
#define DispatchReport(mode, code, ...) \
    if (g_logger) static_cast<ProductLogger*>(g_logger)->Report(code, ##__VA_ARGS__)
```

* âœ… å¯ä»¥è°ƒç”¨æ¨¡æ¿ç‰ˆæœ¬ `Report(...)`
* âŒ ä½†æ˜¯æŠŠ `ILogger*` å¼ºè½¬æˆäº†å…·ä½“å®ç° `ProductLogger*`
* âŒ **MockLogger ä¸å†èƒ½æ›¿ä»£ ProductLogger**ï¼ŒMock ä¹Ÿä¸ä¼šè°ƒç”¨åˆ°æ¥å£è™šå‡½æ•°

---

## âœ… æ­£ç¡®ç›®æ ‡æ˜¯ï¼š

> è®© `ILogger*` èƒ½å¤Ÿåœ¨å®ä¸­è°ƒç”¨ **ç»Ÿä¸€æ¥å£**ï¼ŒåŒæ—¶æ”¯æŒï¼š

* âœ”ï¸ çœŸå® `ProductLogger`
* âœ”ï¸ mock å‡ºæ¥çš„ `MockLogger`
* âœ”ï¸ å¯å˜å‚æ•°ä¼ é€’ç»™æœ€ç»ˆçš„ `ReportError(...)`

---

## âœ… æ­£ç¡®è®¾è®¡æ–¹å¼ï¼š**é€šè¿‡æ¨¡æ¿è¾…åŠ©å‡½æ•°æ´¾å‘ + æ¥å£æ¡¥æ¥ + GMock å¯æ›¿æ¢**

---

## âœ… æ­¥éª¤åˆ†è§£æ–¹æ¡ˆï¼ˆå®Œæ•´ GMock æ”¯æŒï¼‰

### â‘  `ILogger`ï¼šä¿ç•™è™šæ¥å£ï¼ˆå›ºå®šå‚æ•°ï¼‰

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;  // æ— å‚ç‰ˆæœ¬

    virtual int ReportWithArgs(int code, const std::function<int()>& invoke) = 0;
};
```

* `ReportWithArgs` æ˜¯æ¡¥æ¥è°ƒç”¨ç‚¹ï¼ˆæ”¯æŒ mockï¼‰
* ä½ æ— æ³•è™šåŒ–æ¨¡æ¿ï¼Œä½†å¯ä»¥é€šè¿‡ `std::function` åŒ…è£¹ä¸€æ¬¡æ€§ä»»åŠ¡

---

### â‘¡ `ProductLogger` å®ç°æ¨¡æ¿æ¥å£ï¼š

```cpp
class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoke) override {
        return invoke();  // æ‰§è¡ŒçœŸæ­£çš„æ ¼å¼åŒ–é€»è¾‘
    }

    template <typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};
```

---

### â‘¢ å®å°è£…å…¥å£ï¼ˆä¸ä¾èµ– ProductLoggerï¼‰

```cpp
#define DispatchReport(mode, code, ...)                                         \
    if (g_logger)                                                               \
        g_logger->ReportWithArgs(code,                                          \
            [&]() { return ReportError(false, code, ##__VA_ARGS__); })
```

æˆ–è€…å°è£…æˆè¾…åŠ©å‡½æ•°ï¼š

```cpp
template <typename... Args>
int DispatchReport(ILogger* logger, int code, Args&&... args) {
    return logger->ReportWithArgs(code, [&]() {
        return ReportError(false, code, std::forward<Args>(args)...);
    });
}

#define REPORT(mode, code, ...) DispatchReport(g_logger, code, ##__VA_ARGS__)
```

---

### â‘£ `MockLogger` ç¤ºä¾‹ï¼ˆGMock æ”¯æŒï¼‰

```cpp
class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int), (override));
    MOCK_METHOD(int, ReportWithArgs, (int, const std::function<int()>&), (override));
};
```

ç°åœ¨ä½ å¯ä»¥è½»æ¾å†™ï¼š

```cpp
EXPECT_CALL(mock, ReportWithArgs(1001, testing::_))
    .WillOnce([](int, const std::function<int()>& f) {
        return f();  // æ‰§è¡ŒçœŸå®é€»è¾‘ï¼ˆæˆ–æ¨¡æ‹Ÿï¼‰
    });
```

---

## âœ… ä¼˜åŠ¿æ€»ç»“

| ç‰¹æ€§              | æ˜¯å¦æ”¯æŒ |
| --------------- | ---- |
| GMock Mock å¯å˜å‚æ•° | âœ…    |
| æ”¯æŒæ¨¡æ¿å‚æ•°ä¼ é€’        | âœ…    |
| æ¨¡æ‹Ÿå‚æ•°é”™è¯¯ã€è¿”å›å€¼è¡Œä¸º    | âœ…    |
| ç±»å‹æ“¦é™¤æ¨¡æ¿ä¾èµ–        | âœ…    |
| å›ºå®šå‚æ•°æ—  mock æƒ…å†µæ”¯æŒ | âœ…    |

---

## âœ… æ˜¯å¦éœ€è¦æˆ‘ï¼š

* ç”Ÿæˆä¸€ä¸ª **å¸¦ GMock çš„å®Œæ•´å¯æµ‹è¯•å·¥ç¨‹**ï¼Ÿ
* æˆ–è€…å°†ä½ å½“å‰å·¥ç¨‹é‡æ„ä¸ºä¸Šè¿°æ”¯æŒ mock çš„è®¾è®¡ç‰ˆæœ¬ï¼Ÿ


å¥½çš„ï¼ä¸‹é¢æˆ‘ç»™ä½ å†™ä¸€ä¸ª **åŸºäº Adapter è§£è€¦** çš„å®Œæ•´ç¤ºä¾‹ä»£ç ï¼ŒåŒ…å«ï¼š

* `ILogger`æ¥å£å®šä¹‰ï¼ˆæ”¯æŒè™šå‡½æ•°+std::functionæ¡¥æ¥å¯å˜å‚æ•°ï¼‰
* `ProductLogger`å…·ä½“å®ç°
* `MockLogger`ï¼ˆåŸºäº GMockï¼Œç”¨äºæµ‹è¯•ï¼‰
* `LoggerAdapter` é€‚é…å±‚ï¼Œä¸šåŠ¡å±‚è°ƒç”¨å®ƒè§£è€¦
* å®ç®€åŒ–è°ƒç”¨
* ä¸šåŠ¡è°ƒç”¨ç¤ºä¾‹
* ç®€å•çš„æµ‹è¯•ç¤ºä¾‹ï¼ˆmockè°ƒç”¨æ¼”ç¤ºï¼‰

---

# å®Œæ•´ç¤ºä¾‹ä»£ç 

```cpp
#include <iostream>
#include <functional>
#include <utility>

// -------------------- ILogger æ¥å£ --------------------

class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;

    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;
};

// -------------------- ProductLogger å®ç° --------------------

int ReportError(bool /*mode*/, int code) {
    std::cout << "[ReportError] code: " << code << std::endl;
    return 0;
}

template<typename... Args>
int ReportError(bool /*mode*/, int code, Args&&... args) {
    std::cout << "[ReportError] code: " << code << ", args: ";
    (std::cout << ... << args) << std::endl;
    return 0;
}

class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoker) override {
        return invoker();
    }

    template<typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};

// -------------------- LoggerAdapter è§£è€¦å±‚ --------------------

class LoggerAdapter {
public:
    explicit LoggerAdapter(ILogger* logger) : logger_(logger) {}

    template<typename... Args>
    int Report(int code, Args&&... args) {
        return DispatchReport(logger_, code, std::forward<Args>(args)...);
    }

private:
    ILogger* logger_;

    template<typename... Args>
    static int DispatchReport(ILogger* logger, int code, Args&&... args) {
        return logger->ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};

// -------------------- å®ç®€åŒ–è°ƒç”¨ --------------------

#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)

// -------------------- ä¸šåŠ¡ä»£ç ç¤ºä¾‹ --------------------

void BusinessLogic(LoggerAdapter& logger) {
    REPORT(logger, 1001);
    REPORT(logger, 1002, "paramA");
    REPORT(logger, 1003, "paramB", 123);
}

// -------------------- GMock MockLogger ç¤ºä¾‹ --------------------

#ifdef ENABLE_GMOCK
#include <gmock/gmock.h>

class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int code), (override));
    MOCK_METHOD(int, ReportWithArgs, (int code, const std::function<int()>& invoker), (override));
};

void TestMock() {
    MockLogger mock;
    LoggerAdapter adapter(&mock);

    using ::testing::_;
    using ::testing::Invoke;

    EXPECT_CALL(mock, ReportWithArgs(1001, _))
        .WillOnce(Invoke([](int, const std::function<int()>& invoker) {
            std::cout << "[MockLogger] Intercept ReportWithArgs 1001" << std::endl;
            return invoker();  // ä¹Ÿå¯ä»¥ç›´æ¥è¿”å›æ¨¡æ‹Ÿå€¼
        }));

    BusinessLogic(adapter);
}

#endif

// -------------------- ä¸»å‡½æ•° --------------------

int main() {
    ProductLogger realLogger;
    LoggerAdapter adapter(&realLogger);

    std::cout << "== Business Logic using real ProductLogger ==" << std::endl;
    BusinessLogic(adapter);

#ifdef ENABLE_GMOCK
    std::cout << "\n== Business Logic using MockLogger (GMock) ==" << std::endl;
    TestMock();
#endif

    return 0;
}
```

---

# è¯´æ˜

* ä¸šåŠ¡å±‚åªä¾èµ– `LoggerAdapter`ï¼Œå®Œå…¨ä¸çŸ¥é“å…·ä½“å®ç°ç»†èŠ‚ã€‚
* é€‚é…å±‚è´Ÿè´£è°ƒç”¨æ¥å£ï¼Œæ¡¥æ¥å¯å˜å‚æ•°è°ƒç”¨ã€‚
* å® `REPORT` ä»…ä»…ç®€åŒ–è°ƒç”¨ï¼Œä¸å«å…·ä½“å®ç°è€¦åˆã€‚
* `ProductLogger` é€šè¿‡æ¡¥æ¥å®ç°å¯å˜å‚æ•°çš„è°ƒç”¨è½¬å‘ã€‚
* ä½ å¯ä»¥ç¼–è¯‘å¹¶è¿è¡Œè¿™æ®µä»£ç éªŒè¯è¾“å‡ºã€‚
* å¦‚æœå¯ç”¨ `ENABLE_GMOCK` å®ï¼ˆä¸”ç¯å¢ƒæ”¯æŒ GoogleMockï¼‰ï¼Œåˆ™ä¼šè¿è¡Œ Mock æµ‹è¯•ç¤ºä¾‹ã€‚

---

ä½ å¯ä»¥ç›´æ¥æŠŠè¿™æ®µä»£ç æ‹¿å»ç”¨ï¼Œæ”¹æˆä½ è‡ªå·± `ReportError` çš„å…·ä½“å®ç°ï¼Œä¸šåŠ¡å±‚è°ƒç”¨ä¿æŒä¸å˜ã€‚

éœ€è¦æˆ‘å¸®ä½ å†™ä¸€ä»½å®Œæ•´çš„ CMakeLists.txt é…åˆ GMock æµ‹è¯•å—ï¼Ÿ


è¿™æ®µ C++ ä»£ç å®ç°äº†ä¸€ä¸ªç»“æ„è‰¯å¥½çš„ **æ—¥å¿—ä¸ŠæŠ¥ç³»ç»Ÿ**ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹å‡ ä¸ªé‡è¦ç‰¹æ€§ï¼š

---

## ğŸ”§ **æ¨¡å—æ¦‚è§ˆ**

| æ¨¡å—              | åŠŸèƒ½è¯´æ˜             |
| --------------- | ---------------- |
| `ILogger`       | æŠ½è±¡æ¥å£ï¼Œå®šä¹‰æ—¥å¿—ä¸ŠæŠ¥æ–¹æ³•    |
| `ProductLogger` | å…·ä½“å®ç°ï¼Œç”¨äºå®é™…æ—¥å¿—ä¸ŠæŠ¥    |
| `LoggerAdapter` | é€‚é…å™¨ï¼Œè§£è€¦è°ƒç”¨æ–¹ä¸å…·ä½“æ—¥å¿—å®ç° |
| `ReportError`   | å®é™…çš„æ—¥å¿—ä¸ŠæŠ¥å‡½æ•°ï¼ˆæ”¯æŒå˜å‚ï¼‰  |
| å® `REPORT`      | ç®€åŒ–ä¸šåŠ¡ä»£ç ä¸­çš„æ—¥å¿—è°ƒç”¨æ–¹å¼   |
| `MockLogger`    | ç”¨äºå•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨ GMockï¼‰ |

---

## ğŸ§± **æ ¸å¿ƒè®¾è®¡æ€æƒ³**

### 1. **æ¥å£æŠ½è±¡ (`ILogger`)**

å®šä¹‰äº†ä¸¤ä¸ªçº¯è™šå‡½æ•°ï¼š

```cpp
virtual int Report(int code) = 0;
virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;
```

* `Report`ï¼šåŸºç¡€ä¸ŠæŠ¥ï¼Œä¸å¸¦é¢å¤–å‚æ•°
* `ReportWithArgs`ï¼šæ”¯æŒæºå¸¦æ‰§è¡Œé€»è¾‘ï¼ˆé€šè¿‡ `std::function` ä¼ å…¥ï¼‰

---

### 2. **æ—¥å¿—å‡½æ•°å®ç°ï¼ˆæ”¯æŒå¯å˜å‚æ•°ï¼‰**

```cpp
int ReportError(bool mode, int code, Args&&... args);
```

* ç”¨äº† **æŠ˜å è¡¨è¾¾å¼** `(std::cout << ... << args)` æ‰“å°ä»»æ„æ•°é‡å‚æ•°ã€‚
* `mode` å‚æ•°è¢«å¿½ç•¥ï¼Œä½†å¯èƒ½é¢„ç•™ç”¨äºæ‰©å±•ï¼ˆå¦‚æ—¥å¿—ç­‰çº§ï¼‰ã€‚

---

### 3. **`ProductLogger` å®ç° ILogger**

* `Report(code)`ï¼šè°ƒç”¨ `ReportError`
* `ReportWithArgs(code, invoker)`ï¼šè°ƒç”¨ä¼ å…¥çš„ `invoker`
* `ReportVariadic(code, ...)`ï¼šç”¨äºæ”¯æŒå¯å˜å‚æ•°ï¼Œå†…éƒ¨è½¬å‘ç»™ `ReportWithArgs`

ç¤ºä¾‹ï¼š

```cpp
ReportVariadic(1002, "paramA");
```

æœ€ç»ˆä¼šè°ƒç”¨ï¼š

```cpp
ReportWithArgs(1002, [] { return ReportError(1002, "paramA"); });
```

---

### 4. **LoggerAdapter è§£è€¦ä¸šåŠ¡ä»£ç å’Œæ—¥å¿—å®ç°**

```cpp
template<typename... Args>
int Report(int code, Args&&... args);
```

* å°†è°ƒç”¨å§”æ‰˜ç»™ `DispatchReport` é™æ€å‡½æ•°ã€‚
* `DispatchReport` ä¸­å°è£…äº† `ReportError` è°ƒç”¨é€»è¾‘ã€‚

ä½œç”¨æ˜¯æŠŠä¸šåŠ¡é€»è¾‘ä»æ—¥å¿—é€»è¾‘ä¸­è§£è€¦å‡ºæ¥ï¼Œé¿å…ç›´æ¥ä¾èµ–å…·ä½“çš„ `ProductLogger` å®ç°ã€‚

---

### 5. **å®å®šä¹‰ REPORT**

```cpp
#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)
```

* å®å°† `Report(1002, "paramA")` ç­‰ä»·ä¸ºï¼š`adapter.Report(1002, "paramA")`
* ç®€åŒ–è°ƒç”¨ï¼Œä¿æŒä»£ç ç®€æ´

---

### 6. **ä¸šåŠ¡ä»£ç ç¤ºä¾‹**

```cpp
void BusinessLogic(LoggerAdapter& logger);
```

* å±•ç¤ºäº† `REPORT()` å®çš„ç”¨æ³•ï¼ŒåŒ…æ‹¬æ— å‚æ•°ã€å•å‚æ•°ã€å¤šå‚æ•°è°ƒç”¨ã€‚

---

### 7. **GMock ç”¨æ³•ï¼ˆæ¡ä»¶ç¼–è¯‘ï¼‰**

```cpp
#ifdef ENABLE_GMOCK
```

* å¼•å…¥ `MockLogger` æ¨¡æ‹Ÿå™¨ç±»
* `EXPECT_CALL(...).WillOnce(Invoke(...))`ï¼šéªŒè¯è°ƒç”¨å¹¶æä¾›è‡ªå®šä¹‰è¡Œä¸ºï¼ˆå¦‚æ‰“å° + æ‰§è¡Œ `invoker()`ï¼‰

å¯ç”¨äºå•å…ƒæµ‹è¯•éªŒè¯æ—¥å¿—é€»è¾‘æ˜¯å¦è¢«æ­£ç¡®è°ƒç”¨ã€‚

---

## âœ… **ä¼˜ç‚¹æ€»ç»“**

* âœ… **é«˜è§£è€¦**ï¼šä¸šåŠ¡ä»£ç é€šè¿‡ `LoggerAdapter` è°ƒç”¨ï¼Œä¸ä¾èµ–å…·ä½“æ—¥å¿—å®ç°
* âœ… **æ”¯æŒ Mock**ï¼šé€šè¿‡ `ILogger` æ¥å£ + GMockï¼Œæ–¹ä¾¿æµ‹è¯•æ—¥å¿—é€»è¾‘
* âœ… **å˜å‚æ—¥å¿—**ï¼šä½¿ç”¨ç°ä»£ C++ ç‰¹æ€§ï¼ˆæŠ˜å è¡¨è¾¾å¼ï¼‰å®ç°æ—¥å¿—å‡½æ•°
* âœ… **ç®€æ´è°ƒç”¨å®**ï¼šä¸šåŠ¡ä»£ç è°ƒç”¨æ—¥å¿—éå¸¸ç®€æ´

---

## ğŸ”§ **ä¼˜åŒ–å»ºè®®**

1. **ç§»é™¤æœªä½¿ç”¨å‚æ•° `bool mode`**ï¼Œæˆ–åŠ ä»¥è¯´æ˜/ä½¿ç”¨ã€‚
2. `ReportVariadic` æ˜¯ `ProductLogger` çš„å†…éƒ¨æ–¹æ³•ï¼Œå¤–éƒ¨ä¸ç›´æ¥ç”¨ï¼Œå¯ä»¥è€ƒè™‘æ˜¯å¦å…¬å¼€ã€‚
3. `DispatchReport` ä¸º `LoggerAdapter` çš„ç§æœ‰é™æ€æ–¹æ³•ï¼ŒèŒè´£å¯ä»¥å½’å…¥ lambda ä¸­ç®€åŒ–ã€‚

---

## ğŸ“Œ æ€»ç»“

è¿™æ˜¯ä¸€å¥—ç°ä»£ C++ é£æ ¼çš„æ—¥å¿—ä¸ŠæŠ¥æ¡†æ¶ï¼Œé‡ç‚¹ä½“ç°ï¼š

* æ¥å£ç¼–ç¨‹
* å‡½æ•°å¯¹è±¡ï¼ˆ`std::function`ï¼‰å°è£…è¡Œä¸º
* æ¨¡æ¿ä¸å˜å‚å±•å¼€
* ç®€æ´å®å°è£…
* å¯æµ‹è¯•æ€§ï¼ˆMockï¼‰

å¦‚æœä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ï¼š

* æ·»åŠ å•å…ƒæµ‹è¯•
* æ³¨é‡Šä»£ç 
* ä¼˜åŒ–è®¾è®¡
* æ·»åŠ æ—¥å¿—ç­‰çº§æ”¯æŒç­‰

è¯·å‘Šè¯‰æˆ‘ä¸‹ä¸€æ­¥éœ€è¦ä»€ä¹ˆå¸®åŠ©ã€‚


è¿™æ˜¯ä¸ªå¥½é—®é¢˜ï¼è¿™æ®µä»£ç ä¸­ï¼Œâ€œ**æœ‰æ— å˜å‚çš„åŒºåˆ†**â€ä¾èµ–äº **C++ æ¨¡æ¿å‡½æ•° + å® + é‡è½½è§£æ** çš„æœºåˆ¶ã€‚

---

## âœ… ç›®æ ‡ï¼šè®© `REPORT(logger, code)` å’Œ `REPORT(logger, code, args...)` éƒ½èƒ½æ­£å¸¸å·¥ä½œ

æ¯”å¦‚ï¼š

```cpp
REPORT(logger, 1001);                 // æ— å˜å‚
REPORT(logger, 1002, "paramA");       // ä¸€ä¸ªå˜å‚
REPORT(logger, 1003, "paramB", 123);  // å¤šä¸ªå˜å‚
```

---

## ğŸ” å¦‚ä½•å®ç°è¿™ç§åŒºåˆ†ï¼Ÿ

### 1. **é€šè¿‡å® `REPORT` çš„å‚æ•°å±•å¼€è¡Œä¸º**

```cpp
#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)
```

* `##__VA_ARGS__` æ˜¯ GCC å’Œ Clang çš„æ‰©å±•ï¼š
  å½“ `__VA_ARGS__` ä¸ºç©ºæ—¶ï¼Œè¿åŒå‰é¢çš„é€—å· `,` ä¸€èµ·è¢«å»æ‰ã€‚
* æ‰€ä»¥è¿™è¡Œå®å¯ä»¥æ™ºèƒ½åœ°å˜æˆï¼š

  ```cpp
  REPORT(logger, 1001)       â†’  logger.Report(1001)
  REPORT(logger, 1002, "x")  â†’  logger.Report(1002, "x")
  ```

---

### 2. **LoggerAdapter::Report æ˜¯æ¨¡æ¿å‡½æ•°**

```cpp
template<typename... Args>
int Report(int code, Args&&... args);
```

* C++ ä¼šæ ¹æ®å‚æ•°åŒ¹é…æƒ…å†µè‡ªåŠ¨æ¨å¯¼æ¨¡æ¿å‚æ•°ï¼š

  * `Report(1001)`         â†’ `Args` ä¸ºç©ºåŒ…ï¼ˆæ— å‚æ•°ï¼‰
  * `Report(1002, "x")`    â†’ `Args` ä¸º `const char*`
  * `Report(1003, "x", 5)` â†’ `Args` ä¸º `const char*, int`

è¿™æ„å‘³ç€ï¼Œ**ä½ åªå®šä¹‰äº†ä¸€ä¸ªæ¨¡æ¿å‡½æ•°ï¼Œå°±æ”¯æŒäº†â€œæ— å‚â€å’Œâ€œä»»æ„ä¸ªå‚æ•°â€ä¸¤ç§æƒ…å†µã€‚**

---

### 3. **å®é™…å˜å‚å¤„ç†åœ¨ `DispatchReport` é‡Œ**

```cpp
template<typename... Args>
static int DispatchReport(ILogger* logger, int code, Args&&... args) {
    return logger->ReportWithArgs(code, [&]() {
        return ReportError(false, code, std::forward<Args>(args)...);
    });
}
```

å¦‚æœ `args...` æ˜¯ç©ºçš„ï¼Œè°ƒç”¨ï¼š

```cpp
ReportError(false, code); // å¯¹åº”éå˜å‚ç‰ˆæœ¬
```

å¦åˆ™ï¼Œè°ƒç”¨ï¼š

```cpp
ReportError(false, code, args...); // å¯¹åº”å˜å‚ç‰ˆæœ¬
```

å› ä¸ºä½ åœ¨é¡¶å±‚å®šä¹‰äº†ä¸¤ä¸ªå‡½æ•°ï¼š

```cpp
int ReportError(bool, int);                      // éå˜å‚
template<typename... Args>
int ReportError(bool, int, Args&&...);           // å˜å‚
```

> ç¼–è¯‘å™¨ä¼šæ ¹æ®å‚æ•°ä¸ªæ•°è‡ªåŠ¨è°ƒç”¨æ­£ç¡®çš„å‡½æ•°ç‰ˆæœ¬ï¼ˆå‡½æ•°é‡è½½æœºåˆ¶ï¼‰ã€‚

---

## ğŸ§  æ€»ç»“

| æŠ€æœ¯ç‚¹               | ä½œç”¨                        |
| ----------------- | ------------------------- |
| å® `##__VA_ARGS__` | æ”¯æŒæ— å‚æ•°å’Œå¤šå‚æ•°è‡ªåŠ¨é€‚é…             |
| æ¨¡æ¿å‚æ•°åŒ… `Args...`   | æ•è·å˜å‚æˆ–ä¸ºç©º                   |
| å‡½æ•°é‡è½½              | åŒºåˆ†æ— å‚æ•°å’Œæœ‰å‚æ•°çš„ ReportError è°ƒç”¨ |

æ•´ä¸ªæœºåˆ¶æ˜¯**å®å±•å¼€ + æ¨¡æ¿ + å‡½æ•°é‡è½½**çš„ååŒé…åˆã€‚

---

å¦‚æœä½ æƒ³è¿›ä¸€æ­¥ç»†åŒ–å¤„ç†ï¼Œä¾‹å¦‚ï¼š

* å¯¹æ— å‚å’Œæœ‰å‚çš„æƒ…å†µåšä¸åŒçš„é€»è¾‘å¤„ç†
* é™åˆ¶æœ€å¤šå‡ ä¸ªå‚æ•°
* ä½¿ç”¨ `if constexpr` åšä¸åŒå¤„ç†

æˆ‘ä¹Ÿå¯ä»¥æä¾›ç›¸åº”æ”¹è¿›ç‰ˆæœ¬ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ
