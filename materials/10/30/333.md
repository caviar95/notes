下面给你一个完整、可直接编译运行的 **掩码（mask）状态表示** 的 C++ 基本框架。它覆盖了常见需求：

* 每个子系统用一段位（bitmask）表示状态（可多位组合表示复合状态）。
* 支持动态子系统数量与每个子系统不同位宽（用同样的 `uint32_t` 表示每个子系统的掩码）。
* 提供 `FinalState`（或目标状态）以 `required` / `forbidden` 掩码描述合法性判断。
* 提供 `StateMachine` 简单管理、匹配检查、示例用法。
* 可扩展（线程安全、位压缩到单个整型或更复杂的位域都容易扩展）。

下面是示例代码（单文件）——可直接保存为 `mask_state.cpp` 并编译运行（例如 `g++ -std=c++17 mask_state.cpp -o mask_state`）：

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include <cassert>
#include <unordered_map>
#include <sstream>

/*
  掩码状态表示基本框架

  设计思路：
  - 每个子系统使用一个 uint32_t 作为位掩码（如果需要更多位或者更紧凑的全局表示，可以将它们打包到一个更大整型或bitset）
  - MaskState: 保存 N 个子系统的位掩码 vector<uint32_t>
  - FinalState: 对每个子系统定义 required/forbidden 掩码（required: 指定的位必须都存在；forbidden: 指定位必须都不存在）
  - StateMachine: 管理 FinalState 列表，能够检测一个 MaskState 是否匹配某个 FinalState
*/

using Mask = uint32_t;

struct MaskState {
    // subsystems[i] stores the mask for subsystem i
    std::vector<Mask> subsystems;

    MaskState() = default;
    explicit MaskState(size_t n) : subsystems(n, 0u) {}

    size_t size() const { return subsystems.size(); }

    void resize(size_t n) { subsystems.resize(n, 0u); }

    void setBit(size_t subsystemIndex, Mask bitMask) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] |= bitMask;
    }

    void clearBit(size_t subsystemIndex, Mask bitMask) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] &= ~bitMask;
    }

    void assignMask(size_t subsystemIndex, Mask m) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] = m;
    }

    Mask getMask(size_t subsystemIndex) const {
        assert(subsystemIndex < subsystems.size());
        return subsystems[subsystemIndex];
    }

    std::string toString() const {
        std::ostringstream oss;
        oss << "{ ";
        for (size_t i = 0; i < subsystems.size(); ++i) {
            oss << "S" << i << ":0x" << std::hex << subsystems[i] << std::dec;
            if (i+1 < subsystems.size()) oss << ", ";
        }
        oss << " }";
        return oss.str();
    }
};

// 对每个子系统指定 required / forbidden 掩码
struct FinalState {
    std::string name;
    std::vector<Mask> required;  // required[i] 位必须全部被设置
    std::vector<Mask> forbidden; // forbidden[i] 位必须全部为0

    FinalState() = default;
    explicit FinalState(size_t n) : required(n, 0u), forbidden(n, 0u) {}

    bool matches(const MaskState& s) const {
        if (s.size() != required.size()) return false;
        for (size_t i = 0; i < required.size(); ++i) {
            Mask sub = s.getMask(i);
            // 所有 required 位都必须存在
            if ((sub & required[i]) != required[i]) return false;
            // 所有 forbidden 位都必须不存在
            if ((sub & forbidden[i]) != 0) return false;
        }
        return true;
    }
};

struct Transition {
    // 可选：用掩码描述从哪些状态可以到达哪些状态
    // 使用 required/forbidden 的简单模式
    FinalState from;
    FinalState to;
    std::string name;
};

class StateMachine {
public:
    explicit StateMachine(size_t subsystems) : current(subsystems), subsysCount(subsystems) {}

    size_t subsystemCount() const { return subsysCount; }

    void setSubsystemState(size_t idx, Mask mask) {
        current.assignMask(idx, mask);
    }

    void setSubsystemBit(size_t idx, Mask bit) {
        current.setBit(idx, bit);
    }

    void clearSubsystemBit(size_t idx, Mask bit) {
        current.clearBit(idx, bit);
    }

    const MaskState& getCurrent() const { return current; }

    // 添加终态
    void addFinalState(const FinalState& fs) {
        assert(fs.required.size() == subsysCount);
        finalStates.push_back(fs);
    }

    // 查找第一个匹配的 final state (如果没有则返回 nullptr)
    const FinalState* findMatchingFinalState() const {
        for (const auto& fs : finalStates) {
            if (fs.matches(current)) return &fs;
        }
        return nullptr;
    }

    // 打印当前匹配情况
    void printStatus() const {
        std::cout << "Current: " << current.toString() << "\n";
        const FinalState* fs = findMatchingFinalState();
        if (fs) std::cout << "Matches final state: " << fs->name << "\n";
        else std::cout << "No matching final state\n";
    }

private:
    MaskState current;
    size_t subsysCount;
    std::vector<FinalState> finalStates;
};


// ----------------- 示例：定义子系统states -----------------
/*
 假设有两个子系统：
 S0: bits 0 (IDLE), 1 (RUN), 2 (ERROR)
 S1: bits 0 (OFF), 1 (ON), 2 (SUSPEND)
*/
enum S0Bits : Mask {
    S0_IDLE  = 1u << 0,
    S0_RUN   = 1u << 1,
    S0_ERROR = 1u << 2
};

enum S1Bits : Mask {
    S1_OFF     = 1u << 0,
    S1_ON      = 1u << 1,
    S1_SUSPEND = 1u << 2
};

// ----------------- 使用示例 -----------------
int main() {
    StateMachine sm(2); // 2 个子系统

    // 设置当前状态：S0 = RUN, S1 = OFF
    sm.setSubsystemState(0, S0_RUN);
    sm.setSubsystemState(1, S1_OFF);
    sm.printStatus();

    // 定义一个最终状态：Idle+On
    FinalState idleOn(2);
    idleOn.name = "Idle+On";
    idleOn.required[0] = S0_IDLE; // S0 必须是 IDLE
    idleOn.required[1] = S1_ON;   // S1 必须 ON

    // 定义一个最终状态：Any RUN but not ERROR on S0, S1 can be anything
    FinalState runningNoError(2);
    runningNoError.name = "RunWithoutError";
    runningNoError.required[0] = S0_RUN;
    runningNoError.forbidden[0] = S0_ERROR; // S0 不能有 ERROR
    // S1 required/forbidden 默认 0

    sm.addFinalState(idleOn);
    sm.addFinalState(runningNoError);

    // 检测（当前 S0=RUN, S1=OFF）应匹配 runningNoError
    const FinalState* matched = sm.findMatchingFinalState();
    if (matched) {
        std::cout << "Matched final state: " << matched->name << "\n";
    } else {
        std::cout << "No final state matched\n";
    }

    // 改变状态为 Idle+On
    sm.setSubsystemState(0, S0_IDLE);
    sm.setSubsystemState(1, S1_ON);
    sm.printStatus();
    matched = sm.findMatchingFinalState();
    if (matched) std::cout << "Matched final state: " << matched->name << "\n";

    // 复合位示例（一个子系统同时有多个位）
    // 假如允许 S1: ON + SUSPEND 同时存在（或表示某种复合）
    sm.setSubsystemBit(1, S1_ON | S1_SUSPEND);
    std::cout << "After multi-bit set: ";
    sm.printStatus();

    return 0;
}
```

# 说明与扩展建议（短）

* 如果你有固定的全局位数并且想把所有子系统压到一个 `uint64_t` / `std::bitset` 中以减少内存 / 提升比较速度，可以把每个子系统分配固定宽度并打包（需要计算偏移）。
* 如果需要快速查表（大量 final states），可以把 final state 的 required/forbidden 编成更紧凑的 key 并用哈希索引或决策树来加速匹配。
* 对于并发场景，保护 `StateMachine` 内部状态的读写（`std::mutex` 或原子替代）即可。
* 如果你想支持“至少有一个位被设置（any-of）”或“至少 k 个位被设置”这类更复杂的规则，可以把 `FinalState.matches` 扩展为更通用的谓词/回调（`std::function<bool(const MaskState&)>`）。

如果你想，我可以：

* 把每个子系统的位定义由 `enum class` + `scoped helper` 更类型安全化；
* 提供将多子系统压缩到一个 `uint64_t` 的实现（适合子系统少且位数固定的场景）；
* 或者把 `FinalState` 的匹配扩展成支持 "至少一个匹配 (anyOf)"、"全部匹配 (allOf)"、"互斥 (xor)" 等更复杂布尔表达式的领域语言（DSL）。

要哪个扩展我直接在这个框架上做一个版本给你？
非常好 👍 ——这一步是**掩码状态表示进阶设计的关键优化之一**：

通过使用 **`enum class` + 强类型辅助函数（scoped helper）**，我们能显著提升类型安全、可读性和可维护性，避免“不同子系统位定义互相污染”的问题。

---

## 🎯 改进目标

* 用 **`enum class`** 为每个子系统定义状态位；
* 用模板化 `MaskHelper<T>` 提供：

  * 位掩码计算 (`bit(e)`)
  * 状态组合 (`combine(e1, e2, ...)`)
  * 判断 (`has(mask, e)`)
* `StateMachine`、`MaskState` 等核心结构依然保持通用，但 **类型安全化接口**；
* 支持强类型下的自动转换（通过模板约束，防止传错枚举类型）。

---

## ✅ 完整可编译示例：类型安全掩码状态框架

保存为 `mask_state_typed.cpp`：

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include <cassert>
#include <sstream>
#include <type_traits>

// ============ 基础类型定义 ============
using Mask = uint32_t;

// -----------------------------
// Scoped enum + helper 模板
// -----------------------------
template <typename Enum>
struct MaskHelper {
    static_assert(std::is_enum_v<Enum>, "MaskHelper requires enum type");

    using U = std::underlying_type_t<Enum>;

    // 获取单个bit
    static constexpr Mask bit(Enum e) noexcept {
        return static_cast<Mask>(1u << static_cast<U>(e));
    }

    // 组合多个bit
    template <typename... Enums>
    static constexpr Mask combine(Enums... es) noexcept {
        return (bit(es) | ...);
    }

    // 检查mask是否包含某位
    static constexpr bool has(Mask mask, Enum e) noexcept {
        return (mask & bit(e)) != 0;
    }
};

// ================== 子系统定义 ==================

// 子系统0: 主系统状态
enum class Sys0 : uint8_t {
    Idle = 0,
    Run  = 1,
    Error = 2,
};

// 子系统1: 电源状态
enum class Sys1 : uint8_t {
    Off = 0,
    On  = 1,
    Suspend = 2,
};

// 为简化使用定义别名
using H0 = MaskHelper<Sys0>;
using H1 = MaskHelper<Sys1>;

// ================== 掩码状态类 ==================
struct MaskState {
    std::vector<Mask> subsystems;

    explicit MaskState(size_t n) : subsystems(n, 0u) {}
    size_t size() const { return subsystems.size(); }

    void assign(size_t idx, Mask m) {
        assert(idx < subsystems.size());
        subsystems[idx] = m;
    }

    Mask get(size_t idx) const {
        assert(idx < subsystems.size());
        return subsystems[idx];
    }

    std::string toString() const {
        std::ostringstream oss;
        oss << "{ ";
        for (size_t i = 0; i < subsystems.size(); ++i) {
            oss << "S" << i << ":0x" << std::hex << subsystems[i] << std::dec;
            if (i + 1 < subsystems.size()) oss << ", ";
        }
        oss << " }";
        return oss.str();
    }
};

// ================== 终态匹配类 ==================
struct FinalState {
    std::string name;
    std::vector<Mask> required;
    std::vector<Mask> forbidden;

    explicit FinalState(size_t n) : required(n, 0u), forbidden(n, 0u) {}

    bool matches(const MaskState& s) const {
        if (s.size() != required.size()) return false;
        for (size_t i = 0; i < s.size(); ++i) {
            Mask m = s.get(i);
            if ((m & required[i]) != required[i]) return false;
            if ((m & forbidden[i]) != 0) return false;
        }
        return true;
    }
};

// ================== 状态机 ==================
class StateMachine {
public:
    explicit StateMachine(size_t subs) : current(subs), subsysCount(subs) {}

    template <typename Enum>
    void set(size_t idx, Enum e) {
        assert(idx < subsysCount);
        current.assign(idx, MaskHelper<Enum>::bit(e));
    }

    template <typename Enum, typename... Enums>
    void setMulti(size_t idx, Enum e, Enums... es) {
        assert(idx < subsysCount);
        current.assign(idx, MaskHelper<Enum>::combine(e, es...));
    }

    const MaskState& state() const { return current; }

    void addFinal(const FinalState& fs) {
        finalStates.push_back(fs);
    }

    const FinalState* match() const {
        for (const auto& f : finalStates)
            if (f.matches(current))
                return &f;
        return nullptr;
    }

    void print() const {
        std::cout << "Current: " << current.toString() << "\n";
        const FinalState* fs = match();
        if (fs)
            std::cout << " → Matched: " << fs->name << "\n";
        else
            std::cout << " → No match\n";
    }

private:
    MaskState current;
    size_t subsysCount;
    std::vector<FinalState> finalStates;
};

// ================== 使用示例 ==================
int main() {
    StateMachine sm(2); // 两个子系统

    // 定义终态1：Idle+On
    FinalState idleOn(2);
    idleOn.name = "Idle+On";
    idleOn.required[0] = H0::bit(Sys0::Idle);
    idleOn.required[1] = H1::bit(Sys1::On);

    // 定义终态2：Run but no Error
    FinalState running(2);
    running.name = "Running(NoError)";
    running.required[0] = H0::bit(Sys0::Run);
    running.forbidden[0] = H0::bit(Sys0::Error);

    sm.addFinal(idleOn);
    sm.addFinal(running);

    // 当前状态: Run + Off
    sm.set<Sys0>(0, Sys0::Run);
    sm.set<Sys1>(1, Sys1::Off);
    sm.print();

    // 切换为 Idle + On
    sm.set<Sys0>(0, Sys0::Idle);
    sm.set<Sys1>(1, Sys1::On);
    sm.print();

    // 复合状态：Sys1 同时 On + Suspend
    sm.setMulti<Sys1>(1, Sys1::On, Sys1::Suspend);
    sm.print();

    // 检查是否包含某位
    Mask m = H1::combine(Sys1::On, Sys1::Suspend);
    std::cout << "Mask has On? " << H1::has(m, Sys1::On) << "\n";
}
```

---

## 🧩 核心改进点说明

| 改进点  | 旧版做法             | 新版做法                           |                                  |
| ---- | ---------------- | ------------------------------ | -------------------------------- |
| 位定义  | `enum` 全局作用域，易冲突 | `enum class` 强类型作用域            |                                  |
| 类型安全 | 全靠人工区分           | 模板约束 + scoped helper 防止误传类型    |                                  |
| 掩码操作 | 手写移位常量           | 自动推导 `MaskHelper<Enum>::bit()` |                                  |
| 可组合性 | 通过 `             | ` 手写                           | `MaskHelper::combine()` 支持任意枚举组合 |
| 匹配语义 | 二进制掩码对比          | 类型安全，支持跨 subsystem 区分          |                                  |

---

## 🧠 可扩展方向

1. **泛型化 StateMachine：**

   ```cpp
   template<typename... Subsystems>
   class TypedStateMachine;
   ```

   可自动根据模板参数数量生成内部向量。

2. **constexpr 支持：**
   所有 MaskHelper 操作都可 constexpr，使编译期就能生成掩码表。

3. **添加语义层封装：**
   提供 DSL，如：

   ```cpp
   sm.when(Sys0::Run).andNot(Sys0::Error).then("Running(NoError)");
   ```

4. **自动生成枚举到字符串映射：**
   方便调试打印，可用宏或 `magic_enum` 实现。

---

是否希望我在这个基础上再升级为 **“泛型 StateMachine<Subsystem0, Subsystem1, …>”** 版本（支持类型自动推导、无索引访问）？
例如：`sm.set<Sys0>(Sys0::Run)` 而无需指定索引？
