ä¸‹é¢ç»™ä½ ä¸€ä¸ªå®Œæ•´ã€å¯ç›´æ¥ç¼–è¯‘è¿è¡Œçš„ **æ©ç ï¼ˆmaskï¼‰çŠ¶æ€è¡¨ç¤º** çš„ C++ åŸºæœ¬æ¡†æ¶ã€‚å®ƒè¦†ç›–äº†å¸¸è§éœ€æ±‚ï¼š

* æ¯ä¸ªå­ç³»ç»Ÿç”¨ä¸€æ®µä½ï¼ˆbitmaskï¼‰è¡¨ç¤ºçŠ¶æ€ï¼ˆå¯å¤šä½ç»„åˆè¡¨ç¤ºå¤åˆçŠ¶æ€ï¼‰ã€‚
* æ”¯æŒåŠ¨æ€å­ç³»ç»Ÿæ•°é‡ä¸æ¯ä¸ªå­ç³»ç»Ÿä¸åŒä½å®½ï¼ˆç”¨åŒæ ·çš„ `uint32_t` è¡¨ç¤ºæ¯ä¸ªå­ç³»ç»Ÿçš„æ©ç ï¼‰ã€‚
* æä¾› `FinalState`ï¼ˆæˆ–ç›®æ ‡çŠ¶æ€ï¼‰ä»¥ `required` / `forbidden` æ©ç æè¿°åˆæ³•æ€§åˆ¤æ–­ã€‚
* æä¾› `StateMachine` ç®€å•ç®¡ç†ã€åŒ¹é…æ£€æŸ¥ã€ç¤ºä¾‹ç”¨æ³•ã€‚
* å¯æ‰©å±•ï¼ˆçº¿ç¨‹å®‰å…¨ã€ä½å‹ç¼©åˆ°å•ä¸ªæ•´å‹æˆ–æ›´å¤æ‚çš„ä½åŸŸéƒ½å®¹æ˜“æ‰©å±•ï¼‰ã€‚

ä¸‹é¢æ˜¯ç¤ºä¾‹ä»£ç ï¼ˆå•æ–‡ä»¶ï¼‰â€”â€”å¯ç›´æ¥ä¿å­˜ä¸º `mask_state.cpp` å¹¶ç¼–è¯‘è¿è¡Œï¼ˆä¾‹å¦‚ `g++ -std=c++17 mask_state.cpp -o mask_state`ï¼‰ï¼š

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include <cassert>
#include <unordered_map>
#include <sstream>

/*
  æ©ç çŠ¶æ€è¡¨ç¤ºåŸºæœ¬æ¡†æ¶

  è®¾è®¡æ€è·¯ï¼š
  - æ¯ä¸ªå­ç³»ç»Ÿä½¿ç”¨ä¸€ä¸ª uint32_t ä½œä¸ºä½æ©ç ï¼ˆå¦‚æœéœ€è¦æ›´å¤šä½æˆ–è€…æ›´ç´§å‡‘çš„å…¨å±€è¡¨ç¤ºï¼Œå¯ä»¥å°†å®ƒä»¬æ‰“åŒ…åˆ°ä¸€ä¸ªæ›´å¤§æ•´å‹æˆ–bitsetï¼‰
  - MaskState: ä¿å­˜ N ä¸ªå­ç³»ç»Ÿçš„ä½æ©ç  vector<uint32_t>
  - FinalState: å¯¹æ¯ä¸ªå­ç³»ç»Ÿå®šä¹‰ required/forbidden æ©ç ï¼ˆrequired: æŒ‡å®šçš„ä½å¿…é¡»éƒ½å­˜åœ¨ï¼›forbidden: æŒ‡å®šä½å¿…é¡»éƒ½ä¸å­˜åœ¨ï¼‰
  - StateMachine: ç®¡ç† FinalState åˆ—è¡¨ï¼Œèƒ½å¤Ÿæ£€æµ‹ä¸€ä¸ª MaskState æ˜¯å¦åŒ¹é…æŸä¸ª FinalState
*/

using Mask = uint32_t;

struct MaskState {
    // subsystems[i] stores the mask for subsystem i
    std::vector<Mask> subsystems;

    MaskState() = default;
    explicit MaskState(size_t n) : subsystems(n, 0u) {}

    size_t size() const { return subsystems.size(); }

    void resize(size_t n) { subsystems.resize(n, 0u); }

    void setBit(size_t subsystemIndex, Mask bitMask) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] |= bitMask;
    }

    void clearBit(size_t subsystemIndex, Mask bitMask) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] &= ~bitMask;
    }

    void assignMask(size_t subsystemIndex, Mask m) {
        assert(subsystemIndex < subsystems.size());
        subsystems[subsystemIndex] = m;
    }

    Mask getMask(size_t subsystemIndex) const {
        assert(subsystemIndex < subsystems.size());
        return subsystems[subsystemIndex];
    }

    std::string toString() const {
        std::ostringstream oss;
        oss << "{ ";
        for (size_t i = 0; i < subsystems.size(); ++i) {
            oss << "S" << i << ":0x" << std::hex << subsystems[i] << std::dec;
            if (i+1 < subsystems.size()) oss << ", ";
        }
        oss << " }";
        return oss.str();
    }
};

// å¯¹æ¯ä¸ªå­ç³»ç»ŸæŒ‡å®š required / forbidden æ©ç 
struct FinalState {
    std::string name;
    std::vector<Mask> required;  // required[i] ä½å¿…é¡»å…¨éƒ¨è¢«è®¾ç½®
    std::vector<Mask> forbidden; // forbidden[i] ä½å¿…é¡»å…¨éƒ¨ä¸º0

    FinalState() = default;
    explicit FinalState(size_t n) : required(n, 0u), forbidden(n, 0u) {}

    bool matches(const MaskState& s) const {
        if (s.size() != required.size()) return false;
        for (size_t i = 0; i < required.size(); ++i) {
            Mask sub = s.getMask(i);
            // æ‰€æœ‰ required ä½éƒ½å¿…é¡»å­˜åœ¨
            if ((sub & required[i]) != required[i]) return false;
            // æ‰€æœ‰ forbidden ä½éƒ½å¿…é¡»ä¸å­˜åœ¨
            if ((sub & forbidden[i]) != 0) return false;
        }
        return true;
    }
};

struct Transition {
    // å¯é€‰ï¼šç”¨æ©ç æè¿°ä»å“ªäº›çŠ¶æ€å¯ä»¥åˆ°è¾¾å“ªäº›çŠ¶æ€
    // ä½¿ç”¨ required/forbidden çš„ç®€å•æ¨¡å¼
    FinalState from;
    FinalState to;
    std::string name;
};

class StateMachine {
public:
    explicit StateMachine(size_t subsystems) : current(subsystems), subsysCount(subsystems) {}

    size_t subsystemCount() const { return subsysCount; }

    void setSubsystemState(size_t idx, Mask mask) {
        current.assignMask(idx, mask);
    }

    void setSubsystemBit(size_t idx, Mask bit) {
        current.setBit(idx, bit);
    }

    void clearSubsystemBit(size_t idx, Mask bit) {
        current.clearBit(idx, bit);
    }

    const MaskState& getCurrent() const { return current; }

    // æ·»åŠ ç»ˆæ€
    void addFinalState(const FinalState& fs) {
        assert(fs.required.size() == subsysCount);
        finalStates.push_back(fs);
    }

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…çš„ final state (å¦‚æœæ²¡æœ‰åˆ™è¿”å› nullptr)
    const FinalState* findMatchingFinalState() const {
        for (const auto& fs : finalStates) {
            if (fs.matches(current)) return &fs;
        }
        return nullptr;
    }

    // æ‰“å°å½“å‰åŒ¹é…æƒ…å†µ
    void printStatus() const {
        std::cout << "Current: " << current.toString() << "\n";
        const FinalState* fs = findMatchingFinalState();
        if (fs) std::cout << "Matches final state: " << fs->name << "\n";
        else std::cout << "No matching final state\n";
    }

private:
    MaskState current;
    size_t subsysCount;
    std::vector<FinalState> finalStates;
};


// ----------------- ç¤ºä¾‹ï¼šå®šä¹‰å­ç³»ç»Ÿstates -----------------
/*
 å‡è®¾æœ‰ä¸¤ä¸ªå­ç³»ç»Ÿï¼š
 S0: bits 0 (IDLE), 1 (RUN), 2 (ERROR)
 S1: bits 0 (OFF), 1 (ON), 2 (SUSPEND)
*/
enum S0Bits : Mask {
    S0_IDLE  = 1u << 0,
    S0_RUN   = 1u << 1,
    S0_ERROR = 1u << 2
};

enum S1Bits : Mask {
    S1_OFF     = 1u << 0,
    S1_ON      = 1u << 1,
    S1_SUSPEND = 1u << 2
};

// ----------------- ä½¿ç”¨ç¤ºä¾‹ -----------------
int main() {
    StateMachine sm(2); // 2 ä¸ªå­ç³»ç»Ÿ

    // è®¾ç½®å½“å‰çŠ¶æ€ï¼šS0 = RUN, S1 = OFF
    sm.setSubsystemState(0, S0_RUN);
    sm.setSubsystemState(1, S1_OFF);
    sm.printStatus();

    // å®šä¹‰ä¸€ä¸ªæœ€ç»ˆçŠ¶æ€ï¼šIdle+On
    FinalState idleOn(2);
    idleOn.name = "Idle+On";
    idleOn.required[0] = S0_IDLE; // S0 å¿…é¡»æ˜¯ IDLE
    idleOn.required[1] = S1_ON;   // S1 å¿…é¡» ON

    // å®šä¹‰ä¸€ä¸ªæœ€ç»ˆçŠ¶æ€ï¼šAny RUN but not ERROR on S0, S1 can be anything
    FinalState runningNoError(2);
    runningNoError.name = "RunWithoutError";
    runningNoError.required[0] = S0_RUN;
    runningNoError.forbidden[0] = S0_ERROR; // S0 ä¸èƒ½æœ‰ ERROR
    // S1 required/forbidden é»˜è®¤ 0

    sm.addFinalState(idleOn);
    sm.addFinalState(runningNoError);

    // æ£€æµ‹ï¼ˆå½“å‰ S0=RUN, S1=OFFï¼‰åº”åŒ¹é… runningNoError
    const FinalState* matched = sm.findMatchingFinalState();
    if (matched) {
        std::cout << "Matched final state: " << matched->name << "\n";
    } else {
        std::cout << "No final state matched\n";
    }

    // æ”¹å˜çŠ¶æ€ä¸º Idle+On
    sm.setSubsystemState(0, S0_IDLE);
    sm.setSubsystemState(1, S1_ON);
    sm.printStatus();
    matched = sm.findMatchingFinalState();
    if (matched) std::cout << "Matched final state: " << matched->name << "\n";

    // å¤åˆä½ç¤ºä¾‹ï¼ˆä¸€ä¸ªå­ç³»ç»ŸåŒæ—¶æœ‰å¤šä¸ªä½ï¼‰
    // å‡å¦‚å…è®¸ S1: ON + SUSPEND åŒæ—¶å­˜åœ¨ï¼ˆæˆ–è¡¨ç¤ºæŸç§å¤åˆï¼‰
    sm.setSubsystemBit(1, S1_ON | S1_SUSPEND);
    std::cout << "After multi-bit set: ";
    sm.printStatus();

    return 0;
}
```

# è¯´æ˜ä¸æ‰©å±•å»ºè®®ï¼ˆçŸ­ï¼‰

* å¦‚æœä½ æœ‰å›ºå®šçš„å…¨å±€ä½æ•°å¹¶ä¸”æƒ³æŠŠæ‰€æœ‰å­ç³»ç»Ÿå‹åˆ°ä¸€ä¸ª `uint64_t` / `std::bitset` ä¸­ä»¥å‡å°‘å†…å­˜ / æå‡æ¯”è¾ƒé€Ÿåº¦ï¼Œå¯ä»¥æŠŠæ¯ä¸ªå­ç³»ç»Ÿåˆ†é…å›ºå®šå®½åº¦å¹¶æ‰“åŒ…ï¼ˆéœ€è¦è®¡ç®—åç§»ï¼‰ã€‚
* å¦‚æœéœ€è¦å¿«é€ŸæŸ¥è¡¨ï¼ˆå¤§é‡ final statesï¼‰ï¼Œå¯ä»¥æŠŠ final state çš„ required/forbidden ç¼–æˆæ›´ç´§å‡‘çš„ key å¹¶ç”¨å“ˆå¸Œç´¢å¼•æˆ–å†³ç­–æ ‘æ¥åŠ é€ŸåŒ¹é…ã€‚
* å¯¹äºå¹¶å‘åœºæ™¯ï¼Œä¿æŠ¤ `StateMachine` å†…éƒ¨çŠ¶æ€çš„è¯»å†™ï¼ˆ`std::mutex` æˆ–åŸå­æ›¿ä»£ï¼‰å³å¯ã€‚
* å¦‚æœä½ æƒ³æ”¯æŒâ€œè‡³å°‘æœ‰ä¸€ä¸ªä½è¢«è®¾ç½®ï¼ˆany-ofï¼‰â€æˆ–â€œè‡³å°‘ k ä¸ªä½è¢«è®¾ç½®â€è¿™ç±»æ›´å¤æ‚çš„è§„åˆ™ï¼Œå¯ä»¥æŠŠ `FinalState.matches` æ‰©å±•ä¸ºæ›´é€šç”¨çš„è°“è¯/å›è°ƒï¼ˆ`std::function<bool(const MaskState&)>`ï¼‰ã€‚

å¦‚æœä½ æƒ³ï¼Œæˆ‘å¯ä»¥ï¼š

* æŠŠæ¯ä¸ªå­ç³»ç»Ÿçš„ä½å®šä¹‰ç”± `enum class` + `scoped helper` æ›´ç±»å‹å®‰å…¨åŒ–ï¼›
* æä¾›å°†å¤šå­ç³»ç»Ÿå‹ç¼©åˆ°ä¸€ä¸ª `uint64_t` çš„å®ç°ï¼ˆé€‚åˆå­ç³»ç»Ÿå°‘ä¸”ä½æ•°å›ºå®šçš„åœºæ™¯ï¼‰ï¼›
* æˆ–è€…æŠŠ `FinalState` çš„åŒ¹é…æ‰©å±•æˆæ”¯æŒ "è‡³å°‘ä¸€ä¸ªåŒ¹é… (anyOf)"ã€"å…¨éƒ¨åŒ¹é… (allOf)"ã€"äº’æ–¥ (xor)" ç­‰æ›´å¤æ‚å¸ƒå°”è¡¨è¾¾å¼çš„é¢†åŸŸè¯­è¨€ï¼ˆDSLï¼‰ã€‚

è¦å“ªä¸ªæ‰©å±•æˆ‘ç›´æ¥åœ¨è¿™ä¸ªæ¡†æ¶ä¸Šåšä¸€ä¸ªç‰ˆæœ¬ç»™ä½ ï¼Ÿ
éå¸¸å¥½ ğŸ‘ â€”â€”è¿™ä¸€æ­¥æ˜¯**æ©ç çŠ¶æ€è¡¨ç¤ºè¿›é˜¶è®¾è®¡çš„å…³é”®ä¼˜åŒ–ä¹‹ä¸€**ï¼š

é€šè¿‡ä½¿ç”¨ **`enum class` + å¼ºç±»å‹è¾…åŠ©å‡½æ•°ï¼ˆscoped helperï¼‰**ï¼Œæˆ‘ä»¬èƒ½æ˜¾è‘—æå‡ç±»å‹å®‰å…¨ã€å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œé¿å…â€œä¸åŒå­ç³»ç»Ÿä½å®šä¹‰äº’ç›¸æ±¡æŸ“â€çš„é—®é¢˜ã€‚

---

## ğŸ¯ æ”¹è¿›ç›®æ ‡

* ç”¨ **`enum class`** ä¸ºæ¯ä¸ªå­ç³»ç»Ÿå®šä¹‰çŠ¶æ€ä½ï¼›
* ç”¨æ¨¡æ¿åŒ– `MaskHelper<T>` æä¾›ï¼š

  * ä½æ©ç è®¡ç®— (`bit(e)`)
  * çŠ¶æ€ç»„åˆ (`combine(e1, e2, ...)`)
  * åˆ¤æ–­ (`has(mask, e)`)
* `StateMachine`ã€`MaskState` ç­‰æ ¸å¿ƒç»“æ„ä¾ç„¶ä¿æŒé€šç”¨ï¼Œä½† **ç±»å‹å®‰å…¨åŒ–æ¥å£**ï¼›
* æ”¯æŒå¼ºç±»å‹ä¸‹çš„è‡ªåŠ¨è½¬æ¢ï¼ˆé€šè¿‡æ¨¡æ¿çº¦æŸï¼Œé˜²æ­¢ä¼ é”™æšä¸¾ç±»å‹ï¼‰ã€‚

---

## âœ… å®Œæ•´å¯ç¼–è¯‘ç¤ºä¾‹ï¼šç±»å‹å®‰å…¨æ©ç çŠ¶æ€æ¡†æ¶

ä¿å­˜ä¸º `mask_state_typed.cpp`ï¼š

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstdint>
#include <cassert>
#include <sstream>
#include <type_traits>

// ============ åŸºç¡€ç±»å‹å®šä¹‰ ============
using Mask = uint32_t;

// -----------------------------
// Scoped enum + helper æ¨¡æ¿
// -----------------------------
template <typename Enum>
struct MaskHelper {
    static_assert(std::is_enum_v<Enum>, "MaskHelper requires enum type");

    using U = std::underlying_type_t<Enum>;

    // è·å–å•ä¸ªbit
    static constexpr Mask bit(Enum e) noexcept {
        return static_cast<Mask>(1u << static_cast<U>(e));
    }

    // ç»„åˆå¤šä¸ªbit
    template <typename... Enums>
    static constexpr Mask combine(Enums... es) noexcept {
        return (bit(es) | ...);
    }

    // æ£€æŸ¥maskæ˜¯å¦åŒ…å«æŸä½
    static constexpr bool has(Mask mask, Enum e) noexcept {
        return (mask & bit(e)) != 0;
    }
};

// ================== å­ç³»ç»Ÿå®šä¹‰ ==================

// å­ç³»ç»Ÿ0: ä¸»ç³»ç»ŸçŠ¶æ€
enum class Sys0 : uint8_t {
    Idle = 0,
    Run  = 1,
    Error = 2,
};

// å­ç³»ç»Ÿ1: ç”µæºçŠ¶æ€
enum class Sys1 : uint8_t {
    Off = 0,
    On  = 1,
    Suspend = 2,
};

// ä¸ºç®€åŒ–ä½¿ç”¨å®šä¹‰åˆ«å
using H0 = MaskHelper<Sys0>;
using H1 = MaskHelper<Sys1>;

// ================== æ©ç çŠ¶æ€ç±» ==================
struct MaskState {
    std::vector<Mask> subsystems;

    explicit MaskState(size_t n) : subsystems(n, 0u) {}
    size_t size() const { return subsystems.size(); }

    void assign(size_t idx, Mask m) {
        assert(idx < subsystems.size());
        subsystems[idx] = m;
    }

    Mask get(size_t idx) const {
        assert(idx < subsystems.size());
        return subsystems[idx];
    }

    std::string toString() const {
        std::ostringstream oss;
        oss << "{ ";
        for (size_t i = 0; i < subsystems.size(); ++i) {
            oss << "S" << i << ":0x" << std::hex << subsystems[i] << std::dec;
            if (i + 1 < subsystems.size()) oss << ", ";
        }
        oss << " }";
        return oss.str();
    }
};

// ================== ç»ˆæ€åŒ¹é…ç±» ==================
struct FinalState {
    std::string name;
    std::vector<Mask> required;
    std::vector<Mask> forbidden;

    explicit FinalState(size_t n) : required(n, 0u), forbidden(n, 0u) {}

    bool matches(const MaskState& s) const {
        if (s.size() != required.size()) return false;
        for (size_t i = 0; i < s.size(); ++i) {
            Mask m = s.get(i);
            if ((m & required[i]) != required[i]) return false;
            if ((m & forbidden[i]) != 0) return false;
        }
        return true;
    }
};

// ================== çŠ¶æ€æœº ==================
class StateMachine {
public:
    explicit StateMachine(size_t subs) : current(subs), subsysCount(subs) {}

    template <typename Enum>
    void set(size_t idx, Enum e) {
        assert(idx < subsysCount);
        current.assign(idx, MaskHelper<Enum>::bit(e));
    }

    template <typename Enum, typename... Enums>
    void setMulti(size_t idx, Enum e, Enums... es) {
        assert(idx < subsysCount);
        current.assign(idx, MaskHelper<Enum>::combine(e, es...));
    }

    const MaskState& state() const { return current; }

    void addFinal(const FinalState& fs) {
        finalStates.push_back(fs);
    }

    const FinalState* match() const {
        for (const auto& f : finalStates)
            if (f.matches(current))
                return &f;
        return nullptr;
    }

    void print() const {
        std::cout << "Current: " << current.toString() << "\n";
        const FinalState* fs = match();
        if (fs)
            std::cout << " â†’ Matched: " << fs->name << "\n";
        else
            std::cout << " â†’ No match\n";
    }

private:
    MaskState current;
    size_t subsysCount;
    std::vector<FinalState> finalStates;
};

// ================== ä½¿ç”¨ç¤ºä¾‹ ==================
int main() {
    StateMachine sm(2); // ä¸¤ä¸ªå­ç³»ç»Ÿ

    // å®šä¹‰ç»ˆæ€1ï¼šIdle+On
    FinalState idleOn(2);
    idleOn.name = "Idle+On";
    idleOn.required[0] = H0::bit(Sys0::Idle);
    idleOn.required[1] = H1::bit(Sys1::On);

    // å®šä¹‰ç»ˆæ€2ï¼šRun but no Error
    FinalState running(2);
    running.name = "Running(NoError)";
    running.required[0] = H0::bit(Sys0::Run);
    running.forbidden[0] = H0::bit(Sys0::Error);

    sm.addFinal(idleOn);
    sm.addFinal(running);

    // å½“å‰çŠ¶æ€: Run + Off
    sm.set<Sys0>(0, Sys0::Run);
    sm.set<Sys1>(1, Sys1::Off);
    sm.print();

    // åˆ‡æ¢ä¸º Idle + On
    sm.set<Sys0>(0, Sys0::Idle);
    sm.set<Sys1>(1, Sys1::On);
    sm.print();

    // å¤åˆçŠ¶æ€ï¼šSys1 åŒæ—¶ On + Suspend
    sm.setMulti<Sys1>(1, Sys1::On, Sys1::Suspend);
    sm.print();

    // æ£€æŸ¥æ˜¯å¦åŒ…å«æŸä½
    Mask m = H1::combine(Sys1::On, Sys1::Suspend);
    std::cout << "Mask has On? " << H1::has(m, Sys1::On) << "\n";
}
```

---

## ğŸ§© æ ¸å¿ƒæ”¹è¿›ç‚¹è¯´æ˜

| æ”¹è¿›ç‚¹  | æ—§ç‰ˆåšæ³•             | æ–°ç‰ˆåšæ³•                           |                                  |
| ---- | ---------------- | ------------------------------ | -------------------------------- |
| ä½å®šä¹‰  | `enum` å…¨å±€ä½œç”¨åŸŸï¼Œæ˜“å†²çª | `enum class` å¼ºç±»å‹ä½œç”¨åŸŸ            |                                  |
| ç±»å‹å®‰å…¨ | å…¨é äººå·¥åŒºåˆ†           | æ¨¡æ¿çº¦æŸ + scoped helper é˜²æ­¢è¯¯ä¼ ç±»å‹    |                                  |
| æ©ç æ“ä½œ | æ‰‹å†™ç§»ä½å¸¸é‡           | è‡ªåŠ¨æ¨å¯¼ `MaskHelper<Enum>::bit()` |                                  |
| å¯ç»„åˆæ€§ | é€šè¿‡ `             | ` æ‰‹å†™                           | `MaskHelper::combine()` æ”¯æŒä»»æ„æšä¸¾ç»„åˆ |
| åŒ¹é…è¯­ä¹‰ | äºŒè¿›åˆ¶æ©ç å¯¹æ¯”          | ç±»å‹å®‰å…¨ï¼Œæ”¯æŒè·¨ subsystem åŒºåˆ†          |                                  |

---

## ğŸ§  å¯æ‰©å±•æ–¹å‘

1. **æ³›å‹åŒ– StateMachineï¼š**

   ```cpp
   template<typename... Subsystems>
   class TypedStateMachine;
   ```

   å¯è‡ªåŠ¨æ ¹æ®æ¨¡æ¿å‚æ•°æ•°é‡ç”Ÿæˆå†…éƒ¨å‘é‡ã€‚

2. **constexpr æ”¯æŒï¼š**
   æ‰€æœ‰ MaskHelper æ“ä½œéƒ½å¯ constexprï¼Œä½¿ç¼–è¯‘æœŸå°±èƒ½ç”Ÿæˆæ©ç è¡¨ã€‚

3. **æ·»åŠ è¯­ä¹‰å±‚å°è£…ï¼š**
   æä¾› DSLï¼Œå¦‚ï¼š

   ```cpp
   sm.when(Sys0::Run).andNot(Sys0::Error).then("Running(NoError)");
   ```

4. **è‡ªåŠ¨ç”Ÿæˆæšä¸¾åˆ°å­—ç¬¦ä¸²æ˜ å°„ï¼š**
   æ–¹ä¾¿è°ƒè¯•æ‰“å°ï¼Œå¯ç”¨å®æˆ– `magic_enum` å®ç°ã€‚

---

æ˜¯å¦å¸Œæœ›æˆ‘åœ¨è¿™ä¸ªåŸºç¡€ä¸Šå†å‡çº§ä¸º **â€œæ³›å‹ StateMachine<Subsystem0, Subsystem1, â€¦>â€** ç‰ˆæœ¬ï¼ˆæ”¯æŒç±»å‹è‡ªåŠ¨æ¨å¯¼ã€æ— ç´¢å¼•è®¿é—®ï¼‰ï¼Ÿ
ä¾‹å¦‚ï¼š`sm.set<Sys0>(Sys0::Run)` è€Œæ— éœ€æŒ‡å®šç´¢å¼•ï¼Ÿ
