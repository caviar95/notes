# çŠ¶æ€æ˜ å°„å®ç°æ–¹æ¡ˆ

* é¢å‘æŠ€æœ¯å§”å‘˜ä¼šè¯„å®¡ / ä¸“å®¶æ±‡æŠ¥
* åŒ…å«ä¼ªä»£ç  & C++ å®ç°ç¤ºä¾‹
* ä¸‰ç§æ–¹æ¡ˆï¼ˆæšä¸¾ã€æ©ç ã€è¡¨é©±åŠ¨ï¼‰å…¨å¯¹æ¯”
* å«â€œåˆæ³•æ€§åˆ¤æ–­ / è·å–åˆæ³•çŠ¶æ€â€å®ç°é¡µ

## èƒŒæ™¯ä¸é—®é¢˜

* ç³»ç»Ÿç”±å¤šä¸ªå­ç³»ç»ŸçŠ¶æ€ç»„æˆï¼Œæ€»çŠ¶æ€ç»„åˆçˆ†ç‚¸
* åˆæ³•çŠ¶æ€éœ€äººå·¥æšä¸¾æˆ–ç¡¬ç¼–ç æ˜ å°„ï¼Œå®¹æ˜“é—æ¼
* ç›®æ ‡ï¼šæ‰¾åˆ°**å¯æ‰©å±•ã€æ˜“ç»´æŠ¤ã€æ˜“éªŒè¯**çš„çŠ¶æ€æ˜ å°„æœºåˆ¶

## æ–¹æ¡ˆ

### æ–¹æ¡ˆ1 æšä¸¾åˆæ³•çŠ¶æ€ç»„åˆ

* æè¿°æ–¹å¼ï¼š`enum class` + æŸ¥è¡¨
* åˆ¤æ–­é€»è¾‘ï¼šéå†åˆæ³•ç»„åˆè¡¨
* C++ ç¤ºä¾‹ï¼š

  ```cpp
  enum class CommState { Idle, Active };
  enum class PowerState { Off, On };
  struct SystemState { CommState comm; PowerState power; };
  static const std::vector<SystemState> validStates = {
      {CommState::Idle, PowerState::Off},
      {CommState::Active, PowerState::On}
  };
  bool isLegal(const SystemState& s) {
      return std::find(validStates.begin(), validStates.end(), s) != validStates.end();
  }
  ```
* ä¼˜ç‚¹ï¼šé€»è¾‘ç›´è§‚
* ç¼ºç‚¹ï¼šç»„åˆçˆ†ç‚¸ã€ç»´æŠ¤ç¹çã€æ‰€æœ‰çŠ¶æ€ç»„åˆæ”¾åœ¨ä¸€èµ·ï¼Œä¸åˆ©äºå¯è¯»æ€§

### æ–¹æ¡ˆ2 æ©ç è¡¨ç¤º

* æè¿°æ–¹å¼ï¼šæ¯ä¸ªå­ç³»ç»ŸçŠ¶æ€ä½¿ç”¨è‹¥å¹² bit è¡¨ç¤º
* åˆ¤æ–­é€»è¾‘ï¼šæŒ‰ä½åŒ¹é…åˆæ³•æ©ç 
* C++ ç¤ºä¾‹ï¼š

  ```cpp
  using StateMask = uint32_t;
  constexpr StateMask COMM_ACTIVE = 1 << 0;
  constexpr StateMask POWER_ON = 1 << 1;
  constexpr StateMask LEGAL = COMM_ACTIVE | POWER_ON;
  bool isLegal(StateMask s) { return (s & LEGAL) == LEGAL; }
  ```
* ä¼˜ç‚¹ï¼šæ•ˆç‡é«˜ã€å­˜å‚¨ç´§å‡‘
* ç¼ºç‚¹ï¼šå¯è¯»æ€§å·®ã€è·¨æ¨¡å—æ‰©å±•å›°éš¾

è™½ç„¶æ©ç é«˜æ•ˆï¼Œä½†ä¼šéšå«äº§ç”Ÿéé¢„æœŸçŠ¶æ€ç»„åˆï¼ˆéæ³•ç»„åˆï¼‰
è¡¨é¢ä¸Šçœ‹ï¼Œè¿™ç§ç»„åˆæ—¢ç®€æ´åˆé«˜æ•ˆï¼ˆæŒ‰ä½æˆ–ç»„åˆã€æŒ‰ä½ä¸åˆ¤æ–­ï¼‰ï¼Œä½†é—®é¢˜æ˜¯ï¼š æ©ç æœ¬èº«æ˜¯**è‡ªç”±ç»„åˆ**çš„ï¼Œä¸å…·å¤‡â€œåˆæ³•æ€§çº¦æŸâ€ï¼Œå› æ­¤ç†è®ºä¸Šå¯ä»¥ç»„åˆå‡ºæ— æ„ä¹‰çš„çŠ¶æ€ã€‚

é—®é¢˜åŸå› 

1. **æ©ç å¤©ç„¶æ˜¯æ‰å¹³ç©ºé—´**
   å®ƒæ— æ³•è¡¨è¾¾â€œæ¯ä¸ªå­ç³»ç»Ÿå†…åªèƒ½é€‰ä¸€ä¸ªçŠ¶æ€â€çš„çº¦æŸã€‚

2. **ç¼ºä¹åˆæ³•æ€§éªŒè¯æœºåˆ¶**
   æ©ç é€»è¾‘å±‚åªåšæŒ‰ä½åˆ¤æ–­ï¼Œä¸å…³å¿ƒçŠ¶æ€é—´é€»è¾‘ã€‚

3. **å¤šå­ç³»ç»Ÿä¹‹é—´ç¼ºä¹çº¦æŸè¡¨è¾¾èƒ½åŠ›**
   æ— æ³•ç›´æ¥è¡¨ç¤ºè·¨å­ç³»ç»Ÿç»„åˆæ˜¯å¦å…è®¸ï¼ˆä¾‹å¦‚ï¼šPower=Off æ—¶ Comm ä¸èƒ½ Activeï¼‰ã€‚



### æ–¹æ¡ˆ3 è¡¨é©±åŠ¨ / å±‚çº§çŠ¶æ€æ˜ å°„

* æè¿°æ–¹å¼ï¼šçŠ¶æ€èŠ‚ç‚¹ + è½¬ç§»è¡¨
* æ”¯æŒå±‚çº§ç»§æ‰¿ä¸åŠ¨æ€æ‰©å±•
* C++ ç¤ºä¾‹ï¼š

  ```cpp
  struct StateNode {
      std::string name;
      std::vector<std::string> allowedTransitions;
      bool canTransitTo(const std::string& next) const {
          return std::find(allowedTransitions.begin(), allowedTransitions.end(), next)
                 != allowedTransitions.end();
      }
  };
  std::map<std::string, StateNode> stateTable = {
      {"Idle", {"Idle", {"Active"}}},
      {"Active", {"Active", {"Idle", "Error"}}}
  };
  bool isLegalTransition(const std::string& cur, const std::string& next) {
      return stateTable[cur].canTransitTo(next);
  }
  ```
* å¯é€šè¿‡ JSON é…ç½®é©±åŠ¨çŠ¶æ€è¡¨ï¼Œæ— éœ€æ”¹ä»£ç å³å¯æ‰©å±•
* å¯é›†æˆæ©ç ç”¨äºè¿è¡Œæ—¶é«˜æ•ˆåˆ¤æ–­

### å¯¹æ¯”

| åŠŸèƒ½     | æšä¸¾æ–¹æ¡ˆ    | æ©ç æ–¹æ¡ˆ     | è¡¨é©±åŠ¨æ–¹æ¡ˆ     |
| ------ | ------- | -------- | --------- |
| è·å–åˆæ³•çŠ¶æ€ | éå†é™æ€è¡¨   | è®¡ç®—æ©ç ç»„åˆ   | åŠ¨æ€é…ç½®æˆ–æ³¨å†Œ   |
| åˆ¤æ–­åˆæ³•æ€§  | O(n) æŸ¥è¡¨ | O(1) ä½è¿ç®— | O(1) å“ˆå¸ŒæŸ¥æ‰¾ |

## æ€»ç»“

* æ¨èé‡‡ç”¨ **è¡¨é©±åŠ¨ + æ©ç æ··åˆæ¨¡å¼**ï¼š

  * é…ç½®å±‚ï¼šè¡¨é©±åŠ¨åˆæ³•ç»„åˆ
  * è¿è¡Œå±‚ï¼šæ©ç å¿«é€Ÿåˆ¤æ–­
* æ”¯æŒæ’ä»¶å¼æ‰©å±•ä¸çƒ­æ›´æ–°
* ç»“åˆ JSON/Proto å¯å®ç°è·¨è¯­è¨€å…±äº«çŠ¶æ€æè¿°

å¥½çš„ ğŸ‘ æˆ‘æ¥å¸®ä½ æ•´ç†ä¸€ä»½å¯ä»¥ç›´æ¥æ±‡æŠ¥æˆ–å¤´è„‘é£æš´ä½¿ç”¨çš„ **PPT æ–¹æ¡ˆç»“æ„**ï¼ˆå«è®²è§£è¦ç‚¹ä¸C++å®ç°æ€è·¯ï¼‰ï¼Œä¸»é¢˜æ˜¯ï¼š

> **â€œæ©ç çŠ¶æ€ç»„åˆ vs å®Œå…¨æšä¸¾æ–¹æ¡ˆ â€”â€” çŠ¶æ€æ˜ å°„ä¸æ€§èƒ½ä¼˜åŒ–æ¢ç´¢â€**

---

## ğŸ¯ PPT ç›®æ ‡

é¢å‘æŠ€æœ¯è¯„å®¡/æ¶æ„è®¨è®ºï¼Œå±•ç¤ºï¼š

1. ä¸ºä»€ä¹ˆè¦ä»**å®Œå…¨æšä¸¾**è½¬å‘**æ©ç è¡¨ç¤º**ï¼›
2. æ©ç æ–¹å¼çš„ä¼˜åŠ¿ä¸å±€é™ï¼›
3. æ–°çš„æŠ˜ä¸­è®¾è®¡æ–¹æ¡ˆï¼ˆç»“åˆæ©ç  + ç´¢å¼•è¡¨ + åˆæ³•æ€§è¿‡æ»¤ï¼‰ã€‚

---

## ğŸ§© ç¬¬ä¸€éƒ¨åˆ†ï¼šèƒŒæ™¯é—®é¢˜ â€”â€” çŠ¶æ€çˆ†ç‚¸

### ğŸ“é—®é¢˜å®šä¹‰

* ç³»ç»Ÿæ€»çŠ¶æ€ç”± **4ä¸ªå­ç³»ç»Ÿ** å…±åŒå†³å®šï¼š

  ```
  System = f(Sub1, Sub2, Sub3, Sub4)
  ```
* æ¯ä¸ªå­ç³»ç»Ÿæœ€å¤š 15 ç§çŠ¶æ€
  â†’ ç†è®ºç»„åˆæ•°ï¼š15â´ = **50,625ç§çŠ¶æ€**

### âš ï¸ é—®é¢˜ç‚¹

* å®é™…åˆæ³•çŠ¶æ€ä»…çº¦å‡ ç™¾ç§ï¼›
* å®Œå…¨æšä¸¾æ–¹æ¡ˆï¼š

  * éœ€ç»´æŠ¤å·¨å¤§æ˜ å°„è¡¨ï¼›
  * å¢åŠ çŠ¶æ€/å­ç³»ç»Ÿæ—¶ææ˜“é—æ¼æˆ–å‡ºé”™ï¼›
  * çŠ¶æ€ç©ºé—´ç¨€ç–ï¼Œæµªè´¹å†…å­˜ã€‚

---

## ğŸ§± ç¬¬äºŒéƒ¨åˆ†ï¼šå®Œå…¨æšä¸¾æ–¹æ¡ˆ

### ğŸ”¹è®¾è®¡æ€è·¯

```cpp
struct StateKey {
    Sub1State s1;
    Sub2State s2;
    Sub3State s3;
    Sub4State s4;
};
std::map<StateKey, FinalState> stateMap;
```

### ğŸ”¹ä¼˜ç‚¹

* ç²¾ç¡®æ˜ å°„ï¼›
* æŸ¥æ‰¾ O(logN)ï¼›
* åˆæ³•æ€§å¤©ç„¶ä¿è¯ï¼ˆå› ä¸ºåªå­˜åˆæ³•ç»„åˆï¼‰ã€‚

### ğŸ”¹ç¼ºç‚¹

* æ•°æ®è†¨èƒ€ï¼›
* æ–°çŠ¶æ€æ‰©å±•å›°éš¾ï¼›
* é€»è¾‘å¯è¯»æ€§å·®ï¼ˆæšä¸¾è¡¨è¶Šå†™è¶Šå¤§ï¼‰ã€‚

---

## ğŸ§® ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ©ç è¡¨ç¤ºæ–¹æ¡ˆ

### ğŸ”¹åŸºæœ¬æ€è·¯

* æ¯ä¸ªå­ç³»ç»ŸçŠ¶æ€ç”¨ä½æ©ç ï¼ˆbitmaskï¼‰è¡¨ç¤ºï¼›

* é«˜å±‚çŠ¶æ€ä½¿ç”¨ç»„åˆæ©ç ï¼š

  ```cpp
  // æ¯ä¸ªå­ç³»ç»Ÿ15ç§çŠ¶æ€ => ç”¨16ä½æ©ç å³å¯
  using Mask = uint64_t;

  Mask sub1Mask = (1 << Sub1_1) | (1 << Sub1_2);   // Sub1 å¯å¤„äº1æˆ–2
  Mask sub2Mask = (1 << Sub2_1);
  Mask sub3Mask = (1 << Sub3_1);
  Mask sub4Mask = (1 << Sub4_1);
  ```

* å½¢æˆé«˜å±‚çŠ¶æ€å®šä¹‰ï¼š

  ```cpp
  struct FinalMapping {
      Mask s1Mask, s2Mask, s3Mask, s4Mask;
      FinalState target;
  };
  std::vector<FinalMapping> mappingTable;
  ```

---

## âš™ï¸ ç¬¬å››éƒ¨åˆ†ï¼šæ©ç åŒ¹é…é€»è¾‘

### ğŸ”¹åŒ¹é…ç®—æ³•

```cpp
FinalState resolve(StateKey key) {
    for (auto &m : mappingTable) {
        if ((m.s1Mask & (1 << key.s1)) &&
            (m.s2Mask & (1 << key.s2)) &&
            (m.s3Mask & (1 << key.s3)) &&
            (m.s4Mask & (1 << key.s4))) {
            return m.target;
        }
    }
    return FinalState::INVALID;
}
```

### ğŸ”¹ä¼˜ç‚¹

* çŠ¶æ€ç»„åˆå¯å‹ç¼©ï¼ˆé€»è¾‘æ€§å¼ºï¼‰ï¼›
* å¤šçŠ¶æ€å½’å¹¶ä¸ºåŒä¸€FinalStateï¼›
* ç»´æŠ¤é‡æ˜¾è‘—å‡å°‘ã€‚

### ğŸ”¹ç¼ºç‚¹

* åŒ¹é…æ•ˆç‡ O(M)ï¼›
* å­˜åœ¨éæ³•ç»„åˆéœ€é¢å¤–æ’é™¤ï¼›
* éš¾ä»¥ç›´æ¥ç´¢å¼•ï¼ˆæ— æ³•ä½¿ç”¨mapäºŒåˆ†ï¼‰ã€‚

---

## ğŸš« ç¬¬äº”éƒ¨åˆ†ï¼šéæ³•ç»„åˆé—®é¢˜

### ğŸ“åœºæ™¯

> Sub1_1 | Sub1_2, Sub2_1 | Sub2_2, Sub3_1, Sub4_1
> å…¶ä¸­ (Sub1_1, Sub2_2, Sub3_1, Sub4_1) å±äºéæ³•ç»„åˆã€‚

### ğŸ”¹è§£å†³æ€è·¯

* **å¢åŠ æ’é™¤è¡¨ï¼ˆExclusion Tableï¼‰**

  ```cpp
  struct Exclusion {
      Sub1State s1;
      Sub2State s2;
      Sub3State s3;
      Sub4State s4;
  };
  std::vector<Exclusion> exclusionList;
  ```

* åŒ¹é…æ—¶å¢åŠ æ ¡éªŒï¼š

  ```cpp
  bool isExcluded(StateKey key) {
      for (auto &ex : exclusionList)
          if (ex.s1 == key.s1 && ex.s2 == key.s2 && ex.s3 == key.s3 && ex.s4 == key.s4)
              return true;
      return false;
  }
  ```

---

## ğŸ§  ç¬¬å…­éƒ¨åˆ†ï¼šå­ç³»ç»Ÿå¤šæ˜ å°„é—®é¢˜

### ğŸ“åœºæ™¯æ‰©å±•

* Sub1_1 å¯èƒ½å¯¹åº” Final1ï¼›
* Sub1_2 å¯èƒ½å¯¹åº” Final2ï¼›
* åŒä¸€å­ç³»ç»ŸçŠ¶æ€ï¼Œä¸åŒä¸Šä¸‹æ–‡æ˜ å°„ä¸åŒç»“æœã€‚

### ğŸ”¹æ”¹è¿›æ–¹æ¡ˆ

1. **æ©ç è¡¨ + ä¼˜å…ˆçº§ï¼ˆpriorityï¼‰**

   ```cpp
   struct FinalMapping {
       Mask s1Mask, s2Mask, s3Mask, s4Mask;
       FinalState target;
       int priority;
   };
   ```

   * æŒ‰ä¼˜å…ˆçº§åŒ¹é…ï¼›
   * å…è®¸è¦†ç›–æˆ–åˆ†å±‚ã€‚

2. **å±€éƒ¨ä¸Šä¸‹æ–‡çº¦æŸ**

   * å¼•å…¥ `ContextID`ï¼ˆå¦‚â€œä¸Šä½æœºAâ€ã€â€œä¸Šä½æœºBâ€ï¼‰ï¼›
   * åœ¨æ©ç åŒ¹é…ä¸­åŠ å…¥ï¼š

     ```cpp
     if (m.context == ctx && maskMatch(...))
         return m.target;
     ```

---

## âš¡ ç¬¬ä¸ƒéƒ¨åˆ†ï¼šç»¼åˆæ€§èƒ½åˆ†æ

| æŒ‡æ ‡    | å®Œå…¨æšä¸¾    | æ©ç æ–¹å¼  | ä¼˜åŒ–æ©ç æ–¹å¼ï¼ˆç´¢å¼•+æ©ç ï¼‰ |
| ----- | ------- | ----- | ------------- |
| æŸ¥æ‰¾å¤æ‚åº¦ | O(logN) | O(M)  | O(logK + M')  |
| ç»´æŠ¤æˆæœ¬  | é«˜       | ä¸­     | ä¸­             |
| å¯æ‰©å±•æ€§  | å·®       | å¥½     | å¥½             |
| åˆæ³•æ€§ä¿éšœ | å¤©ç„¶ä¿éšœ    | éœ€é¢å¤–éªŒè¯ | å¯é€šè¿‡åˆæ³•è¡¨ä¿è¯      |
| å¯è¯»æ€§   | å·®       | å¥½     | å¥½             |

---

## ğŸš€ ç¬¬å…«éƒ¨åˆ†ï¼šæŠ˜ä¸­ä¼˜åŒ–æ–¹æ¡ˆï¼ˆæ¨èï¼‰

### ğŸ”¹æ··åˆç´¢å¼• + æ©ç æ–¹æ¡ˆ

* æŒ‰ä¸»å­ç³»ç»Ÿï¼ˆSub1ï¼‰é¢„å»ºç´¢å¼•è¡¨ï¼›
* æ¯ä¸ªç´¢å¼•ä¸‹ä¿å­˜å¯¹åº”æ©ç ç»„åˆï¼›
* ä¼˜å…ˆçº§ + æ’é™¤è¡¨ä¿è¯åˆæ³•æ€§ï¼›
* æŸ¥æ‰¾è·¯å¾„ï¼š
  **O(logK) å®šä½ç´¢å¼• + O(M') æ©ç åŒ¹é…**

### ğŸ”¹ç¤ºæ„ä»£ç 

```cpp
std::unordered_map<Sub1State, std::vector<FinalMapping>> indexedMap;

FinalState resolve(StateKey key) {
    auto it = indexedMap.find(key.s1);
    if (it == indexedMap.end()) return INVALID;
    for (auto &m : it->second) {
        if (maskMatch(m, key) && !isExcluded(key))
            return m.target;
    }
    return INVALID;
}
```

---

## ğŸ§© ç¬¬ä¹éƒ¨åˆ†ï¼šç¤ºä¾‹å¯¹æ¯”

| åœºæ™¯     | æšä¸¾æ•°é‡         | æ˜ å°„è¡¨é¡¹æ•°ï¼ˆæ©ç ï¼‰ |
| ------ | ------------ | --------- |
| åŸå§‹çŠ¶æ€ç©ºé—´ | 15â´ = 50,625 | â€”         |
| å®é™…æœ‰æ•ˆçŠ¶æ€ | 600          | â€”         |
| æ©ç å‹ç¼©å  | â€”            | â‰ˆ40â€“60    |
| å‡å°‘æ¯”ä¾‹   | â€”            | **çº¦90%+** |

---

## âœ… ç¬¬åéƒ¨åˆ†ï¼šæ€»ç»“

| ç»´åº¦          | æ¨èæ–¹æ¡ˆ         |
| ----------- | ------------ |
| çŠ¶æ€è§„æ¨¡ < 100  | ç›´æ¥å®Œå…¨æšä¸¾ï¼ˆç»´æŠ¤ç®€å•ï¼‰ |
| çŠ¶æ€è§„æ¨¡ > 1000 | æ©ç æ–¹å¼ï¼ˆé€»è¾‘æŠ½è±¡ä¼˜åŠ¿ï¼‰ |
| å­˜åœ¨éæ³•ç»„åˆ      | åŠ æ’é™¤è¡¨         |
| åŒæ€å¤šæ˜ å°„       | å¢ä¼˜å…ˆçº§æˆ–ä¸Šä¸‹æ–‡æ ‡è¯†   |
| æ€§èƒ½å…³é”®è·¯å¾„      | ç»“åˆç´¢å¼•è¡¨ + æ©ç æ–¹å¼ |

---

## ğŸ“˜ é™„å½•ï¼šç¤ºä¾‹ä»£ç å·¥ç¨‹ç»“æ„

```
/state_mapping_demo/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ state_defs.h
â”‚   â”œâ”€â”€ final_mapping.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ mapping_table.cpp
â”‚   â”œâ”€â”€ exclusion.cpp
â”‚   â”œâ”€â”€ resolver.cpp
â””â”€â”€ CMakeLists.txt
```

---

æ˜¯å¦å¸Œæœ›æˆ‘ç›´æ¥å¸®ä½ ç”Ÿæˆè¿™ä»½PPTçš„ **å¯æ±‡æŠ¥ç‰ˆæœ¬ï¼ˆ.pptx æ–‡ä»¶ï¼‰**ï¼Ÿ
æˆ‘å¯ä»¥è‡ªåŠ¨å°†ä¸Šè¿°å†…å®¹æ ¼å¼åŒ–ä¸ºå¹»ç¯ç‰‡ï¼ˆå«ä»£ç å—ä¸è¡¨æ ¼ï¼‰ï¼Œå¯ç”¨äºé¢†å¯¼æˆ–ä¸“å®¶è¯„å®¡ã€‚

éå¸¸å¥½çš„é—®é¢˜ã€‚ä½ å·²ç»è§¦åŠâ€œ**å¤šå­ç³»ç»ŸçŠ¶æ€ç»„åˆåˆæ³•æ€§ç”Ÿæˆ**â€çš„æ ¸å¿ƒï¼š
ä¸ä»…ä»…æ˜¯â€œå„å­ç³»ç»Ÿçš„å½“å‰çŠ¶æ€ç»„åˆâ€ï¼Œè¿˜æ¶‰åŠ **æ“ä½œé¡ºåº**ï¼ˆä¹Ÿå°±æ˜¯çŠ¶æ€æµè½¬çš„è·¯å¾„ä¾èµ–ï¼‰ã€‚
ä¸‹é¢æˆ‘å°†ç³»ç»Ÿæ€§åœ°å¸®ä½ æ¢³ç†æ•´ä¸ªæ€è·¯ï¼Œå¹¶ç»™å‡ºä¸€å¥—â€œå¯è‡ªåŠ¨ç”Ÿæˆåˆæ³•çŠ¶æ€ç»„åˆ / è¯†åˆ«ä¸åˆæ³•çŠ¶æ€â€çš„é€šç”¨æ–¹æ³•ï¼ˆé€‚ç”¨äºæ©ç æˆ–æšä¸¾ä¸¤ç§å®ç°ï¼‰ã€‚

---

## ğŸ§© èƒŒæ™¯å®šä¹‰

å‡è®¾ç³»ç»Ÿç”±å¤šä¸ª**å­ç³»ç»Ÿï¼ˆSubsystemï¼‰**ç»„æˆï¼š

```
System = Sub1 Ã— Sub2 Ã— Sub3 Ã— ...
```

æ¯ä¸ªå­ç³»ç»Ÿéƒ½æœ‰ä¸€ç»„çŠ¶æ€ï¼ˆé€šå¸¸å¯åˆ†ä¸ºä¸‰ç±»ï¼‰ï¼š

| ç±»å‹                     | å«ä¹‰                                     |
| ---------------------- | -------------------------------------- |
| ç¨³å®šçŠ¶æ€ (Stable)          | æ“ä½œå®Œæˆåçš„ç¨³æ€ï¼Œå¦‚ `READY`ã€`RUNNING`ã€`STOPPED` |
| è¿‡ç¨‹çŠ¶æ€ (Transient)       | æ“ä½œè¿›è¡Œä¸­çš„çŠ¶æ€ï¼Œå¦‚ `STARTING`ã€`STOPPING`       |
| å¼‚å¸¸/ç›®æ ‡çŠ¶æ€ (Target/Error) | æœ€ç»ˆç›®æ ‡æˆ–é”™è¯¯çŠ¶æ€ï¼Œå¦‚ `ERROR`, `FINISHED`        |

ä¾‹ï¼š

```cpp
enum class Sub1State { Idle, Starting, Running, Stopping, Error };
enum class Sub2State { Ready, Busy, Done, Error };
```

---

## ğŸ§  é—®é¢˜æ ¸å¿ƒ

> å½“å„å­ç³»ç»Ÿ**æ“ä½œé¡ºåºä¸åŒ**æ—¶ï¼Œç»„åˆçŠ¶æ€åˆæ³•æ€§ä¼šéšæ—¶é—´æ¼”åŒ–ã€‚

ä¾‹å¦‚ï¼š

| æ“ä½œé¡ºåº           | Sub1 çŠ¶æ€  | Sub2 çŠ¶æ€  | ç³»ç»Ÿæ˜¯å¦åˆæ³•           |
| -------------- | -------- | -------- | ---------------- |
| å¯åŠ¨é¡ºåº Sub1â†’Sub2 | Starting | Ready    | âœ… åˆæ³•ï¼ˆç³»ç»Ÿåœ¨å¯åŠ¨æµç¨‹ï¼‰    |
| å¯åŠ¨é¡ºåº Sub2â†’Sub1 | Ready    | Starting | âŒ ä¸åˆæ³•ï¼ˆè¿èƒŒè§„å®šå¯åŠ¨é¡ºåºï¼‰  |
| è¿è¡ŒçŠ¶æ€           | Running  | Busy     | âœ… åˆæ³•             |
| åœæ­¢é¡ºåºé”™è¯¯         | Stopping | Ready    | âŒ ä¸åˆæ³•ï¼ˆåº”å…ˆåœæ­¢ Sub2ï¼‰ |

---

## ğŸš¦ æ–¹æ³•ä¸€ï¼šåŸºäºâ€œæ“ä½œåºåˆ—â€ç”Ÿæˆåˆæ³•çŠ¶æ€ç©ºé—´

è¿™ç§æ–¹æ³•ä»**æ“ä½œåºåˆ—**å‡ºå‘ï¼Œè‡ªåŠ¨æ¨å¯¼åˆæ³•ç»„åˆã€‚

### Step 1ï¸âƒ£ å®šä¹‰å­ç³»ç»ŸçŠ¶æ€å›¾

æ¯ä¸ªå­ç³»ç»Ÿå®šä¹‰è‡ªå·±çš„**æœ‰é™çŠ¶æ€æœº**ï¼ˆFSMï¼‰ï¼š

```cpp
Sub1:
  Idle â†’ Starting â†’ Running â†’ Stopping â†’ Idle

Sub2:
  Ready â†’ Busy â†’ Done â†’ Ready
```

### Step 2ï¸âƒ£ å®šä¹‰ç³»ç»Ÿæ“ä½œåºåˆ—ï¼ˆå…¨å±€çº¦æŸï¼‰

ä¾‹å¦‚ï¼š

```
å¯åŠ¨æµç¨‹ï¼š Sub1.Start â†’ Sub2.Start
åœæ­¢æµç¨‹ï¼š Sub2.Stop â†’ Sub1.Stop
```

æˆ‘ä»¬å°†è¿™ç§é¡ºåºç”¨**æœ‰å‘ä¾èµ–å›¾ï¼ˆDAGï¼‰**è¡¨ç¤ºï¼š

```
Start:  Sub1 â†’ Sub2
Stop:   Sub2 â†’ Sub1
```

### Step 3ï¸âƒ£ ä»æ‰€æœ‰çŠ¶æ€ç»„åˆç”Ÿæˆâ€œç¬›å¡å°”ç§¯â€

```cpp
AllCombos = {Sub1State Ã— Sub2State}
```

### Step 4ï¸âƒ£ éå†ç»„åˆï¼Œä½¿ç”¨**åˆæ³•è·¯å¾„æ£€æŸ¥å™¨**ç­›é€‰

é€šè¿‡åˆ¤æ–­è¯¥ç»„åˆæ˜¯å¦å¯èƒ½å‡ºç°åœ¨åˆæ³•çš„æ‰§è¡Œè·¯å¾„ä¸Šã€‚

ä¼ªä»£ç ï¼š

```cpp
bool isLegal(Sub1State s1, Sub2State s2) {
    // 1. æ£€æŸ¥å­ç³»ç»Ÿå„è‡ªçŠ¶æ€æ˜¯å¦åœ¨åˆæ³•è·¯å¾„ä¸Š
    if (!isValidState(Sub1_FSM, s1) || !isValidState(Sub2_FSM, s2))
        return false;

    // 2. æ£€æŸ¥å…¨å±€æ“ä½œé¡ºåºçº¦æŸ
    if (s1 == Starting && s2 == Ready)
        return true;  // å¯åŠ¨é˜¶æ®µï¼Œç¬¦åˆ Sub1â†’Sub2 é¡ºåº
    if (s1 == Running && s2 == Busy)
        return true;
    if (s1 == Stopping && s2 == Done)
        return true;

    // 3. è¿èƒŒé¡ºåºçš„åœºæ™¯
    if (s1 == Ready && s2 == Starting)
        return false; // å¯åŠ¨é¡ºåºåäº†

    return false;
}
```

### Step 5ï¸âƒ£ è‡ªåŠ¨ç”Ÿæˆåˆæ³•çŠ¶æ€è¡¨

ä½ å¯ä»¥é€šè¿‡éå†æ‰€æœ‰ç»„åˆï¼š

```cpp
for (auto s1 : all(Sub1State)) {
  for (auto s2 : all(Sub2State)) {
    if (isLegal(s1, s2)) {
        legal_combos.push_back({s1, s2});
    } else {
        illegal_combos.push_back({s1, s2});
    }
  }
}
```

è¾“å‡ºå³å¯å½¢æˆ PPT/æŠ¥å‘Šç”¨è¡¨æ ¼ã€‚

---

## ğŸ§® æ–¹æ³•äºŒï¼šåŸºäºæ©ç çš„é«˜æ•ˆåˆæ³•æ€§æ£€æµ‹

å½“ç³»ç»Ÿå¤šè¾¾ **N ä¸ªå­ç³»ç»Ÿ** æ—¶ï¼Œå…¨ç»„åˆä¸º `Î  |SubiState|`ï¼Œçˆ†ç‚¸å¼å¢é•¿ã€‚
å¯ä»¥ç”¨ **æ©ç  + å±‚çº§æ˜ å°„** æ¥é™ä½å¤æ‚åº¦ã€‚

### æ ¸å¿ƒæ€è·¯

* ä¸ºæ¯ä¸ªå­ç³»ç»Ÿåˆ†é…ä¸€ä¸ªæ©ç æ®µï¼Œå¦‚ï¼š

  ```
  Sub1: bits [0..3]
  Sub2: bits [4..7]
  Sub3: bits [8..11]
  ```
* æ¯ç§çŠ¶æ€æ˜ å°„ä¸ºå›ºå®šæ©ç å€¼ï¼ˆä¾‹å¦‚ç”¨ ID è¡¨ç¤ºï¼‰ã€‚

ä¾‹å¦‚ï¼š

```cpp
constexpr uint32_t Sub1_Idle      = 0x01;
constexpr uint32_t Sub1_Starting  = 0x02;
constexpr uint32_t Sub1_Running   = 0x04;
constexpr uint32_t Sub1_Stopping  = 0x08;
```

### åˆæ³•æ€§è§„åˆ™å¯ä»¥ç”¨æ©ç è¡¨è¾¾

```cpp
constexpr uint32_t Legal_Start_Phase1 = Sub1_Starting | Sub2_Ready;
constexpr uint32_t Legal_Start_Phase2 = Sub1_Running  | Sub2_Busy;
constexpr uint32_t Legal_Stop_Phase1  = Sub1_Stopping | Sub2_Done;
```

é€šè¿‡ bit åŒ¹é…åˆ¤æ–­ï¼š

```cpp
bool isLegal(uint32_t combo_mask) {
    return any_of(legal_masks.begin(), legal_masks.end(),
                  [&](uint32_t legal){ return (combo_mask & legal) == legal; });
}
```

è¿™æ ·å¯ä»¥å¿«é€Ÿåˆ¤å®šã€‚

---

## ğŸ§± æ–¹æ³•ä¸‰ï¼šè·¯å¾„ç”Ÿæˆ + åˆæ³•çŠ¶æ€è‡ªåŠ¨æ¨å¯¼ï¼ˆæ¨èï¼‰

è¿™æ˜¯ä¸€ç§æœ€è‡ªåŠ¨åŒ–ã€æœ€æ˜“æ‰©å±•çš„æ–¹æ¡ˆï¼š

1. å®šä¹‰æ‰€æœ‰å­ç³»ç»Ÿ FSMã€‚
2. å®šä¹‰å…¨å±€æ“ä½œåºåˆ—ï¼ˆé¡ºåºçº¦æŸï¼‰ã€‚
3. ä½¿ç”¨ç®—æ³•ï¼ˆDFS/BFSï¼‰ä»åˆå§‹ç»„åˆå‡ºå‘ï¼Œ**æ¨¡æ‹Ÿæ‰€æœ‰åˆæ³•æ“ä½œåºåˆ—**ã€‚
4. æŠŠèƒ½åˆ°è¾¾çš„ `(Sub1State, Sub2State, ...)` è®°ä¸ºåˆæ³•ç»„åˆã€‚
5. å…¶ä»–ä¸ºéæ³•ã€‚

ä¼ªä»£ç ç¤ºä¾‹ï¼š

```cpp
struct Combo { Sub1State s1; Sub2State s2; };

std::set<Combo> legal;

void dfs(Combo current) {
    legal.insert(current);

    for (auto next : nextStates(current)) {
        if (checkGlobalOrder(current, next))
            dfs(next);
    }
}
```

ç»“æœï¼š

* `legal` é›†åˆä¸­åŒ…å«æ‰€æœ‰**å¯èƒ½å‡ºç°åœ¨çœŸå®è¿è¡Œè¿‡ç¨‹ä¸­çš„ç»„åˆ**
* å‰©ä½™ç»„åˆè‡ªåŠ¨è§†ä¸ºéæ³•

è¿™æ ·ï¼Œæ–°å¢çŠ¶æ€æˆ–ä¿®æ”¹é¡ºåºæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨é‡ç®—åˆæ³•ç©ºé—´ï¼Œ**ä¸ä¼šé—æ¼**ã€‚

---

## âš™ï¸ å®é™…å·¥ç¨‹åº”ç”¨å»ºè®®

| æ–¹æ¡ˆ         | ç‰¹ç‚¹       | é€‚ç”¨åœºæ™¯         |
| ---------- | -------- | ------------ |
| æ–¹æ³•1ï¼šé™æ€è§„åˆ™åŒ¹é… | ç›´è§‚ã€æ˜“å±•ç¤º   | å­ç³»ç»Ÿå°‘ï¼Œæµç¨‹å›ºå®š    |
| æ–¹æ³•2ï¼šæ©ç ç»„åˆ   | é«˜æ•ˆæŸ¥è¯¢     | è¿è¡Œæ—¶é¢‘ç¹çŠ¶æ€æ ¡éªŒ    |
| æ–¹æ³•3ï¼šè·¯å¾„æœç´¢   | è‡ªåŠ¨æ¨å¯¼ã€æœ€å¥å£® | å¤§è§„æ¨¡å¤šå­ç³»ç»Ÿï¼Œå¤æ‚ä¾èµ– |

---

## ğŸ“˜ ä¸¾ä¾‹è¾“å‡ºï¼ˆå¯ç”¨äº PPTï¼‰

| Sub1 çŠ¶æ€  | Sub2 çŠ¶æ€  | é˜¶æ®µ   | åˆæ³•æ€§ | è¯´æ˜     |
| -------- | -------- | ---- | --- | ------ |
| Idle     | Ready    | åˆå§‹   | âœ…   | åˆå§‹ç¨³æ€   |
| Starting | Ready    | å¯åŠ¨é˜¶æ®µ | âœ…   | å¯åŠ¨é¡ºåºæ­£ç¡® |
| Ready    | Starting | å¯åŠ¨é˜¶æ®µ | âŒ   | å¯åŠ¨é¡ºåºé”™è¯¯ |
| Running  | Busy     | è¿è¡Œä¸­  | âœ…   | æ­£å¸¸è¿è¡Œ   |
| Stopping | Done     | åœæ­¢é˜¶æ®µ | âœ…   | åœæ­¢é¡ºåºæ­£ç¡® |
| Done     | Stopping | åœæ­¢é˜¶æ®µ | âŒ   | åœæ­¢é¡ºåºåäº† |

---

## ğŸ’¡ æ‰©å±•æ€è€ƒ

* ä½ å¯ä»¥è¿›ä¸€æ­¥åœ¨åˆæ³•æ€§åˆ¤æ–­ä¸­åŠ å…¥ï¼š

  * **æ—¶é—´çº¦æŸ**ï¼ˆå¦‚ Sub2 å¿…é¡»åœ¨ Sub1 å¯åŠ¨å®Œæˆå 2s å†…è¿›å…¥ Busyï¼‰
  * **ä¼˜å…ˆçº§çº¦æŸ**ï¼ˆå¦‚ç´§æ€¥åœæ­¢å¯è·³è¿‡éƒ¨åˆ†çŠ¶æ€ï¼‰
  * **å­ç³»ç»Ÿç»„**ï¼ˆå¤šä¸ªå­ç³»ç»Ÿä¸€èµ·å½¢æˆ higher-level group FSMï¼‰

---

## âœ… æ€»ç»“

> **å¤šå­ç³»ç»ŸçŠ¶æ€ç»„åˆåˆæ³•æ€§** å¯ä»¥é€šè¿‡ â€œè·¯å¾„çº¦æŸ + çŠ¶æ€ç©ºé—´è£å‰ªâ€ è‡ªåŠ¨ç”Ÿæˆã€‚

ä¸‰ç§æ ¸å¿ƒå®ç°ç­–ç•¥ï¼š

1. **åŸºäºè§„åˆ™åŒ¹é…**ï¼ˆå¿«é€Ÿç›´è§‚ï¼‰
2. **åŸºäºæ©ç åŒ¹é…**ï¼ˆé€‚åˆè¿è¡Œæ—¶éªŒè¯ï¼‰
3. **åŸºäºè·¯å¾„ç”Ÿæˆ**ï¼ˆé€‚åˆè®¾è®¡éªŒè¯/è‡ªåŠ¨æ¨å¯¼ï¼‰

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥å¸®ä½ ï¼š

* ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„ **C++ demo**ï¼ˆå®ç° DFS è‡ªåŠ¨ç”Ÿæˆåˆæ³•çŠ¶æ€ç»„åˆï¼‰
* å¹¶é™„å¸¦è¾“å‡ºè¡¨æ ¼ï¼ˆCSV / Markdownï¼‰å½¢å¼ï¼Œç”¨äº PPT æŠ¥å‘Šã€‚

è¦æˆ‘å¸®ä½ ç”Ÿæˆè¿™ä¸ª demo å—ï¼Ÿ
