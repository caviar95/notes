根据每条消息携带的 ver 字段来动态选择对应版本的状态机逻辑，而不是运行时只绑定一个 Version。

这种场景常见于：

    一个服务同时接收不同版本的客户端请求；

    某种协议或业务逻辑在不同版本间存在差异；

    需要动态路由到不同版本的状态处理器。


增加消息结构体 Message，包含 ver, event, context id 等

引入版本态缓存池：std::map<Version, std::unique_ptr<IStateMachine>>

每次收到消息，根据 ver 选择版本逻辑进行处理


🧠 拓展建议

    ✨ session_id 可扩展为一个完整的 Context 结构体，存储更多状态信息；

    🔁 fsm_map_ 和 session_map_ 可加入超时清理机制；

    📄 makeStateMachine(ver) 也可从配置文件加载动态转换表；

    🔌 你还可以按版本拆分为 .so 插件动态加载（配合 dlfcn.h）。

✅ 总结
特性	是否支持
多版本并存处理	✅ 动态从消息获取 ver 字段
每个 session 独立状态	✅ 用 session_id → State 管理
状态驱动逻辑抽象	✅ 表驱动 + 策略模式
易于扩展维护	✅ 仅添加版本实现和表即可

在实践中，不同版本的状态处理方案主要落在两条维度上：

1. **编译时区分（差异化编译）**
2. **运行时区分（同一套代码动态调度）**

除此之外，还可以考虑 **插件化／微服务拆分** 等更松耦合的方式。下面从几方面对比，并给出版本信息携带的最佳实践建议。

---

## 一、编译时区分 vs 运行时区分

| 特性          | 编译时区分                              | 运行时区分                         |
| ----------- | ---------------------------------- | ----------------------------- |
| **实现方式**    | `#ifdef VERSION_X`、CMake 多目标、模板特化等 | Strategy 模式 + 表驱动 / 插件 / 配置文件 |
| **二进制数量**   | 每个版本一个二进制（或多个变体）                   | 单二进制，多版本逻辑内置                  |
| **灵活性**     | 需重新编译／重发布才能切换版本                    | 运行中即可根据消息头或配置切换               |
| **打包／部署成本** | 版本越多，部署包数量线性增长                     | 部署包数量固定，运维更省心                 |
| **运行时开销**   | 无版本分支开销（编译去除无用逻辑）                  | 消息分发有一次哈希／查表开销，但通常微乎其微        |
| **代码复杂度**   | 各版本代码物理隔离，易于金丝雀发布                  | 版本逻辑混在一起，代码可读性、维护性略逊          |
| **测试难度**    | 每个版本单独编译测试                         | 单套测试需要覆盖所有版本分支                |

---

### 1. 编译时区分（差异化编译）

* **适用场景**

  * 不同版本差异非常大，运行时无法承受复杂的条件分支。
  * 对二进制大小、性能有极致追求，希望剔除所有无用逻辑。
  * 发布节奏较慢，版本数量有限。

* **常见做法**

  * CMake／Bazel 定义多个 target：`fsm_v1`, `fsm_v2`，打包成不同可执行／库。
  * 在代码里通过 `#ifdef VERSION_1`/`VERSION_2` 条件编译。
  * Template 特化：`template<Version V> class StateMachine;` 对每个 `V` 做特化。

* **弊端**

  * 构建产物多，CI/CD 复杂度提升。
  * 如果同一服务需要同时处理多版本请求，就必须预留多套进程或多种启动参数来指向不同二进制，运维成本高。

---

### 2. 运行时区分（同一套代码动态调度）

* **适用场景**

  * 服务端需要同时兼容多版本客户端。
  * 版本迭代频繁，但希望零停服、热部署新逻辑。
  * 差异主要集中在状态转换表或少数钩子上。

* **常见做法**

  1. **策略模式 + 表驱动**

     * 按前面示例，`makeStateMachine(ver)` 动态创建不同版本策略。
     * `fsm_map_[ver]` 缓存各版本实例，`dispatch(msg)` 时按 `msg.ver` 调度。

  2. **插件化（.so/.dll）**

     * 不同版本各自产生独立插件，主程序通过 `dlopen`、`dlsym` 加载。
     * 插件里实现符合 `IStateMachine` 的工厂接口，运行时按版本动态加载。

  3. **微服务拆分**

     * 完全拆成不同服务进程（或容器），各自只负责一套版本逻辑。
     * 请求网关（API Gateway）根据 `ver` 路由到对应服务。

* **弊端**

  * 运行时选择增加一次映射或加载开销，但一般可忽略不计。
  * 代码里会有多个版本的逻辑并存，阅读时需跳转。

---

## 二、版本信息如何携带

无论编译时还是运行时区分，**消息中携带版本信息** 是统一的最佳实践。常见方式有：

1. **协议头字段**

   ```cpp
   struct Message {
       uint8_t    ver;       // 1 = v1, 2 = v2, …
       uint32_t   sessionId;
       uint16_t   event;
       // …其他 Payload
   };
   ```

2. **HTTP/gRPC 标头（Header/Metadata）**

   * HTTP：`X-Api-Version: 2`
   * gRPC Metadata：`metadata["version"] = "v2"`

3. **URL 路径**

   * `/api/v1/resource` vs `/api/v2/resource`
   * 适合 RESTful，版本由路由直接区分。

4. **消息队列 Topic**

   * Kafka Topic：`orders.v1` vs `orders.v2`
   * 消费者根据 Topic 订阅不同版本的事件。

---

## 三、最佳实践建议

1. **若需同时兼容多版本且迭代频繁 → 运行时区分＋策略/插件**

   * 单二进制部署，动态调度；
   * 版本逻辑隔离在各自策略实现或插件中，主干代码清爽。

2. **若版本差异极大，且部署/运维可接受多套二进制 → 编译时区分**

   * 针对不同版本做瘦身；
   * 可在同一机群中并行部署多套服务，各自独立升级。

3. **消息设计：**

   * **一定要显式携带 `ver`**，避免根据内容猜测；
   * 对外协议文档里把 `ver` 写清楚，并保证向前/向后兼容策略。

4. **渐进式升级（灰度发布）：**

   * 运行时版本可从配置中心（ZooKeeper/Consul）或 API 网关动态下发给后端。
   * Client → 网关 → Dispatcher → 对应版本服务／策略。

---

### 小结

* **编译时区分**：适合“大刀阔斧”式版本拆分、极致性能／体积优化。
* **运行时区分**：适合“平滑演进”式兼容、多版本并存、高可用在线升级。
* **版本携带**：通过消息头、路由、Topic、Metadata 等方式显式传递。

根据你对**部署复杂度**、**运行时灵活性**、**性能体积要求**的权衡，选择最合适的方案即可。
