ä½ æå‡ºçš„é—®é¢˜å±äº**åœ¨C++ä¸­å¯¹å°è£…æœ‰`__FILE__`, `__LINE__`, `__FUNCTION__`ç­‰è°ƒç”¨ä½ç½®ä¿¡æ¯çš„å®è¿›è¡Œæµ‹è¯•æ‰“æ¡©**çš„å…¸å‹åœºæ™¯ã€‚ç”±äºè¿™ç±»å®ä¼šå°†è°ƒç”¨ä½ç½®ä¿¡æ¯åµŒå…¥åœ¨ä»£ç ä¸­ï¼Œå› æ­¤åœ¨**UTä¸­å®ç°æ‰“æ¡©**æ—¶éœ€è¦ç‰¹åˆ«å¤„ç†ã€‚

---

## ğŸ§  é—®é¢˜èƒŒæ™¯

ä½ å½“å‰æœ‰ä¸€ä¸ªå®ï¼Œç±»ä¼¼è¿™æ ·ï¼š

```cpp
#define WRAPPED_CALL(args...) ExternalFunc(args, __FILE__, __LINE__, __FUNCTION__)
```

æˆ–æ›´å¤æ‚ä¸€äº›ï¼š

```cpp
#define LOG_CALL(x) Logger::log(x, __FILE__, __LINE__, __func__)
```

åœ¨ä¸šåŠ¡ä»£ç ä¸­è°ƒç”¨çš„æ˜¯ `WRAPPED_CALL(...)`ï¼Œ**è€Œä¸æ˜¯å‡½æ•°æœ¬èº«**ã€‚

è¿™å¯¼è‡´ï¼š

1. æƒ³è¦ mock `ExternalFunc` æ—¶ï¼Œéœ€è¦å¤„ç†è¿™äº›ä½ç½®ä¿¡æ¯ã€‚
2. åœ¨å•å…ƒæµ‹è¯•ä¸­å¾ˆéš¾æ›¿æ¢ `WRAPPED_CALL` ä¸º mock å‡½æ•°ã€‚

---

## âœ… å¸¸è§è§£å†³æ–¹æ¡ˆå¯¹æ¯”

### âœ… æ–¹æ¡ˆä¸€ï¼šå°†è°ƒç”¨å°è£…ä¸ºå¯æ›¿æ¢å‡½æ•°ï¼Œå†ç”±å®åŒ…è£…ï¼ˆæ¨èï¼‰

#### æ€è·¯

ä½¿ç”¨æ™®é€šå‡½æ•°ä½œä¸ºä¸­è½¬ï¼Œé€šè¿‡å®ä¼ å…¥ `__FILE__`, `__LINE__`, `__FUNCTION__`ï¼Œåœ¨ UT ä¸­ mock ä¸­é—´å±‚å‡½æ•°ã€‚

#### ç¤ºä¾‹ï¼š

```cpp
// åŸå§‹å‡½æ•°
void ExternalFunc(int value, const char* file, int line, const char* func);

// å¯æ›¿æ¢ä¸­è½¬å‡½æ•°
inline void ExternalFuncWrapper(int value, const char* file, int line, const char* func) {
    ExternalFunc(value, file, line, func);
}

// å®åŒ…è£…ï¼ˆä¾æ—§ä¿ç•™è°ƒç”¨ä½ç½®ï¼‰
#define WRAPPED_CALL(value) ExternalFuncWrapper(value, __FILE__, __LINE__, __FUNCTION__)
```

#### UTä¸­æ‰“æ¡©æ–¹å¼

* åœ¨UTä¸­ä½¿ç”¨ `EXPECT_CALL` é’ˆå¯¹ `ExternalFuncWrapper` è¿›è¡Œmockï¼ˆé…åˆé“¾æ¥æ›¿æ¢æˆ–æ¥å£æŠ½è±¡ï¼‰ã€‚
* æˆ–è€…å°† `ExternalFuncWrapper` å£°æ˜ä¸ºè™šå‡½æ•°ã€æ¥å£æ–¹æ³•æˆ–é€šè¿‡å‡½æ•°æŒ‡é’ˆæ³¨å…¥ï¼ˆè§æ–¹æ¡ˆä¸‰ï¼‰ã€‚

---

### âœ… æ–¹æ¡ˆäºŒï¼šå¼•å…¥ä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼‰

é€‚ç”¨äºå®æœ€ç»ˆè°ƒç”¨çš„æ˜¯ç±»çš„æˆå‘˜å‡½æ•°ã€‚

```cpp
class IExternal {
public:
    virtual void call(int v, const char* file, int line, const char* func) = 0;
};

class RealExternal : public IExternal {
public:
    void call(int v, const char* file, int line, const char* func) override {
        // çœŸæ­£è°ƒç”¨ ExternalFunc
    }
};

#define WRAPPED_CALL(ext, value) ext->call(value, __FILE__, __LINE__, __FUNCTION__)
```

#### UTä¸­ï¼š

```cpp
class MockExternal : public IExternal {
public:
    MOCK_METHOD(void, call, (int v, const char* file, int line, const char* func), (override));
};
```

ç„¶åä½ å°±å¯ä»¥è‡ªç”± mock `call()` æ–¹æ³•ã€‚

---

### âœ… æ–¹æ¡ˆä¸‰ï¼šä½¿ç”¨å‡½æ•°æŒ‡é’ˆæˆ– std::function æ³¨å…¥

å¦‚æœä½ ä¸æƒ³å¼•å…¥æ¥å£ï¼Œå¯ä»¥ç”¨å‡½æ•°æŒ‡é’ˆæˆ– `std::function`ã€‚

```cpp
using ExternalFuncType = std::function<void(int, const char*, int, const char*)>;

inline ExternalFuncType g_externalFunc = ExternalFunc;

#define WRAPPED_CALL(value) g_externalFunc(value, __FILE__, __LINE__, __FUNCTION__)
```

#### UTä¸­ï¼š

```cpp
g_externalFunc = [](int v, const char* f, int l, const char* fn) {
    // mock logic
};
```

**ä¼˜ç‚¹ï¼š** ä¸éœ€è¦å†™ mock ç±»ï¼›
**ç¼ºç‚¹ï¼š** çº¿ç¨‹å®‰å…¨æ€§ã€è‡ªå®šä¹‰è¡Œä¸ºä¸å¦‚ gmockã€‚

---

### ğŸš« ä¸æ¨èï¼šç›´æ¥æ›¿æ¢å®æˆ–å®åµŒå¥— mock

ä½ å¯èƒ½ä¼šæƒ³åˆ°ï¼š

```cpp
#define WRAPPED_CALL(...) MOCK_WRAPPED_CALL(__VA_ARGS__)
```

ä½†è¿™ç§åšæ³•ä¼šï¼š

* ä¿®æ”¹åŸæœ‰å®å®šä¹‰ï¼Œä¸ç¬¦åˆã€Œä¸æ”¹åŠ¨åŸå®ã€çš„å‰æï¼›
* æ— æ³•åœ¨å¤šä¸ªæ¨¡å—ä¹‹é—´ç²¾ç¡®æ§åˆ¶ mock èŒƒå›´ï¼›
* ä¸ mock å·¥å…·ï¼ˆå¦‚ gmockï¼‰é›†æˆå›°éš¾ã€‚

---

## âœ… æ¨èç»„åˆç­–ç•¥

| æŠ€æœ¯        | ä¼˜ç‚¹                   | ç¼ºç‚¹              |
| --------- | -------------------- | --------------- |
| ä¸­é—´å±‚å‡½æ•° + å® | ç®€å•ã€å…¼å®¹è€ä»£ç ã€ä¸å½±å“ä½¿ç”¨è€…      | mock éœ€é“¾æ¥æ›¿æ¢æˆ–å†…éƒ¨è®¿é—® |
| æ¥å£æ³¨å…¥      | mock æœ€è‡ªç„¶ã€é…åˆ gmock æä½³ | å¢åŠ æŠ½è±¡ã€ç¨å¤æ‚        |
| å‡½æ•°æŒ‡é’ˆæ³¨å…¥    | çµæ´»ã€æ— ä¾µå…¥               | ç±»å‹å®‰å…¨ã€ç»´æŠ¤å¤æ‚       |
| æ”¹å®æ”¹ä»£ç      | æ˜“å‡ºé”™ï¼Œç ´ååŸè®¾è®¡            | ä¸æ¨è             |

---

## ğŸ§ª å®è·µå»ºè®®

1. **å·²æœ‰å¤§é‡ WRAPPED\_CALL ä½¿ç”¨æ—¶** â†’ ä¼˜å…ˆé€‰ç”¨ *ä¸­é—´å±‚å‡½æ•°åŒ…è£… + é“¾æ¥ mock*ã€‚
2. **æ–°é¡¹ç›®æˆ–æ¨¡å—åŒ–åœºæ™¯** â†’ ç”¨ *æ¥å£æ³¨å…¥ + DI æ¨¡å¼*ã€‚
3. **å¿«é€Ÿæµ‹è¯•å±€éƒ¨é€»è¾‘** â†’ ç”¨ *std::function å…¨å±€æ›¿æ¢*ã€‚
4. **ä½¿ç”¨ GoogleTest/Mock** â†’ å¼ºçƒˆå»ºè®®ä½¿ç”¨ä¸­é—´å±‚å‡½æ•°æˆ– DI æ³¨å…¥ï¼Œé¿å…ç›´æ¥ mock å®ã€‚

---

## ğŸ”š æ€»ç»“

ä½ è¦è€ƒè™‘çš„é‡ç‚¹æ˜¯ï¼š

* **ä¸åŠ¨å®çš„å®šä¹‰**
* **è®©UTå¯ä»¥æ¥ç®¡å®æœ€ç»ˆè°ƒç”¨çš„å†…å®¹**

é‚£å°±è¦**æŠŠå®ä¸­å®é™…è°ƒç”¨çš„å†…å®¹æŠ½è±¡å‡ºæ¥**ï¼Œè¿™æ · mock æ—¶ç›®æ ‡æ˜ç¡®ã€ä¸ä¼šè¢« `__FILE__` ä¹‹ç±»å¹²æ‰°ï¼Œè°ƒè¯•å®šä½ä¹Ÿæ›´æ¸…æ™°ã€‚

å¦‚æœä½ èƒ½è´´å‡ºä½ å½“å‰å®çš„å®šä¹‰ï¼Œæˆ‘å¯ä»¥å¸®ä½ æ”¹é€ æˆé€‚åˆæ‰“æ¡©çš„ç»“æ„ã€‚æ˜¯å¦éœ€è¦æˆ‘ç»™å‡ºå®Œæ•´ç¤ºä¾‹å·¥ç¨‹ç»“æ„ï¼ˆ.h/.cpp/test.cppï¼‰ï¼Ÿ
ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ **C++ å·¥ç¨‹ç¤ºä¾‹**ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨\*\*ä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼‰\*\*çš„æ–¹å¼å¯¹å¸¦æœ‰ `__FILE__`, `__LINE__`, `__FUNCTION__` çš„å®è¿›è¡Œå°è£…ï¼Œä½¿å…¶åœ¨ **å•å…ƒæµ‹è¯•ä¸­å¯è¢«æ‰“æ¡©ï¼ˆMockï¼‰**ã€‚

---

## âœ… åœºæ™¯è¯´æ˜

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸šåŠ¡è°ƒç”¨æ—¥å¿—ç³»ç»Ÿï¼š

```cpp
LOG_CALL("task start");
```

ä½ å¸Œæœ›è¿™ä¸ªå®å°†è°ƒç”¨è½¬å‘åˆ°ä¸€ä¸ªå¤–éƒ¨æ¨¡å—çš„ log å‡½æ•°ï¼Œå¹¶è®°å½•è°ƒç”¨ä½ç½®ï¼Œä½†åœ¨ UT ä¸­æˆ‘ä»¬è¦ mock æ‰è¿™ä¸ª log é€»è¾‘ã€‚

---

## ğŸ“ å·¥ç¨‹ç›®å½•ç»“æ„

```
project/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ logger.h        // å®šä¹‰æ¥å£å’Œå®
â”œâ”€â”€ src/
â”‚   â””â”€â”€ real_logger.cpp // å®ç°æ—¥å¿—é€»è¾‘
â”œâ”€â”€ test/
â”‚   â””â”€â”€ test_logger.cpp // ä½¿ç”¨ GoogleTest + GoogleMock
â”œâ”€â”€ CMakeLists.txt      // æ„å»ºè„šæœ¬
```

---

## ğŸ”§ 1. include/logger.h

```cpp
#pragma once
#include <string>

// æ—¥å¿—æ¥å£
class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void log(const std::string& msg, const char* file, int line, const char* func) = 0;
};

// å…¨å±€ logger å®ä¾‹
void set_logger(ILogger* logger);
ILogger* get_logger();

// å®å°è£…ï¼Œè®°å½•è°ƒç”¨ä½ç½®ä¿¡æ¯
#define LOG_CALL(msg) get_logger()->log((msg), __FILE__, __LINE__, __FUNCTION__)
```

---

## ğŸ”§ 2. src/real\_logger.cpp

```cpp
#include "logger.h"
#include <iostream>

class RealLogger : public ILogger {
public:
    void log(const std::string& msg, const char* file, int line, const char* func) override {
        std::cout << "[LOG] " << msg << " at " << file << ":" << line << " (" << func << ")" << std::endl;
    }
};

static ILogger* g_logger = nullptr;

void set_logger(ILogger* logger) {
    g_logger = logger;
}

ILogger* get_logger() {
    if (!g_logger) {
        static RealLogger default_logger;
        return &default_logger;
    }
    return g_logger;
}
```

---

## ğŸ§ª 3. test/test\_logger.cpp

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "logger.h"

using ::testing::_;
using ::testing::StrEq;
using ::testing::HasSubstr;

class MockLogger : public ILogger {
public:
    MOCK_METHOD(void, log, (const std::string& msg, const char* file, int line, const char* func), (override));
};

TEST(LoggerTest, LogIsCalledWithCorrectParams) {
    MockLogger mock;

    // è®¾ç½® mock æ›¿ä»£é»˜è®¤ logger
    set_logger(&mock);

    EXPECT_CALL(mock, log(StrEq("test message"), HasSubstr("test_logger.cpp"), _, StrEq("LoggerTest_LogIsCalledWithCorrectParams_Test")));

    // æµ‹è¯•è°ƒç”¨
    LOG_CALL("test message");

    // æ¢å¤ï¼ˆå¯é€‰ï¼‰
    set_logger(nullptr);
}
```

---

## ğŸ›  4. CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(LoggerTest)

set(CMAKE_CXX_STANDARD 17)

# è®¾ç½® include ç›®å½•
include_directories(include)

# æºæ–‡ä»¶
add_library(logger STATIC src/real_logger.cpp)

# GoogleTest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# æµ‹è¯•ç›®æ ‡
add_executable(test_logger test/test_logger.cpp)
target_link_libraries(test_logger logger GTest::GTest GTest::Main pthread)
```

---

## ğŸ§ª æ„å»ºå¹¶è¿è¡Œ

```bash
mkdir build && cd build
cmake ..
make
./test_logger
```

---

## âœ… æ€»ç»“ä¼˜ç‚¹

* `LOG_CALL(...)` ä¿ç•™è°ƒç”¨ä½ç½®ä¿¡æ¯ã€‚
* `ILogger` æ¥å£ + `set_logger()` å®ç°äº†å¯æ›¿æ¢æ€§ã€‚
* `MockLogger` + `EXPECT_CALL` å¯ä»¥å¯¹æ—¥å¿—è¡Œä¸ºè¿›è¡Œç²¾ç¡®éªŒè¯ã€‚
* æ²¡æœ‰ç ´åå®å®šä¹‰ï¼Œä¸å½±å“ä¸šåŠ¡å±‚ä½¿ç”¨ã€‚

---

å¦‚æœä½ éœ€è¦æ›´å¤æ‚çš„ç”¨ä¾‹ï¼Œæ¯”å¦‚å¤šçº¿ç¨‹ä¸‹çš„ logger thread-safety æˆ–æ”¯æŒå¤šå®ä¾‹æ³¨å…¥ç­‰ï¼Œä¹Ÿå¯ä»¥è¿›ä¸€æ­¥æ‰©å±•æ­¤æ–¹æ¡ˆã€‚

æ˜¯å¦éœ€è¦æˆ‘æ‰©å±•æˆå¤šæ¨¡å—åœºæ™¯æˆ–ç»“åˆå®é™…ä¸šåŠ¡ä»£ç æ¨¡æ‹Ÿï¼Ÿ
æ„Ÿè°¢æä¾›å®é™…å®å®šä¹‰ï¼Œæ¥ä¸‹æ¥æˆ‘å°†åŸºäºä½ ç»™å‡ºçš„å®é™…æƒ…å†µï¼š

---

## âœ… åœºæ™¯å›é¡¾

### å®å®šä¹‰å¦‚ä¸‹ï¼š

```cpp
#define TRACE(mode, format, args, ...) \
    Log(mode, POSITION, format, ##args)
```

å‡è®¾ `POSITION` æ˜¯ä¸€ä¸ªå®å®šä¹‰ä¸ºï¼š

```cpp
#define POSITION __FILE__, __LINE__, __FUNCTION__
```

### å¤–éƒ¨ Log å®ç°å¦‚ä¸‹ï¼š

```cpp
class XXX {
public:
    static void Log(Mode mode,
                    const std::string& file,
                    int line,
                    const std::string& func,
                    const char* fmt,
                    ...);
};
```

ä½ å¸Œæœ›åœ¨ **ä¸ä¿®æ”¹å®è°ƒç”¨æ–¹å¼çš„å‰æä¸‹**ï¼Œåœ¨å•å…ƒæµ‹è¯•ä¸­ mock æ‰ `XXX::Log(...)` çš„è¡Œä¸ºã€‚

---

## âœ… æ¨èæ–¹æ¡ˆï¼šä¸­è½¬æ¥å£æ³¨å…¥ + å®åŒ…è£… + mock

### ğŸš©é—®é¢˜ç‚¹ï¼š

* `XXX::Log` æ˜¯ `static`ï¼Œæ— æ³•ç›´æ¥ mockï¼ˆé™¤éç”¨é“¾æ¥æ›¿æ¢æˆ– link seamï¼‰ã€‚
* å®å±•å¼€æ—¶æ³¨å…¥äº† `__FILE__`, `__LINE__`, `__FUNCTION__`ï¼Œå½±å“ mock å‚æ•°åŒ¹é…ã€‚
* `...` å¯å˜å‚æ•°å¯¹ mock æ¡†æ¶ä¸å‹å¥½ã€‚

---

## âœ… æ”¹é€ æ–¹æ¡ˆç›®æ ‡ï¼š

1. ä¸æ”¹åŠ¨ `TRACE(...)` çš„è°ƒç”¨æ–¹å¼ï¼›
2. å¼•å…¥å¯ mock çš„ä¸­é—´å±‚ï¼›
3. å°†å¯å˜å‚æ•° Log é‡å®šå‘è‡³æ¥å£å‡½æ•°ï¼›
4. æä¾›é»˜è®¤å®ç°ä¾›ç”Ÿäº§ä»£ç ä½¿ç”¨ï¼Œå¯æ³¨å…¥ mock å®ç°ä¾›æµ‹è¯•ä½¿ç”¨ã€‚

---

## ğŸ“ ç¤ºä¾‹å·¥ç¨‹ç»“æ„

```
project/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ trace.h          // å®å®šä¹‰ + æŠ½è±¡æ¥å£
â”œâ”€â”€ src/
â”‚   â””â”€â”€ trace_impl.cpp   // é»˜è®¤å®ç°
â”œâ”€â”€ test/
â”‚   â””â”€â”€ test_trace.cpp   // GTest + GMock
```

---

## ğŸ”§ include/trace.h

```cpp
#pragma once
#include <string>

// æ—¥å¿—çº§åˆ«æšä¸¾
enum class Mode {
    Debug,
    Info,
    Warn,
    Error,
};

// å¯æ›¿æ¢çš„æ—¥å¿—æ¥å£
class ITracer {
public:
    virtual ~ITracer() = default;
    virtual void Log(Mode mode,
                     const std::string& file,
                     int line,
                     const std::string& func,
                     const char* fmt,
                     va_list args) = 0;
};

// æ³¨å…¥å¼æ¥å£
void SetTracer(ITracer* tracer);
ITracer* GetTracer();

// POSITION å®å®šä¹‰
#define POSITION __FILE__, __LINE__, __FUNCTION__

// åŒ…è£…å®ï¼šæ¨¡æ‹Ÿä½ çš„ TRACE å®
#define TRACE(mode, fmt, ...) \
    TraceLog(mode, POSITION, fmt, ##__VA_ARGS__)

// ä¸­è½¬å‡½æ•°ï¼ˆå®å±•å¼€ç›®æ ‡ï¼‰
void TraceLog(Mode mode,
              const char* file, int line, const char* func,
              const char* fmt, ...);
```

---

## ğŸ”§ src/trace\_impl.cpp

```cpp
#include "trace.h"
#include <iostream>
#include <cstdarg>
#include <mutex>

static ITracer* g_tracer = nullptr;
static std::mutex tracer_mutex;

void SetTracer(ITracer* tracer) {
    std::lock_guard<std::mutex> lock(tracer_mutex);
    g_tracer = tracer;
}

ITracer* GetTracer() {
    std::lock_guard<std::mutex> lock(tracer_mutex);
    return g_tracer;
}

// é»˜è®¤å®ç°
class DefaultTracer : public ITracer {
public:
    void Log(Mode mode,
             const std::string& file,
             int line,
             const std::string& func,
             const char* fmt,
             va_list args) override {
        char buffer[1024];
        vsnprintf(buffer, sizeof(buffer), fmt, args);
        std::cout << "["
                  << static_cast<int>(mode) << "] "
                  << file << ":" << line << " "
                  << func << " - "
                  << buffer << std::endl;
    }
};

// ä¸­è½¬å‡½æ•°
void TraceLog(Mode mode,
              const char* file, int line, const char* func,
              const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);

    ITracer* tracer = GetTracer();
    static DefaultTracer default_tracer;
    if (!tracer) tracer = &default_tracer;

    tracer->Log(mode, file, line, func, fmt, args);

    va_end(args);
}
```

---

## ğŸ§ª test/test\_trace.cpp

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "trace.h"

using ::testing::_;
using ::testing::StrEq;
using ::testing::HasSubstr;

class MockTracer : public ITracer {
public:
    MOCK_METHOD(void, Log,
                (Mode mode, const std::string& file, int line,
                 const std::string& func, const char* fmt, va_list args),
                (override));
};

// å¸®åŠ©å‡½æ•°ï¼šè§£æ va_list ä¸º stringï¼Œä¾¿äºåŒ¹é…
std::string FormatVaList(const char* fmt, va_list args) {
    char buffer[1024];
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    return std::string(buffer);
}

// åŒ…è£… matcherï¼Œç”¨äºæ•è· va_list
MATCHER_P2(FormatMatches, expected_fmt, expected_msg, "") {
    va_list args;
    va_copy(args, std::get<4>(arg));
    std::string actual = FormatVaList(expected_fmt, args);
    va_end(args);
    return actual == expected_msg;
}

TEST(TraceTest, TraceLogIsCalled) {
    MockTracer mock;
    SetTracer(&mock);

    EXPECT_CALL(mock, Log(Mode::Info,
                          HasSubstr("test_trace.cpp"), _, HasSubstr("TraceTest_TraceLogIsCalled"),
                          StrEq("%s"), FormatMatches("%s", "Hello, world")));

    TRACE(Mode::Info, "%s", "Hello, world");

    SetTracer(nullptr); // æ¢å¤é»˜è®¤ tracerï¼ˆå¯é€‰ï¼‰
}
```

---

## âœ… ä½¿ç”¨è¯´æ˜

ä¸šåŠ¡ä»£ç ä¸­ä½ ç»§ç»­ä½¿ç”¨ï¼š

```cpp
TRACE(Mode::Info, "connected to %s:%d", ip.c_str(), port);
```

å•å…ƒæµ‹è¯•ä¸­å®Œå…¨æ§åˆ¶ `Log()` çš„è¡Œä¸ºä¸æ–­è¨€ï¼Œä¸å½±å“ä¸šåŠ¡å®å®šä¹‰ã€‚

---

## ğŸ”š æ€»ç»“

| è¦ç‚¹                   | è¯´æ˜                |
| -------------------- | ----------------- |
| ä¿ç•™ `TRACE(...)` å®å½¢å¼  | âœ” ä¸å½±å“ä¸šåŠ¡è°ƒç”¨         |
| æ”¯æŒ `POSITION` + å¯å˜å‚æ•° | âœ” æ­£ç¡®ä¼ é€’æ–‡ä»¶/è¡Œå·/å‡½æ•°    |
| å®ç°æ‰“æ¡©ã€mock éªŒè¯         | âœ” å®Œæ•´æ”¯æŒ GoogleMock |
| ä¸ä¾èµ–é“¾æ¥æ›¿æ¢æˆ–ç‰¹æ®Šå·¥å…·         | âœ” å¯ç§»æ¤ã€ç¨³å®š          |

---

å¦‚æœä½ å¸Œæœ›å’ŒåŸå§‹çš„ `XXX::Log(...)` æ¥å£æ— ç¼é›†æˆï¼Œæˆ‘ä¹Ÿå¯ä»¥åŠ ä¸€å±‚é€‚é…å™¨ï¼ŒæŠŠ `TraceLog()` çš„å®é™…å®ç°è°ƒç”¨ `XXX::Log(...)`ï¼Œä½ æ˜¯å¦éœ€è¦ï¼Ÿæ˜¯å¦è¿˜éœ€è¦æˆ‘è¡¥å……è¿™ä¸ªå·¥ç¨‹çš„ `CMakeLists.txt` æ–‡ä»¶ï¼Ÿ
éå¸¸å¥½ï¼Œæˆ‘ä»¬ç°åœ¨å°†æ„å»ºä¸€ä¸ª**å°½å¯èƒ½å®Œæ•´çš„ç¤ºä¾‹å·¥ç¨‹**ï¼ŒåŒ…æ‹¬ï¼š

---

## âœ… ç›®æ ‡æ€»ç»“

ä½ éœ€è¦ä¸€ä¸ªå®Œæ•´çš„ C++ å·¥ç¨‹ï¼Œå…·å¤‡ä»¥ä¸‹è¦ç‚¹ï¼š

| ç»„ä»¶                 | åŠŸèƒ½                            |
| ------------------ | ----------------------------- |
| `TRACE(...)` å®     | æ¨¡æ‹ŸåŸå§‹å¸¦å®šä½ä¿¡æ¯ + å¯å˜å‚æ•°æ—¥å¿—è°ƒç”¨          |
| `ITracer` æ¥å£       | å¯ mock çš„æ—¥å¿—ä¸­è½¬å±‚                 |
| `DefaultTracer` å®ç° | å®é™…å†™å…¥æ§åˆ¶å°æˆ–æ–‡ä»¶çš„é»˜è®¤æ—¥å¿—               |
| `TraceLog()` å‡½æ•°    | ä¸­è½¬å±‚ï¼Œç”¨äº `TRACE(...)` è°ƒç”¨        |
| `va_list` è®¾è®¡       | æ”¯æŒ C é£æ ¼çš„æ ¼å¼åŒ–æ—¥å¿—ï¼ˆä¿æŒå’Œæ—§æ¥å£å…¼å®¹ï¼‰       |
| ä¸šåŠ¡ä»£ç æ¨¡å—             | ç¤ºä¾‹ä¸šåŠ¡å‡½æ•°ï¼Œè°ƒç”¨ `TRACE(...)`        |
| å•å…ƒæµ‹è¯•               | ä½¿ç”¨ GoogleMock å¯¹ tracer è¡Œä¸ºè¿›è¡ŒéªŒè¯ |

---

## ğŸ“ å·¥ç¨‹ç»“æ„

```
project/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ trace.h         # æ¥å£ã€å®ã€ä¸­è½¬å‡½æ•°å£°æ˜
â”‚   â””â”€â”€ business.h      # ç¤ºä¾‹ä¸šåŠ¡æ¨¡å—å¤´
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ trace.cpp       # æ—¥å¿—å®ç°ï¼ˆDefaultTracerï¼‰
â”‚   â””â”€â”€ business.cpp    # ä¸šåŠ¡æ¨¡å—å®ç°ï¼Œè°ƒç”¨ TRACE
â”œâ”€â”€ test/
â”‚   â””â”€â”€ test_trace.cpp  # å•å…ƒæµ‹è¯•
â”œâ”€â”€ CMakeLists.txt      # æ„å»ºè„šæœ¬
```

---

## ğŸ”§ include/trace.hï¼ˆå® + ä¸­è½¬ï¼‰

```cpp
#pragma once
#include <string>
#include <cstdarg>

enum class Mode {
    Debug,
    Info,
    Warn,
    Error,
};

class ITracer {
public:
    virtual ~ITracer() = default;
    virtual void Log(Mode mode,
                     const std::string& file,
                     int line,
                     const std::string& func,
                     const char* fmt,
                     va_list args) = 0;
};

void SetTracer(ITracer* tracer);
ITracer* GetTracer();

#define POSITION __FILE__, __LINE__, __FUNCTION__

// å®å®šä¹‰ï¼šå…¼å®¹æ—§ TRACE ç”¨æ³•
#define TRACE(mode, fmt, ...) \
    TraceLog(mode, POSITION, fmt, ##__VA_ARGS__)

// ä¸­è½¬å‡½æ•°
void TraceLog(Mode mode,
              const char* file, int line, const char* func,
              const char* fmt, ...);
```

---

## ğŸ”§ include/business.hï¼ˆä¸šåŠ¡æ¨¡å—å¤´ï¼‰

```cpp
#pragma once
#include <string>

class Business {
public:
    void connect(const std::string& ip, int port);
};
```

---

## ğŸ”§ src/trace.cppï¼ˆé»˜è®¤ tracer å®ç°ï¼‰

```cpp
#include "trace.h"
#include <iostream>
#include <mutex>
#include <memory>

static ITracer* g_tracer = nullptr;
static std::mutex tracer_mutex;

void SetTracer(ITracer* tracer) {
    std::lock_guard<std::mutex> lock(tracer_mutex);
    g_tracer = tracer;
}

ITracer* GetTracer() {
    std::lock_guard<std::mutex> lock(tracer_mutex);
    return g_tracer;
}

class DefaultTracer : public ITracer {
public:
    void Log(Mode mode,
             const std::string& file,
             int line,
             const std::string& func,
             const char* fmt,
             va_list args) override {
        char buffer[1024];
        vsnprintf(buffer, sizeof(buffer), fmt, args);
        std::cout << "[" << static_cast<int>(mode) << "] "
                  << file << ":" << line << " "
                  << func << " - "
                  << buffer << std::endl;
    }
};

void TraceLog(Mode mode,
              const char* file, int line, const char* func,
              const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);

    ITracer* tracer = GetTracer();
    static DefaultTracer default_tracer;
    if (!tracer) tracer = &default_tracer;

    tracer->Log(mode, file, line, func, fmt, args);

    va_end(args);
}
```

---

## ğŸ”§ src/business.cppï¼ˆä¸šåŠ¡æ¨¡å—ï¼‰

```cpp
#include "business.h"
#include "trace.h"

void Business::connect(const std::string& ip, int port) {
    TRACE(Mode::Info, "Connecting to %s:%d", ip.c_str(), port);

    // æ¨¡æ‹Ÿè¿æ¥é€»è¾‘
    if (ip.empty() || port <= 0) {
        TRACE(Mode::Error, "Invalid connection parameters");
    }
}
```

---

## ğŸ§ª test/test\_trace.cppï¼ˆå•å…ƒæµ‹è¯•ï¼‰

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "trace.h"
#include "business.h"

using ::testing::_;
using ::testing::HasSubstr;
using ::testing::StrEq;

class MockTracer : public ITracer {
public:
    MOCK_METHOD(void, Log,
                (Mode mode, const std::string& file, int line,
                 const std::string& func, const char* fmt, va_list args),
                (override));
};

std::string FormatVaList(const char* fmt, va_list args) {
    char buffer[1024];
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    return std::string(buffer);
}

MATCHER_P2(FormattedMessageIs, fmt, expected_msg, "") {
    va_list copy;
    va_copy(copy, std::get<4>(arg));
    std::string actual = FormatVaList(fmt, copy);
    va_end(copy);
    return actual == expected_msg;
}

TEST(TraceTest, BusinessConnectCallsTracerCorrectly) {
    MockTracer mock;
    SetTracer(&mock);

    EXPECT_CALL(mock, Log(Mode::Info,
                          HasSubstr("business.cpp"), _, _, StrEq("Connecting to %s:%d"),
                          FormattedMessageIs("Connecting to %s:%d", "192.168.1.1:8080")));

    Business b;
    b.connect("192.168.1.1", 8080);

    SetTracer(nullptr); // æ¸…ç†
}
```

---

## ğŸ“œ CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(TraceLogger)

set(CMAKE_CXX_STANDARD 17)

include_directories(include)

add_library(trace STATIC src/trace.cpp)
add_library(business STATIC src/business.cpp)

find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

add_executable(test_trace test/test_trace.cpp)
target_link_libraries(test_trace trace business GTest::GTest GTest::Main pthread)
```

---

## ğŸ’¡ ä¸ºä»€ä¹ˆè¦ç”¨ `va_list`ï¼Ÿ

1. **å…¼å®¹åŸå§‹ C é£æ ¼å¯å˜å‚æ•°æ¥å£ï¼š**
   ä½ çš„ `XXX::Log(...)` æ¥å£ä½¿ç”¨ `...` æ¥ä¼ é€’æ ¼å¼åŒ–å‚æ•°ï¼ˆå¦‚ `printf` é£æ ¼ï¼‰ã€‚è¿™ç±»æ¥å£å†…éƒ¨å¿…é¡»ä½¿ç”¨ `va_list` å’Œ `va_start()`/`va_end()` æ¥è§£åŒ…å‚æ•°ã€‚

2. **mock æ¡†æ¶ä¸èƒ½ç›´æ¥åŒ¹é… `...` å‚æ•°ï¼š**
   GoogleMock ä¸æ”¯æŒ `...` å‚æ•°åŒ¹é…ï¼Œä½†æ”¯æŒ `va_list`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ä¸­è½¬å‡½æ•°ä¸­ä½¿ç”¨ `va_list`ï¼Œmock ä¸­ä¹Ÿä¸€è‡´ä½¿ç”¨ `va_list`ã€‚

3. **æ ¼å¼åŒ–ä¸º string ä¾¿äºæµ‹è¯•åŒ¹é…ï¼š**
   `va_list` å¯ä»¥é€šè¿‡ `vsnprintf` æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œä¾¿äºåœ¨ UT ä¸­å¯¹æ¶ˆæ¯è¿›è¡Œç²¾ç¡®åŒ¹é…ã€‚

---

## âœ… æ€»ç»“

| é¡¹ç›®å…ƒç´                    | åŠŸèƒ½                     |
| ---------------------- | ---------------------- |
| `TRACE(...)` å®         | ç®€æ´åœ°è°ƒç”¨æ—¥å¿—æ¥å£ï¼Œå¹¶æ³¨å…¥ä½ç½®ä¿¡æ¯      |
| `TraceLog(...)`        | ä¸­è½¬å‡½æ•°ï¼Œç»Ÿä¸€å¤„ç†æ ¼å¼åŒ–é€»è¾‘         |
| `va_list`              | ä¿æŒ C é£æ ¼æ—¥å¿—æ ¼å¼çš„é€šç”¨æ€§ã€å¯å˜å‚æ•°æ”¯æŒ |
| `ITracer` æ¥å£           | å®ç° mock + æ³¨å…¥èƒ½åŠ›         |
| `DefaultTracer`        | çœŸå®åœºæ™¯ä¸‹æ—¥å¿—è½åœ°æ§åˆ¶å°           |
| `MockTracer` + `GMock` | ç²¾ç¡®æ§åˆ¶ + éªŒè¯æ—¥å¿—è¡Œä¸º          |
| `Business` æ¨¡å—          | å®é™…ä¸šåŠ¡ä»£ç ä¸­çš„æ—¥å¿—ä½¿ç”¨åœºæ™¯         |

---

æ˜¯å¦è¿˜éœ€è¦æˆ‘æ‰“åŒ…è¿™ä¸ªå®Œæ•´å·¥ç¨‹ä¸ºå‹ç¼©åŒ…æˆ– GitHub æ¨¡æ¿æ ¼å¼ï¼Ÿå¦‚æœä½ ä½¿ç”¨çš„æ˜¯æŸä¸ªæµ‹è¯•æ¡†æ¶ï¼ˆå¦‚ Catch2ã€doctestï¼‰è€Œé GTestï¼Œä¹Ÿå¯ä»¥æ”¹å†™ã€‚
è¿™ä¸ªè­¦å‘Šæ˜¯å› ä¸ºä½ åœ¨ `CMakeLists.txt` ä¸­å†™äº†ç±»ä¼¼ï¼š

```cmake
target_link_libraries(trace ../GTest/)
```

ä½† `../GTest/` æ˜¯ä¸€ä¸ª**ç›®å½•**ï¼Œè€Œä¸æ˜¯ä¸€ä¸ª **åº“æ–‡ä»¶**ï¼ŒCMake åªèƒ½ `link` åˆ° **åº“ç›®æ ‡ï¼ˆå¦‚ `GTest::GTest`ï¼‰** æˆ–å®é™…çš„ `.so` / `.a` æ–‡ä»¶ï¼Œè€Œä¸æ˜¯ç›®å½•ã€‚

---

## âœ… æ­£ç¡®å¤„ç†æ–¹å¼å¦‚ä¸‹

### âœ… æ–¹æ³•ä¸€ï¼šä½¿ç”¨ CMake å®˜æ–¹æ–¹å¼æŸ¥æ‰¾ GTestï¼ˆæ¨èï¼‰

ç¡®ä¿ä½ å·²ç»åœ¨ç³»ç»Ÿä¸­é€šè¿‡åŒ…ç®¡ç†å™¨æˆ–æºç å®‰è£…äº† GoogleTestã€‚

ç„¶åä½¿ç”¨å¦‚ä¸‹æ–¹å¼ï¼š

```cmake
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

target_link_libraries(test_trace
    trace
    business
    GTest::GTest
    GTest::Main
    pthread)
```

### âœ… æ–¹æ³•äºŒï¼šå¦‚æœä½ æ˜¯ä»æºç æ‹‰å– GTestï¼ˆä¾‹å¦‚ `GTest/` æ˜¯æºç ç›®å½•ï¼‰

#### ğŸ“Œ å‡è®¾ç»“æ„å¦‚ä¸‹ï¼š

```
project/
â”œâ”€â”€ GTest/         # GoogleTest æºç 
â”œâ”€â”€ CMakeLists.txt
```

ä½ åº”å½“å°† `GTest` æ·»åŠ ä¸ºå­ç›®å½•ï¼Œå¹¶ä½¿ç”¨å®ƒæš´éœ²çš„ targetï¼š

```cmake
add_subdirectory(../GTest gtest-build)  # ç›¸å¯¹è·¯å¾„è§†æƒ…å†µä¿®æ”¹

target_link_libraries(test_trace
    trace
    business
    gtest
    gtest_main
    pthread)
```

> æ³¨æ„ï¼š`gtest` å’Œ `gtest_main` æ˜¯ GoogleTest æºç è‡ªå¸¦çš„ CMake target åã€‚

---

## âŒ é”™è¯¯åšæ³•ï¼ˆä¼šå¯¼è‡´ä½ çœ‹åˆ°çš„ warningï¼‰

```cmake
target_link_libraries(test_trace ../GTest/)
```

è¿™è¡Œä»£ç é”™è¯¯åœ°å°è¯•å°†ä¸€ä¸ªâ€œç›®å½•â€å½“ä½œâ€œåº“â€æ¥é“¾æ¥ï¼Œæ‰€ä»¥è¢« CMake å¿½ç•¥ï¼Œå¹¶ç»™å‡ºä½ çœ‹åˆ°çš„è­¦å‘Šã€‚

---

## âœ… å°ç»“

| ç›®çš„            | æ­£ç¡®æ–¹å¼                                                |
| ------------- | --------------------------------------------------- |
| ä½¿ç”¨ç³»ç»Ÿå®‰è£…çš„ GTest | `find_package(GTest REQUIRED)` + `GTest::GTest` ç­‰ç›®æ ‡ |
| ä½¿ç”¨æœ¬åœ°æºç çš„ GTest | `add_subdirectory()` + `gtest` / `gtest_main` ç›®æ ‡    |
| é¿å…å°†ç›®å½•å½“åº“é“¾æ¥     | ä¸è¦å†™ `target_link_libraries(... some/path/)`         |

---

å¦‚ä½ æ„¿æ„ï¼Œæˆ‘ä¹Ÿå¯ä»¥æ ¹æ®ä½ çš„ç›®å½•ç»“æ„ï¼Œå¸®ä½ æ”¹å†™ CMake æ–‡ä»¶ï¼Œä½¿å…¶æ­£ç¡®åŒ…å«æœ¬åœ° GTestã€‚æ˜¯å¦æ–¹ä¾¿ä½ è´´å‡ºå®é™…ç›®å½•ç»“æ„ï¼ˆ`tree` æˆ–è€… `ls -R`ï¼‰ï¼Ÿ
è¿™ä¸ªé“¾æ¥é”™è¯¯çš„æ ¹æœ¬åŸå› æ˜¯ï¼š

> ä½ åœ¨ `business.cpp` ä¸­è°ƒç”¨äº† `TraceLog(...)`ï¼Œä½†é“¾æ¥é˜¶æ®µæ‰¾ä¸åˆ°å…¶å®šä¹‰ï¼ˆsymbol missingï¼‰ï¼Œæ‰€ä»¥æŠ¥é”™ã€‚

---

## ğŸ” é”™è¯¯åˆ†æ

é”™è¯¯ä¿¡æ¯å…³é”®å¥ï¼š

```
Undefined symbols for architecture arm64:
  "TraceLog(Mode, char const*, int, char const*, char const*, ...)"
```

è¯´æ˜ **`TraceLog` å‡½æ•°çš„å®šä¹‰ï¼ˆå®ç°ï¼‰æ²¡æœ‰æ­£ç¡®é“¾æ¥åˆ° `libbusiness.dylib`**ã€‚è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„ **é“¾æ¥ç¬¦å·ç¼ºå¤±** é—®é¢˜ã€‚

---

## âœ… è§£å†³æ–¹æ¡ˆ

### âœ… 1. ç¡®ä¿ `trace.cpp` ä¸­å®šä¹‰äº† `TraceLog(...)`

åœ¨ `trace.cpp` ä¸­ï¼Œä½ éœ€è¦æœ‰è¿™ä¸ªå®šä¹‰ï¼š

```cpp
void TraceLog(Mode mode,
              const char* file, int line, const char* func,
              const char* fmt, ...) {
    // å®ç°...
}
```

å¦‚æœæ²¡æœ‰ï¼Œå°±å¿…é¡»è¡¥ä¸Šã€‚

---

### âœ… 2. ç¡®ä¿ `trace.cpp` è¢«æ­£ç¡®æ·»åŠ è¿›æ„å»ºç›®æ ‡ï¼ˆæ¯”å¦‚ `libtrace`ï¼‰

åœ¨ä½ çš„ `CMakeLists.txt` ä¸­ï¼Œåº”è¯¥æœ‰ï¼š

```cmake
add_library(trace STATIC src/trace.cpp)
```

---

### âœ… 3. ç¡®ä¿ `business` ä¾èµ–äº† `trace`ï¼Œå¦åˆ™ä¸ä¼šé“¾æ¥ trace çš„ç¬¦å·

ä½ æŠ¥é”™å‘ç”Ÿåœ¨ `libbusiness.dylib`ï¼Œè¯´æ˜å®ƒæ²¡æœ‰æ­£ç¡®é“¾æ¥ `trace`ï¼Œæ‰€ä»¥æ‰¾ä¸åˆ° `TraceLog`ã€‚

**åœ¨ä½ çš„ `CMakeLists.txt` ä¸­è¡¥ä¸Šï¼š**

```cmake
target_link_libraries(business trace)
```

ğŸ“Œ å¦‚æœä½ å½“å‰æ˜¯è¿™æ ·å†™çš„ï¼š

```cmake
add_library(business STATIC src/business.cpp)
```

é‚£å°±å¿…é¡»æ‰‹åŠ¨é“¾æ¥ trace åº“ï¼š

```cmake
target_link_libraries(business trace)
```

å¦åˆ™ç¼–è¯‘é€šè¿‡ä½†é“¾æ¥å¤±è´¥ã€‚

---

## âœ… æ•´ä½“ç¤ºä¾‹ï¼ˆä¿®å¤ç‰ˆ CMakeLists.txtï¼‰

```cmake
cmake_minimum_required(VERSION 3.10)
project(TraceLogger)

set(CMAKE_CXX_STANDARD 17)

include_directories(include)

add_library(trace STATIC src/trace.cpp)
add_library(business STATIC src/business.cpp)
target_link_libraries(business trace)  # â˜…â˜… å¿…é¡»æ·»åŠ  â˜…â˜…

# GoogleTest æ”¯æŒ
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

add_executable(test_trace test/test_trace.cpp)
target_link_libraries(test_trace trace business GTest::GTest GTest::Main pthread)
```

---

## âœ… ç¼–è¯‘é¡ºåºéªŒè¯

ç¼–è¯‘ `trace.cpp` â†’ æä¾› `TraceLog` å®ç°
é“¾æ¥ `business` æ—¶ â†’ ä½¿ç”¨ `trace` ä¸­çš„ç¬¦å·
å¦åˆ™å°±ä¼šæŠ¥é”™è¯´ `TraceLog` æœªå®šä¹‰ï¼ˆUndefined Symbolï¼‰

---

## âœ… å°ç»“

| é—®é¢˜                      | è§£å†³åŠæ³•                                        |
| ----------------------- | ------------------------------------------- |
| `TraceLog` undefined    | `trace.cpp` ä¸­å†™äº†å®šä¹‰ï¼Ÿâœ”                         |
| `trace.cpp` æ˜¯å¦åŠ å…¥åº“ç›®æ ‡ï¼Ÿ    | `add_library(trace STATIC src/trace.cpp)` âœ” |
| `business` æ˜¯å¦é“¾æ¥äº† traceï¼Ÿ | `target_link_libraries(business trace)` âœ”   |

---

å¦‚æœä½ ç¡®è®¤å†™äº† `TraceLog()`ï¼Œä½†è¿˜æ˜¯æŠ¥é”™ï¼Œå¯ä»¥è´´å‡ºä½ çš„å®Œæ•´ `CMakeLists.txt` å’Œæºæ–‡ä»¶ç»“æ„ï¼Œæˆ‘å¯ä»¥ç›´æ¥å¸®ä½ ä¿®æ­£ã€‚æ˜¯å¦éœ€è¦æˆ‘è¾“å‡ºä¸€ä¸ªæ‰“åŒ…å¥½çš„é¡¹ç›®æ¨¡æ¿ zip æ–‡ä»¶ï¼Ÿ
è¿™ä¸ªç¼–è¯‘é”™è¯¯æç¤ºä½ åœ¨ä½¿ç”¨ `std::get<4>(arg)` æ—¶å‡ºé”™äº†ï¼š

> `error: no matching function for call to 'get'`

è¿™æ˜¯å› ä¸º `MATCHER_P2(...)` çš„å‚æ•° `arg` ä¸æ˜¯ `std::tuple` ç±»å‹ï¼Œä¸èƒ½ä½¿ç”¨ `std::get<4>(arg)` å–å‡º `va_list` å‚æ•°ã€‚

---

## ğŸ” é”™è¯¯åŸå› è¯¦è§£

ä½ å®šä¹‰çš„è¿™ä¸ª matcherï¼š

```cpp
MATCHER_P2(FormattedMessageIs, fmt, expected_msg, "") {
    va_list copy;
    va_copy(copy, std::get<4>(arg)); // âŒ é”™è¯¯
    ...
}
```

åœ¨ `MATCHER_P*` çš„ matcher ä¸­ï¼Œ`arg` æ˜¯**å•ä¸ªå‚æ•°**ï¼Œä½ åœ¨ `EXPECT_CALL(...)` ä¸­å†™çš„æ˜¯ï¼š

```cpp
EXPECT_CALL(mock, Log(..., ..., ..., ..., ..., FormattedMessageIs(...)));
```

è¿™æ„å‘³ç€ `arg` å¯¹åº”çš„æ˜¯æœ€åä¸€ä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯ï¼š

```cpp
const char* fmt
va_list args
```

è¿™ä¸¤ä¸ªæ˜¯**ä¸¤ä¸ªå‚æ•°**ï¼Œ**ä¸æ˜¯ä¸€ä¸ª tuple**ï¼Œæ‰€ä»¥ä¸èƒ½ `std::get<4>`ã€‚

---

## âœ… æ­£ç¡®å†™æ³•

æˆ‘ä»¬éœ€è¦ä¸€ä¸ª matcher èƒ½å¤Ÿä½œç”¨äº `va_list args`ï¼Œå¹¶é€šè¿‡æä¾›çš„ `fmt`ï¼Œæ ¼å¼åŒ–å‡ºå®é™…å­—ç¬¦ä¸²è¿›è¡Œæ¯”å¯¹ã€‚

ä½ å¯ä»¥æ”¹æˆè¿™æ ·å†™ matcherï¼š

---

### âœ… æ¨èæ–¹æ¡ˆï¼šMATCHER\_P + capture `fmt` + æ ¼å¼åŒ–

```cpp
MATCHER_P(FormattedVaListEquals, expected_msg, "") {
    const char* fmt = "%s"; // ğŸ’¡ å¿…é¡»æ‰‹åŠ¨æŒ‡å®šæ ¼å¼ï¼Œå› ä¸º matcher åªèƒ½æ¥å—ä¸€ä¸ªå‚æ•°
    va_list copy;
    va_copy(copy, arg);
    char buffer[1024];
    vsnprintf(buffer, sizeof(buffer), fmt, copy);
    va_end(copy);
    return std::string(buffer) == expected_msg;
}
```

ç„¶ååœ¨æµ‹è¯•ä¸­è¿™ä¹ˆå†™ï¼š

```cpp
EXPECT_CALL(mock, Log(Mode::Info,
                      HasSubstr("business.cpp"), _, _, StrEq("%s"),
                      FormattedVaListEquals("192.168.1.1:8080")));
```

> ğŸ”¥ æ³¨æ„ï¼šä½ è¦**å›ºå®šä¼ å…¥æ ¼å¼å­—ç¬¦ä¸²**ä½œä¸º `EXPECT_CALL(..., StrEq("%s"), ...)`ï¼Œè¿™æ · matcher æ‰èƒ½çŸ¥é“è¦æ€ä¹ˆæ ¼å¼åŒ–ã€‚

---

### ğŸ’¡ å¯é€‰é«˜çº§æ–¹æ¡ˆï¼ˆæ•è· fmt + args çš„ç»„åˆï¼‰

å¦‚æœä½ çœŸçš„æƒ³æ¯”è¾ƒ `fmt + va_list` å¯¹åº”çš„å®é™…å­—ç¬¦ä¸²ï¼Œå°±éœ€è¦ï¼š

* å®šä¹‰ matcher æ—¶ä¼ å…¥ `fmt`ï¼›
* è°ƒç”¨æ—¶ä¿è¯æ ¼å¼åŒ¹é…ï¼›
* matcher å†…éƒ¨ `vsnprintf`ã€‚

æ¯”å¦‚ï¼š

```cpp
MATCHER_P2(FormattedMessageIs, fmt, expected_msg, "") {
    va_list copy;
    va_copy(copy, arg);  // âŒ è¿™é‡Œä»ç„¶ä¸èƒ½å·¥ä½œï¼Œå› ä¸º arg æ˜¯ va_listï¼Œè€Œä¸æ˜¯ tuple<fmt, va_list>
    ...
}
```

âš ï¸ æ‰€ä»¥è¿™ç§æ–¹å¼éœ€è¦ä½ è‡ªå·±å®šä¹‰ç»“æ„æˆ– lambdaï¼Œ**ä¸é€‚åˆç”¨ `MATCHER_P2` å®ç°**ã€‚

---

## âœ… æœ€ç»ˆç¨³å®šæ–¹æ¡ˆï¼ˆæ¨èä½¿ç”¨ lambdaï¼‰

ä½ å¯ä»¥ä¸ç”¨ matcherï¼Œç›´æ¥ç”¨ lambda æ›¿ä»£ï¼š

```cpp
EXPECT_CALL(mock, Log(Mode::Info,
                      HasSubstr("business.cpp"), _, _, StrEq("%s"), _))
    .WillOnce([](Mode, const std::string&, int, const std::string&,
                 const char* fmt, va_list args) {
        char buffer[1024];
        vsnprintf(buffer, sizeof(buffer), fmt, args);
        EXPECT_STREQ(buffer, "192.168.1.1:8080");
    });
```

---

## âœ… ç»“è®º

| æ–¹æ³•                                           | æ˜¯å¦æ¨è   | åŸå›              |
| -------------------------------------------- | ------ | -------------- |
| `std::get<4>(arg)`                           | âŒ é”™è¯¯ç”¨æ³• | `arg` ä¸æ˜¯ tuple |
| `MATCHER_P` + `va_list` æ ¼å¼åŒ–                  | âœ… æ¨è   | å¯æ§ã€ç®€å•ã€è·¨å¹³å°      |
| ä½¿ç”¨ lambda + `EXPECT_CALL(...).WillOnce(...)` | âœ… æ›´çµæ´»  | æ”¯æŒå¤æ‚åˆ¤æ–­é€»è¾‘       |

---

æ˜¯å¦éœ€è¦æˆ‘å°†æµ‹è¯•é€»è¾‘å…¨éƒ¨æ¢æˆæ¨èçš„ matcher + lambda ç»„åˆçš„å®Œæ•´å½¢å¼ï¼Ÿæˆ–è€…ä½ å¸Œæœ›æ”¯æŒä»»æ„æ ¼å¼å­—ç¬¦ä¸²å’Œå¤šä¸ªå‚æ•°ï¼Ÿæˆ‘å¯ä»¥ç»™ä½ å°è£…ä¸€ä¸ªæ›´é€šç”¨çš„ `FormatVaListMatcher`ã€‚
ä½ é‡åˆ°çš„è¿™ä¸ªé”™è¯¯æœ¬è´¨ä¸Šæ˜¯ï¼š

> `va_copy(copy, arg);` ä¸­ï¼Œ`arg` æ˜¯ä¸€ä¸ª `const va_list` ç±»å‹ï¼ˆå³ `const char* const`ï¼‰ï¼Œä½† `va_copy` éœ€è¦ä¸€ä¸ª **éå¸¸é‡** çš„ `va_list`ã€‚

---

## ğŸ§  ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿ

åœ¨ GoogleMock çš„ `MATCHER_P(...)` æˆ– `MATCHER(...)` å®ä¸­ï¼Œ`arg` çš„ç±»å‹æ˜¯**æ¨å¯¼çš„**ã€‚å½“ä½ å¯¹æŸä¸ªå‡½æ•°å‚æ•°ç±»å‹ä¸º `va_list` çš„å‡½æ•°ä½¿ç”¨ matcher æ—¶ï¼ŒGMock **æ¨å¯¼å‡ºçš„æ˜¯ `const va_list`**ï¼Œè¿™å°±å¯¼è‡´ä½ ä¸èƒ½ç›´æ¥å¯¹å®ƒä½¿ç”¨ `va_copy`ï¼Œå› ä¸º `va_copy` çš„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ `va_list`ï¼ˆé constï¼‰ã€‚

è¿™æ­£æ˜¯ä½ æŠ¥é”™ä¸­è¯´çš„ï¼š

```
error: binding reference of type '__builtin_va_list' to value of type 'char *const' drops 'const' qualifier
```

---

## âœ… è§£å†³æ–¹æ¡ˆï¼šæ‰‹åŠ¨å–æ¶ˆ `const`

ä½ å¯ä»¥ä½¿ç”¨ `const_cast` æ˜ç¡®å»æ‰ `const` é™å®šï¼š

### âœ… ä¿®å¤ä»£ç å¦‚ä¸‹ï¼š

```cpp
MATCHER_P(FormattedVaListEquals, expected_msg, "") {
    va_list copy;
    va_copy(copy, const_cast<va_list&>(arg));  // ğŸ‘ˆ è¿™é‡ŒåŠ  const_cast
    char buffer[1024];
    const char* fmt = "%s";  // ä½ éœ€è¦å’Œæµ‹è¯•ä»£ç ä¸­ format ä¿æŒä¸€è‡´
    vsnprintf(buffer, sizeof(buffer), fmt, copy);
    va_end(copy);
    return std::string(buffer) == expected_msg;
}
```

âš ï¸ `const_cast` æ˜¯å®‰å…¨çš„å‰ææ˜¯ä½ ä¸ä¼šä¿®æ”¹ `arg` æŒ‡å‘çš„æ•°æ®ï¼Œåªæ˜¯ä¸ºäº†æ ¼å¼åŒ–è¯»å–ã€‚

---

## âœ… æµ‹è¯•ä»£ç ä¸­è¿™æ ·å†™ï¼š

```cpp
EXPECT_CALL(mock, Log(Mode::Info,
                      HasSubstr("business.cpp"), _, _, StrEq("%s"),
                      FormattedVaListEquals("192.168.1.1:8080")));
```

---

## âœ… æ›¿ä»£æ–¹æ¡ˆï¼ˆæ¨è âœ…ï¼‰

ä½ å¯ä»¥ç›´æ¥ä¸ç”¨ matcherï¼Œè€Œä½¿ç”¨ `WillOnce(...)` æ­é… lambdaï¼Œ**æ›´ç›´è§‚ã€ç±»å‹æ›´å®‰å…¨**ï¼Œæ”¯æŒå¯¹ `va_list` çš„æ›´å¤æ‚å¤„ç†ï¼š

```cpp
EXPECT_CALL(mock, Log(Mode::Info,
                      HasSubstr("business.cpp"), _, _, StrEq("%s"), _))
    .WillOnce([](Mode, const std::string&, int, const std::string&,
                 const char* fmt, va_list args) {
        char buffer[1024];
        vsnprintf(buffer, sizeof(buffer), fmt, args);
        EXPECT_STREQ(buffer, "192.168.1.1:8080");
    });
```

è¿™ä¸ªæ–¹å¼ä¸ä¼šæ¶‰åŠ `va_copy` æˆ– `const_cast`ï¼Œ**ç±»å‹æ›´å®‰å…¨**ï¼Œä¹Ÿæ›´çµæ´»ã€‚

---

## âœ… æœ€ç»ˆå»ºè®®

| æ–¹å¼                       | æ¨è    | åŸå›                                     |
| ------------------------ | ----- | ------------------------------------- |
| `MATCHER_P + const_cast` | âœ… å¯ç”¨  | è§£å†³ const é—®é¢˜ï¼Œç®€å•                        |
| lambda + `WillOnce(...)` | âœ…âœ… æ¨è | ç±»å‹æ›´å®‰å…¨ï¼Œè°ƒè¯•æ–¹ä¾¿                            |
| åŸ matcher ä¸åŠ  const\_cast | âŒ æŠ¥é”™  | `va_list` æ˜¯æŒ‰å€¼ä¼ é€’çš„ï¼Œä½† GMock æ¨å¯¼æˆäº† `const` |

---

æ˜¯å¦å¸Œæœ›æˆ‘ä¸ºä½ æä¾›ä¸€ä¸ª **å®Œå…¨è§„é¿ va\_list çš„æµ‹è¯•æ¥å£é‡å†™ç‰ˆæœ¬**ï¼Ÿä¾‹å¦‚æŠŠæ ¼å¼åŒ–äº¤ç»™ä¸šåŠ¡ä¾§æˆ–å°è£…æˆ stringï¼Ÿè¿™æ ·å¯ä»¥è®©æµ‹è¯•æ›´å¥½ mockï¼Œä¹Ÿé¿å… `va_list` å¸¦æ¥çš„å¹³å°å…¼å®¹æ€§é—®é¢˜ã€‚
æ„Ÿè°¢ä½ é‡ç”³åœºæ™¯ã€‚ä½ æå‡ºçš„æ˜¯ä¸€ä¸ªåœ¨çœŸå®å·¥ç¨‹ä¸­**éå¸¸å…¸å‹**çš„å®æ—¥å¿—å°è£… + C é£æ ¼å¯å˜å‚æ•°æ—¥å¿—å‡½æ•°çš„é—®é¢˜ï¼ŒåŒæ—¶ä½ å¸Œæœ›ï¼š

* ä¿ç•™ä¸šåŠ¡ä¸­ `TRACE(...)` å®çš„è°ƒç”¨å½¢å¼ï¼›
* åç«¯å®é™…è°ƒç”¨çš„æ˜¯ä¸€ä¸ª `static` å‡½æ•°ï¼š`XXX::Log(...)`ï¼Œå…¶ä¸­æœ‰ `...` å‚æ•°ï¼›
* èƒ½åœ¨ **å•å…ƒæµ‹è¯•ä¸­ mock æ‰ `Log(...)`** çš„è¡Œä¸ºï¼›
* **å®ç°ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰+ GMock æµ‹è¯•éªŒè¯**ã€‚

---

## âœ… ä½ çš„é—®é¢˜æœ¬è´¨ä¸Šæ˜¯ï¼š

### âœ” å¦‚ä½• mock è¿™ç§ `static void Log(..., const char* fmt, ...)` çš„å‡½æ•°ï¼Ÿ

ç”±äºï¼š

* **å®ƒæ˜¯ static å‡½æ•°**ï¼›
* **ä½¿ç”¨äº†å¯å˜å‚æ•°**ï¼ˆ`...`ï¼‰ï¼›
* è¢«å® `TRACE(...)` é—´æ¥è°ƒç”¨ï¼›
* **æ— æ³•ç›´æ¥ç”¨ GoogleMock mock static å‡½æ•°**ï¼›

æˆ‘ä»¬è¦ç”¨ **ä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼‰+ è½¬å‘å±‚** + **Mockable æ¥å£** æ¥è§£å†³å®ƒã€‚

---

## âœ… æœ€ä½³å®è·µæ–¹æ¡ˆï¼šé‡å®šå‘ + ä¸­è½¬ + å¯ mock æ¥å£

---

### ğŸŒŸ 1. ä¿ç•™åŸå§‹æ¥å£ï¼ˆä¸åŠ¨ä¸šåŠ¡ä»£ç ï¼‰

```cpp
// åŸå§‹æ¥å£
class XXX {
public:
    static void Log(Mode mode,
                    const std::string& file,
                    int line,
                    const std::string& func,
                    const char* fmt,
                    ...);
};

// åŸå§‹å®
#define POSITION __FILE__, __LINE__, __FUNCTION__
#define TRACE(mode, format, ...) XXX::Log(mode, POSITION, format, ##__VA_ARGS__)
```

---

### ğŸŒŸ 2. åˆ›å»º mockable æ¥å£ï¼ˆé staticï¼‰

```cpp
class ITracer {
public:
    virtual ~ITracer() = default;

    virtual void Log(Mode mode,
                     const std::string& file,
                     int line,
                     const std::string& func,
                     const std::string& message) = 0;
};
```

è¿™é‡Œä¸å†ä¿ç•™ `...`ï¼Œè€Œæ˜¯åªä¼ æœ€ç»ˆæ ¼å¼åŒ–åçš„ `std::string`ï¼Œé¿å… GMock å¯¹ `...` çš„å…¼å®¹é—®é¢˜ã€‚

---

### ğŸŒŸ 3. ä¿®æ”¹ `XXX::Log()` å®ç°ï¼šå†…éƒ¨å°†å¯å˜å‚æ•°è½¬ä¸º `std::string`ï¼Œå†è½¬å‘ç»™å¯æ³¨å…¥çš„ `ITracer`

```cpp
#include <cstdarg>
#include <memory>
#include <mutex>

namespace {
std::shared_ptr<ITracer> g_tracer;
std::mutex g_tracer_mutex;
}

void SetTracer(std::shared_ptr<ITracer> tracer) {
    std::lock_guard<std::mutex> lock(g_tracer_mutex);
    g_tracer = std::move(tracer);
}

std::shared_ptr<ITracer> GetTracer() {
    std::lock_guard<std::mutex> lock(g_tracer_mutex);
    return g_tracer;
}

// åŸå§‹æ¥å£å®ç°
void XXX::Log(Mode mode,
              const std::string& file,
              int line,
              const std::string& func,
              const char* fmt,
              ...) {
    char buffer[1024];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

    auto tracer = GetTracer();
    if (tracer) {
        tracer->Log(mode, file, line, func, buffer);
    } else {
        // é»˜è®¤è¾“å‡º
        std::cout << "[" << static_cast<int>(mode) << "] "
                  << file << ":" << line << " "
                  << func << " - "
                  << buffer << std::endl;
    }
}
```

---

### ğŸŒŸ 4. åœ¨ UT ä¸­ mock æ‰ `ITracer`

```cpp
#include <gmock/gmock.h>
#include "your_header.h"

using ::testing::_;
using ::testing::StrEq;
using ::testing::HasSubstr;

class MockTracer : public ITracer {
public:
    MOCK_METHOD(void, Log,
                (Mode mode,
                 const std::string& file,
                 int line,
                 const std::string& func,
                 const std::string& message),
                (override));
};

TEST(LoggerTest, TraceIsCalledCorrectly) {
    auto mock = std::make_shared<MockTracer>();
    SetTracer(mock);

    EXPECT_CALL(*mock,
                Log(Mode::Info,
                    HasSubstr("business.cpp"),  // file
                    _,                          // line
                    HasSubstr("TraceIsCalledCorrectly"),  // func
                    StrEq("Connected to 127.0.0.1:8080")));

    // è°ƒç”¨å®ï¼Œä¸éœ€è¦æ”¹åŠ¨ä¸šåŠ¡é€»è¾‘
    TRACE(Mode::Info, "Connected to %s:%d", "127.0.0.1", 8080);
}
```

---

## âœ… æ€»ç»“

| é¡¹                    | è¯´æ˜                                        |
| -------------------- | ----------------------------------------- |
| `TRACE(...)`         | ä¿ç•™è°ƒç”¨æ ¼å¼ï¼Œä¸åŠ¨ä¸šåŠ¡                               |
| `XXX::Log(...)`      | static + ...ï¼Œæ˜¯æœ€ç»ˆå‡ºå£                        |
| `ITracer`            | mockable æ¥å£ï¼Œä¾›æµ‹è¯•ä½¿ç”¨                         |
| `XXX::Log` å†…éƒ¨æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸² | åˆ©äºä¼ ç»™ `ITracer`ï¼Œé¿å… mock `va_list` é—®é¢˜       |
| `SetTracer()`        | æ³¨å…¥ mock å®ç°ï¼Œç”¨äº UT                          |
| GMock å•æµ‹             | ä½¿ç”¨æ™®é€š `MOCK_METHOD`ï¼Œä¸ç”¨å¤„ç† `...` æˆ– `va_list` |

---

## âœ… Bonusï¼šä¸ºä»€ä¹ˆä¸ç›´æ¥ mock `XXX::Log`ï¼Ÿ

1. å®ƒæ˜¯ static å‡½æ•°ï¼Œä¸èƒ½ç”¨ GoogleMock ç›´æ¥ mockï¼›
2. `...` å¯å˜å‚æ•°å‡½æ•°æ— æ³• mockï¼›
3. ä¸èƒ½æ›¿æ¢ `XXX::Log` é“¾æ¥ç¬¦å·ï¼ˆé™¤éç”¨é“¾æ¥æ›¿æ¢ hackï¼‰ï¼›
4. `__FILE__`, `__LINE__`, `__FUNCTION__` æ˜¯é¢„å¤„ç†å®ï¼Œä¸èƒ½ä¼ é€’ç»™ interfaceï¼›
5. æ‰€ä»¥æˆ‘ä»¬è¦åŠ ä¸­è½¬ï¼Œä¾èµ–æ³¨å…¥å¯ mock å±‚æ˜¯å”¯ä¸€ç¨³å®šæ–¹æ¡ˆã€‚

---

å¦‚ä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ï¼š

* âœï¸ ç»™å‡ºå®Œæ•´çš„ `.cpp` å’Œ `.h` æ–‡ä»¶ï¼›
* ğŸ“ æ‰“åŒ…ä¸ºä¸€ä¸ª CMake é¡¹ç›®ï¼›
* æˆ–å°†è¿™ä¸ªæ–¹æ¡ˆä¸ä½ ç°æœ‰çš„é¡¹ç›®ç»“æ„èåˆã€‚

ä½ éœ€è¦å“ªç§ï¼Ÿ
äº†è§£äº†ï¼Œç°åœ¨ä½ é¢å¯¹çš„çœŸå®éœ€æ±‚å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼š

---

## âœ… åœºæ™¯é‡è¿°ï¼ˆçœŸå®ä¸šåŠ¡èƒŒæ™¯ï¼‰

* ä½ æ­£åœ¨ç¼–å†™ä¸€ä¸ªæ¨¡å—ï¼ˆå¦‚ä¸šåŠ¡é€»è¾‘æ¨¡å—ï¼‰ï¼›
* å¤–éƒ¨æä¾›äº†ä¸€ä¸ªé™æ€æ—¥å¿—å‡½æ•° `XXX::Log(...)`ï¼Œå®ƒæ˜¯ `static` ä¸”å¸¦ `...` çš„ C é£æ ¼æ—¥å¿—å‡½æ•°ï¼›
* **ä½ ä¸èƒ½æ”¹åŠ¨è¿™ä¸ªå¤–éƒ¨ `XXX::Log()` å®ç°**ï¼ˆå®ƒæ˜¯å¤–éƒ¨æ¨¡å—ï¼‰ï¼›
* å®ƒé€šå¸¸é€šè¿‡å® `TRACE(...)` è¢«ä¸šåŠ¡ä»£ç è°ƒç”¨ï¼›
* ä½ ç°åœ¨å¸Œæœ›åœ¨**æœ¬æ¨¡å—ä¸­å°è£…ä¸€å±‚æ—¥å¿—æ¥å£**ï¼Œå±è”½å¤–éƒ¨ä¾èµ–ï¼›
* å¹¶å¸Œæœ›é€šè¿‡ **ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰+ GMock**ï¼Œå¯¹æ—¥å¿—è¿›è¡Œå•å…ƒæµ‹è¯•éªŒè¯ã€‚

---

## âœ… è§£å†³æ–¹æ¡ˆç»“æ„ï¼ˆå°è£… + DI + mockï¼‰

æˆ‘ä»¬å¯ä»¥å°†ç›®æ ‡åˆ†å±‚æŠ½è±¡ä¸ºï¼š

| å±‚            | è¯´æ˜                                                    |
| ------------ | ----------------------------------------------------- |
| `EXTERNAL`   | å¤–éƒ¨æä¾›çš„ä¸å¯æ”¹ `XXX::Log(mode, file, line, func, fmt, ...)` |
| `LogAdapter` | æœ¬æ¨¡å—å†…éƒ¨å°è£…ï¼Œå±è”½å¤–éƒ¨æ¥å£ï¼Œç»Ÿä¸€æ ¼å¼å¤„ç†                                 |
| `ILogger`    | å¯æ³¨å…¥æ¥å£ï¼Œæ–¹ä¾¿å•å…ƒæµ‹è¯•                                          |
| `LOG(...)`   | æœ¬æ¨¡å—è‡ªå·±çš„å®ï¼Œæœ€ç»ˆç”¨äºæ›¿ä»£ `TRACE(...)`                           |
| å•å…ƒæµ‹è¯•         | å¯¹ `ILogger` æ³¨å…¥ mock å®ç°ï¼ŒéªŒè¯ message æ˜¯å¦æ­£ç¡®                |

---

## âœ… Step-by-Step å®ç°æ–¹æ¡ˆ

---

### ğŸŒŸ 1. å¤–éƒ¨ `XXX::Log(...)` ï¼ˆä½ ä¸èƒ½æ”¹ï¼‰

```cpp
// å¤–éƒ¨åº“å¤´æ–‡ä»¶ï¼ˆä¸å¯ä¿®æ”¹ï¼‰
class XXX {
public:
    static void Log(Mode mode,
                    const std::string& file,
                    int line,
                    const std::string& func,
                    const char* fmt,
                    ...);
};
```

---

### ğŸŒŸ 2. å®šä¹‰ä¸€ä¸ªæœ¬æ¨¡å—çš„å¯æ³¨å…¥æ¥å£

```cpp
// logger_interface.h
#pragma once
#include <string>

class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void Log(Mode mode,
                     const std::string& file,
                     int line,
                     const std::string& func,
                     const std::string& message) = 0;
};
```

---

### ğŸŒŸ 3. ç¼–å†™ä¸­è½¬å±‚å°è£…ï¼šLogAdapter.cpp/.h

```cpp
// log_adapter.h
#pragma once
#include "logger_interface.h"

// ä¾› LOG å®ä½¿ç”¨
void InternalLog(Mode mode,
                 const char* file, int line, const char* func,
                 const char* fmt, ...);

// æ³¨å…¥æ¥å£ï¼ˆç”¨äº UTï¼‰
void SetLogger(std::shared_ptr<ILogger> logger);
```

```cpp
// log_adapter.cpp
#include "log_adapter.h"
#include <cstdarg>
#include <memory>
#include <mutex>

// å¼•å…¥å¤–éƒ¨æ—¥å¿—
#include "external_logger.h" // å‡è®¾è¿™é‡Œå®šä¹‰äº† XXX::Log

static std::shared_ptr<ILogger> g_logger;
static std::mutex g_logger_mutex;

void SetLogger(std::shared_ptr<ILogger> logger) {
    std::lock_guard<std::mutex> lock(g_logger_mutex);
    g_logger = std::move(logger);
}

void InternalLog(Mode mode,
                 const char* file, int line, const char* func,
                 const char* fmt, ...) {
    char buffer[1024];

    va_list args;
    va_start(args, fmt);
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

    std::shared_ptr<ILogger> logger;
    {
        std::lock_guard<std::mutex> lock(g_logger_mutex);
        logger = g_logger;
    }

    if (logger) {
        logger->Log(mode, file, line, func, buffer);
    } else {
        // è°ƒç”¨å¤–éƒ¨æ—¥å¿—æ¥å£
        XXX::Log(mode, file, line, func, "%s", buffer);  // è½¬å‘æ ¼å¼åŒ–åæ–‡æœ¬
    }
}
```

---

### ğŸŒŸ 4. æœ¬æ¨¡å—å†…éƒ¨ä½¿ç”¨å®å°è£…

```cpp
// log_macro.h
#pragma once
#include "log_adapter.h"

#define LOG(mode, fmt, ...) \
    InternalLog(mode, __FILE__, __LINE__, __FUNCTION__, fmt, ##__VA_ARGS__)
```

---

### ğŸŒŸ 5. å®é™…ä¸šåŠ¡ä»£ç ä¸­ä½¿ç”¨

```cpp
// business.cpp
#include "log_macro.h"

void BusinessLogic() {
    LOG(Mode::Debug, "Connecting to server %s:%d", "127.0.0.1", 9000);
}
```

---

### ğŸŒŸ 6. å•å…ƒæµ‹è¯• mockï¼ˆä½¿ç”¨ GMockï¼‰

```cpp
// mock_logger.h
#include "logger_interface.h"
#include <gmock/gmock.h>

class MockLogger : public ILogger {
public:
    MOCK_METHOD(void, Log,
                (Mode mode,
                 const std::string& file,
                 int line,
                 const std::string& func,
                 const std::string& message),
                (override));
};
```

```cpp
// test_log.cpp
#include "mock_logger.h"
#include "log_macro.h"
#include <gtest/gtest.h>

TEST(LogTest, MessageForwardedToMock) {
    auto mock = std::make_shared<MockLogger>();
    SetLogger(mock);

    EXPECT_CALL(*mock,
                Log(Mode::Error,
                    testing::HasSubstr("business.cpp"),
                    testing::_, testing::_,
                    testing::StrEq("connect failed")));

    LOG(Mode::Error, "connect failed");
}
```

---

## âœ… æœ€ç»ˆæ•ˆæœ

ä½ å¯ä»¥ï¼š

* ä¿ç•™è‡ªå·±çš„å® `LOG(...)` è®©ä¸šåŠ¡ä»£ç ç®€æ´ï¼›
* ä¿æŒå¯¹å¤–éƒ¨æ—¥å¿—çš„é»˜è®¤è°ƒç”¨ï¼›
* åœ¨ UT ä¸­ mock æ‰å¤–éƒ¨æ—¥å¿—ï¼ŒéªŒè¯æ ¼å¼å’Œå†…å®¹ï¼›
* ä¸æ”¹å˜ä»»ä½•ä¸€è¡Œ `XXX::Log(...)` ä»£ç ï¼›
* åœ¨äº§çº¿è¿è¡Œæ—¶ï¼Œèµ° `XXX::Log(...)`ï¼›
* åœ¨æµ‹è¯•æ—¶ï¼Œèµ° `ILogger::Log(...)`ã€‚

---

## âœ… ç»“æ„å›¾

```text
LOG(...)      â†’       InternalLog(...)
                          â†“
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ loggerä¸ºç©ºï¼Ÿ â”‚â”€â”€æ˜¯â†’ XXX::Log(...)
                â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“ å¦
              mock logger->Log(...)
```

---

## âœ… æ€»ç»“å»ºè®®

| è¦ç´                  | å»ºè®®                |
| ------------------ | ----------------- |
| å¤–éƒ¨ `XXX::Log(...)` | ä¸å¯æ”¹åŠ¨ï¼Œåªèƒ½å°è£…         |
| `...` å¯å˜å‚æ•°         | åœ¨å°è£…å±‚æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸²       |
| å•å…ƒæµ‹è¯• mock          | æ³¨å…¥ `ILogger`ï¼Œæ”¯æŒéªŒè¯ |
| ä¸ä¸šåŠ¡è§£è€¦              | ä½¿ç”¨ `LOG(...)` å®   |

---

å¦‚æœä½ å¸Œæœ›æˆ‘ï¼š

* ç”Ÿæˆä¸€ä¸ªå®Œæ•´ CMake å·¥ç¨‹ï¼›
* æä¾›æ¥å£ + mock + æµ‹è¯•æ ·ä¾‹ä»£ç æ‰“åŒ…ï¼›

å¯ä»¥å‘Šè¯‰æˆ‘ä½ çš„å·¥ç¨‹ç›®å½•ç»“æ„æˆ–ç›´æ¥è¯´ä¸€å£°â€œæ‰“åŒ…ç¤ºä¾‹â€ï¼Œæˆ‘ç«‹å³ç»™ä½ å‡†å¤‡å¥½ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ
éå¸¸å¥½çš„é—®é¢˜ï¼

æ˜¯çš„ï¼Œä½ **è§‚å¯Ÿå¾—éå¸¸å‡†ç¡®**ï¼š
åœ¨é‡‡ç”¨ **å°è£… + ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰+ mockable æ¥å£**çš„æ–¹æ¡ˆåï¼Œ**æ—¥å¿—çš„å¤„ç†æ–¹å¼ç¡®å®å‘ç”Ÿäº†å˜åŒ–**ï¼Œä¸»è¦ä½“ç°åœ¨ï¼š

---

## ğŸ”„ ä» â€œfmt + ...â€ å˜ä¸º â€œstd::string messageâ€ çš„å˜åŒ–

### ğŸ“Œ åŸå§‹æ–¹å¼ï¼ˆç›´æ¥è°ƒç”¨å¤–éƒ¨æ—¥å¿—ï¼‰ï¼š

```cpp
XXX::Log(Mode::Info, __FILE__, __LINE__, __FUNCTION__, "connect to %s:%d", ip, port);
```

è¿™ç§æ–¹å¼ä¼ çš„æ˜¯ï¼š

* ä¸€ä¸ª `const char* fmt`
* åé¢è·Ÿç€å¤šä¸ªå‚æ•°ï¼ˆå¯å˜å‚æ•°ï¼‰`...`

---

### âœ… æ–°æ–¹å¼ï¼ˆç»è¿‡å°è£…åçš„æ¥å£ï¼‰ï¼š

```cpp
InternalLog(Mode::Info, __FILE__, __LINE__, __FUNCTION__, "connect to %s:%d", ip, port);
```

å†…éƒ¨åšäº†è¿™ä»¶äº‹ï¼š

```cpp
char buffer[1024];
vsnprintf(buffer, sizeof(buffer), fmt, args);
logger->Log(..., std::string(buffer)); // ä¼ å…¥æ ¼å¼åŒ–åçš„å®Œæ•´å­—ç¬¦ä¸²
```

å³ï¼š

> **åœ¨å°è£…å‡½æ•°ä¸­**å…ˆæ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œå†å°†æ ¼å¼åŒ–åçš„ç»“æœï¼ˆ`std::string message`ï¼‰ä¼ ç»™ mockable æ¥å£ã€‚

---

## âœ… ä¸ºä»€ä¹ˆè¦åšè¿™ä¸ªå˜åŒ–ï¼Ÿ

### âœ… åŸå›  1ï¼š`...` å¯å˜å‚æ•°å‡½æ•°æ— æ³•è¢« mock

* GMock **æ— æ³• mock `...` å¯å˜å‚æ•°å‡½æ•°**ï¼ˆä¸èƒ½å†™ `MOCK_METHOD(..., (..., const char*, ...))`ï¼‰
* `va_list` ä¹Ÿä¸èƒ½ç”¨ matcher ç›´æ¥åˆ¤æ–­
* è€Œ `std::string` åˆ™å¯ä»¥è¢« GMock **ç²¾ç¡®éªŒè¯**

---

### âœ… åŸå›  2ï¼šä½ è¦å¯¹å†…å®¹è¿›è¡Œæµ‹è¯•éªŒè¯

ä½ å¸Œæœ›åœ¨æµ‹è¯•ä¸­è¿™ä¹ˆå†™ï¼š

```cpp
EXPECT_CALL(mock_logger,
            Log(Mode::Info, ..., "connect to 127.0.0.1:9000"));
```

è¿™å¿…é¡»ä¾èµ–æ—¥å¿—å†…å®¹å·²ç»æ˜¯**å®Œæ•´çš„ message string**ã€‚

---

### âœ… åŸå›  3ï¼šä¾èµ–æ³¨å…¥æ¥å£è®¾è®¡è¦æ±‚ç¨³å®šã€æµ‹è¯•å‹å¥½

è®¾è®¡ä¸€ä¸ª clean interfaceï¼š

```cpp
virtual void Log(Mode mode,
                 const std::string& file,
                 int line,
                 const std::string& func,
                 const std::string& message) = 0;
```

æ¯”ä¸‹é¢è¿™ç§æ–¹å¼æ›´å¯ç»´æŠ¤ï¼š

```cpp
// ä¸èƒ½è¿™ä¹ˆå†™ï¼GMock ä¸æ”¯æŒ
virtual void Log(Mode mode, ..., const char* fmt, ...) = 0;
```

---

## âœ… ä¼šå¯¹ä½¿ç”¨æ–¹æœ‰å½±å“å—ï¼Ÿ

**ä¸ä¼šæœ‰ä»»ä½•å½±å“**ï¼Œå› ä¸ºä½ ä»ç„¶ä½¿ç”¨ä¸šåŠ¡ä¾§ç†Ÿæ‚‰çš„ `LOG(...)` å®ï¼š

```cpp
LOG(Mode::Debug, "connect to %s:%d", "127.0.0.1", 9000);
```

åº•å±‚å°è£…ï¼ˆ`InternalLog`ï¼‰å·²ç»è‡ªåŠ¨å®Œæˆäº†æ ¼å¼åŒ–ï¼š

```cpp
char buf[1024];
vsnprintf(buf, sizeof(buf), fmt, args);
```

> âœ… æ‰€ä»¥ä½¿ç”¨è€… **ä»ç„¶å†™ fmt + å‚æ•°**ï¼Œåªæ˜¯ä½ **å†…éƒ¨æŠŠå®ƒè½¬æˆ string äº†**ï¼Œä»¥ä¾¿ mockã€‚

---

## âœ… æ€»ç»“

| å†…å®¹         | æ—§æ–¹å¼ï¼ˆä¸å¯æµ‹è¯•ï¼‰              | æ–°æ–¹å¼ï¼ˆå¯ mockã€å¯éªŒè¯ï¼‰              |
| ---------- | ---------------------- | ---------------------------- |
| æ¥å£å‚æ•°       | `const char* fmt, ...` | `const std::string& message` |
| æ˜¯å¦å¯è¢« mock  | âŒ æ— æ³• mock              | âœ… å¯ç”¨ GMock                   |
| æ˜¯å¦æ”¯æŒéªŒè¯å†…å®¹   | âŒ éš¾ä»¥éªŒè¯                 | âœ… å¯ç”¨ `StrEq` / `HasSubstr`   |
| ä½¿ç”¨æ–¹å¼æ˜¯å¦å˜    | âŒ ä¼šå—é™                  | âœ… ä½¿ç”¨ `LOG(...)` ä¸å˜           |
| å°è£…å±‚æ˜¯å¦éœ€è¦æ ¼å¼åŒ– | âŒ å¤–éƒ¨å¤„ç†                 | âœ… å†…éƒ¨ä½¿ç”¨ `vsnprintf`           |

---

å¦‚æœä½ åšæŒè®© mock æ¥å£ä¹Ÿä¿ç•™ `fmt + ...` çš„å½¢å¼ï¼Œé‚£åªèƒ½ç”¨éå¸¸ hack çš„é“¾æ¥æ›¿æ¢æˆ–è€…å‡½æ•°æŒ‡é’ˆï¼Œä½†è¿™ä¼šä¸§å¤± mock çš„ä¼˜åŠ¿ï¼Œä¸æ¨èã€‚

æ˜¯å¦éœ€è¦æˆ‘ç»™ä½ ä¸€ä¸ªç»“æ„æ¸…æ™°çš„ demo å·¥ç¨‹ï¼ˆå« `LOG()` å® + `ITracer` + GMock å•å…ƒæµ‹è¯•ï¼‰ï¼Ÿå¯ä»¥å¿«é€Ÿå¼€å§‹ç”¨è¿™ä¸ªæ–¹å¼ã€‚
éå¸¸åˆ°ä½çš„é—®é¢˜ï¼Œè¿™æ­£æ˜¯è®¾è®¡è¿™ç±»æ—¥å¿—å°è£…æ—¶**å¿…é¡»æƒè¡¡çš„æ ¸å¿ƒé—®é¢˜**ï¼š

---

## âœ… é—®é¢˜ç®€è¿°

ä½ åŸæœ¬ä½¿ç”¨çš„æ˜¯ `fmt + args` çš„å½¢å¼ï¼Œä¾‹å¦‚ï¼š

```cpp
TRACE(Mode::Info, "connected to %s:%d", ip, port);
```

å°è£…åè½¬æ¢æˆï¼š

```cpp
LOG(Mode::Info, "connected to %s:%d", ip, port);  // âœ… ä¸šåŠ¡ä½¿ç”¨ä¿æŒä¸å˜
â†“
â†’ å°è£…ä¸­ `vsnprintf` è½¬æˆ `std::string`
â†’ `ILogger::Log(..., const std::string& message)`
```

ä½ æ‹…å¿ƒï¼š

1. ğŸ” **ä½¿ç”¨æ–¹å¼æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Ÿ**
2. ğŸ¢ **æ€§èƒ½æ˜¯å¦æœ‰æ˜æ˜¾å¼€é”€ï¼Ÿ**

---

## âœ… ä¸€ã€ä½¿ç”¨æ–¹å¼æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Ÿ

### âœ… ç»“è®ºï¼š**å¯¹è°ƒç”¨è€…**æ²¡æœ‰å˜åŒ–ï¼Œåªè¦ä½ å°è£…å¾—å½“ã€‚

ä½ ä¸šåŠ¡ä¸­ä»ç„¶å†™çš„æ˜¯ï¼š

```cpp
LOG(Mode::Info, "connected to %s:%d", ip, port);
```

ä½ çš„å®ï¼š

```cpp
#define LOG(mode, fmt, ...) \
    InternalLog(mode, __FILE__, __LINE__, __FUNCTION__, fmt, ##__VA_ARGS__)
```

è¿™ä¸€ç‚¹**å’ŒåŸæ¥çš„ `TRACE(...)` å®ä¸€æ¨¡ä¸€æ ·**ï¼Œæ˜¯ C é£æ ¼æ—¥å¿—æ¥å£çš„ä¸€ç§ç»å…¸å°è£…æ–¹å¼ã€‚

---

### âœ… æ‰€ä»¥ä½¿ç”¨ä¸Š âœ… æ²¡å˜åŒ–

* å®å°è£…ï¼š`LOG(...)`
* æ ¼å¼ä¼ å‚ï¼š`fmt + args`
* è‡ªåŠ¨è®°å½•è°ƒç”¨ä½ç½®ï¼š`__FILE__`, `__LINE__`, `__FUNCTION__`
* âœ… ä½ ç”šè‡³å¯ä»¥å…¨å±€æ›¿æ¢ `TRACE â†’ LOG` å³å¯

---

## âœ… äºŒã€æ€§èƒ½æ˜¯å¦ä¼šæœ‰é¢å¤–å¼€é”€ï¼Ÿ

### âœ… æ˜¯çš„ï¼Œç›¸æ¯”ç›´æ¥ `XXX::Log(fmt, ...)`ï¼Œç¡®å®ä¼šå¤šä¸€ä¸ªæ­¥éª¤ï¼š

```cpp
vsnprintf â†’ æ„é€  std::string â†’ æ³¨å…¥æ¥å£ â†’ mock or fallback
```

> å³ä¾¿ä½ æœ€ç»ˆè¿˜æ˜¯è°ƒç”¨äº† `XXX::Log(...)`ï¼Œä½ ä¹Ÿåœ¨å°è£…å±‚**é¢å¤–æ ¼å¼åŒ–äº†ä¸€æ¬¡å­—ç¬¦ä¸²**ï¼Œè¿™æ˜¯å¤šä½™çš„ã€‚

---

### âš ï¸ ä½†ï¼šè¿™ä¸ªå¼€é”€**é€šå¸¸å¯ä»¥æ¥å—**ï¼ŒåŸå› å¦‚ä¸‹ï¼š

#### âœ… 1. æ—¥å¿—æœ¬èº«é€šå¸¸æ˜¯ä½é¢‘/IOå¯†é›†

* æ—¥å¿—å±äº **éå…³é”®è·¯å¾„**
* å’Œ vsnprintf ç›¸æ¯”ï¼Œ**å†™å…¥æ–‡ä»¶/æ§åˆ¶å°çš„ IO æ›´æ…¢**
* æ‰€ä»¥ vsnprintf çš„è¿™ç‚¹æ—¶é—´ï¼Œ**é€šå¸¸ä¸ä¼šæˆä¸ºç“¶é¢ˆ**

#### âœ… 2. ä½ éœ€è¦æ›´å¼ºçš„å¯æµ‹è¯•æ€§

* å¯ mock æ˜¯ä½ å½“å‰çš„æ ¸å¿ƒç›®æ ‡
* `...` å‡½æ•°ä¸å¯ mockï¼Œè€Œä½ é€šè¿‡å°è£…è§„é¿äº†å®ƒ

#### âœ… 3. å¤šæ•°æ—¥å¿—åº“ï¼ˆåŒ…æ‹¬ spdlogã€glogï¼‰å†…éƒ¨ä¹Ÿåšäº†ç±»ä¼¼è½¬åŒ–

* æ¯”å¦‚ glog çš„ `LOG(INFO) <<` æ˜¯ç”¨ stream æ‹¼æ¥çš„
* spdlog ä¹Ÿæ ¼å¼åŒ–åå­˜å…¥ buffer æˆ–è¾“å‡ºæµ

#### âœ… 4. ä½ å¯ä»¥å¯ç”¨ä¼˜åŒ–æ‰‹æ®µç¼“è§£å¼€é”€ï¼š

* ä½¿ç”¨ thread\_local buffer å‡å°‘å †æ ˆåˆ†é…ï¼›
* å°è£…ä¸­åš compile-time format string ä¼˜åŒ–ï¼›
* æˆ–ä»…åœ¨ debug/release ä¸åŒåœºæ™¯ä¸‹å¯ç”¨æ—¥å¿—/æ ¼å¼åŒ–ã€‚

---

## âœ… è¡¥å……æ–¹æ¡ˆï¼ˆå¦‚å¯¹æ€§èƒ½éå¸¸æ•æ„Ÿï¼‰

å¦‚æœä½ ä»ç„¶æ‹…å¿ƒå¼€é”€ï¼Œå¯ä»¥è€ƒè™‘ï¼š

### ğŸš€ æ–¹æ¡ˆ Aï¼šåœ¨ release æ¨¡å¼ä¸‹èµ°ç›´é€šè·¯å¾„ï¼ˆè·³è¿‡å°è£…ï¼‰

```cpp
#ifdef ENABLE_MOCK_LOGGING
    // mock è·¯å¾„ï¼Œæ ¼å¼åŒ–ä¸º string
#else
    XXX::Log(mode, file, line, func, fmt, ...);
#endif
```

### ğŸš€ æ–¹æ¡ˆ Bï¼šå°è£…ä¸­åˆ¤æ–­ logger æ˜¯å¦ä¸ºç©ºå†æ ¼å¼åŒ–

```cpp
auto logger = GetLogger();
if (logger) {
    // æ‰åš vsnprintfï¼Œæ„é€  string
} else {
    // ç›´æ¥è°ƒç”¨ XXX::Log(...)
}
```

---

## âœ… æ€»ç»“å¯¹æ¯”è¡¨

| ç»´åº¦    | åŸå§‹æ–¹å¼ `XXX::Log(fmt, ...)` | å°è£…æ–¹å¼ `InternalLog(fmt, ...)` |
| ----- | ------------------------- | ---------------------------- |
| è°ƒç”¨æ–¹å¼  | `TRACE(...)`              | `LOG(...)`ï¼ˆä¸€è‡´ï¼‰               |
| å¯æµ‹è¯•æ€§  | âŒ æ— æ³• mock `...`           | âœ… GMock å¯éªŒè¯                  |
| æ€§èƒ½    | âœ… å°‘ä¸€æ¬¡æ ¼å¼åŒ–                  | âš ï¸ å¤šä¸€æ¬¡ `vsnprintf`           |
| è°ƒè¯•éªŒè¯  | âŒ æ— æ³•éªŒè¯å†…å®¹                  | âœ… å¯éªŒè¯ message                |
| äº§çº¿ç¨³å®šæ€§ | âœ… ç›´æ¥è°ƒç”¨å¤–éƒ¨                  | âœ… é»˜è®¤ fallback åˆ°å¤–éƒ¨            |
| ç»´æŠ¤æ€§   | ä¸­ç­‰                        | é«˜ï¼Œå¯æ‰©å±•                        |

---

## âœ… å»ºè®®

* âœ… å¦‚æœä½ é‡è§† **æµ‹è¯•å¯æ§æ€§ã€æ¨¡å—éš”ç¦»ã€mock çµæ´»æ€§** â†’ å½“å‰å°è£…æ–¹æ¡ˆæ˜¯ä¸šç•Œé€šè¡Œæ–¹æ¡ˆï¼›
* âš ï¸ å¦‚æœä½ ç¡®å®å¤„äºé«˜é¢‘ç‡æ—¥å¿—è°ƒç”¨åœºæ™¯ï¼ˆå¦‚åƒçº§ TPS traceï¼‰ â†’ å¯è€ƒè™‘å†ä¼˜åŒ–ï¼›
* ğŸš€ æœ€ä½³æ–¹æ¡ˆï¼š**å°è£…ä¸­åˆ¤æ–­æ˜¯å¦å¯ç”¨ mockï¼Œå¿…è¦æ—¶ç›´é€šå¤–éƒ¨å‡½æ•°**ï¼Œç»“åˆ release/debug ç¼–è¯‘å®ï¼Œæ€§èƒ½å‡ ä¹æ— æŸã€‚

---

å¦‚ä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥æ ¹æ®è¿™ä¸ªè®¾è®¡æ‰“åŒ…ä¸€ä¸ªå®Œæ•´ CMake å·¥ç¨‹ç¤ºä¾‹ï¼Œæˆ–è€…å¸®ä½ åŠ ä¸Š buffer reuse / release ä¼˜åŒ–ç­–ç•¥ã€‚æ˜¯å¦éœ€è¦æˆ‘è¡¥å……ä¸€ä»½ï¼Ÿ

åœ¨ C++ ä¸­ï¼Œ\*\*å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰\*\*è¢«å¹¿æ³›åœ°ç”¨æ¥ä¿è¯æŸä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä¸”ä¸ºå…¨å±€è®¿é—®æä¾›ä¸€ä¸ªç»Ÿä¸€çš„å…¥å£ã€‚ç„¶è€Œï¼Œå½“å¤§é‡ä½¿ç”¨æˆ–æ»¥ç”¨å•ä¾‹æ¨¡å¼æ—¶ï¼Œä¼šå¸¦æ¥ä¸€ç³»åˆ—è´Ÿé¢å½±å“ä¸éšæ‚£ï¼Œä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ç‚¹ï¼š

---

## 1. éšè—çš„å…¨å±€çŠ¶æ€ï¼Œå¯¼è‡´å¯ç»´æŠ¤æ€§å’Œå¯æµ‹è¯•æ€§ä¸‹é™

* **å…¨å±€çŠ¶æ€**ï¼šå•ä¾‹æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§â€œä¼ªå…¨å±€å˜é‡â€ã€‚ä»»æ„ä»£ç éƒ½å¯ä»¥é€šè¿‡ `Singleton::instance()` è®¿é—®æˆ–ä¿®æ”¹å®ƒçš„å†…éƒ¨çŠ¶æ€ï¼Œå¯¼è‡´ç¨‹åºçš„è¡Œä¸ºä¾èµ–äºâ€œçœ‹ä¸è§â€çš„å¤–éƒ¨çŠ¶æ€ï¼Œå¢åŠ ç†è§£æˆæœ¬ã€‚

  ```cpp
  // éšå¼ä¾èµ–ï¼Œä»»ä½•åœ°æ–¹éƒ½å¯èƒ½æ”¹å˜ Logger çš„æ—¥å¿—çº§åˆ«
  Logger::instance().setLevel(LogLevel::DEBUG);
  ```

* **éš¾ä»¥åšå•å…ƒæµ‹è¯•**ï¼šå› ä¸ºå•ä¾‹çš„çŠ¶æ€æ˜¯å…¨å±€ä¸”æŒä¹…åŒ–çš„ï¼Œä¸åŒæµ‹è¯•ç”¨ä¾‹é—´ä¼šç›¸äº’å½±å“ã€‚è¦åšéš”ç¦»æµ‹è¯•ï¼Œå¿…é¡»æ˜¾å¼åœ°â€œé‡ç½®â€æˆ–â€œæ¨¡æ‹Ÿâ€å•ä¾‹ï¼Œä¸ç„¶æµ‹è¯•é—´ä¼šå‡ºç°â€œä¸Šä¸‹æ–‡æ±¡æŸ“â€ã€‚

  ```cpp
  // éœ€è¦åœ¨æ¯ä¸ªæµ‹è¯•ç»“æŸåæ‰‹åŠ¨æ¸…ç†çŠ¶æ€
  tearDown() {
      Logger::instance().reset();
  }
  ```

---

## 2. éšå¼ä¾èµ–å…³ç³»ï¼Œä¸åˆ©äºä»£ç è§£è€¦

* **éšè—ä¾èµ–**ï¼šä½¿ç”¨è€…æ— éœ€é€šè¿‡æ„é€ å‡½æ•°æˆ–å‚æ•°ä¼ é€’å°±èƒ½æ‹¿åˆ°å•ä¾‹ï¼Œå¯¼è‡´ç±»ä¸å•ä¾‹ä¹‹é—´çš„ä¾èµ–å…³ç³»ä¸æ˜ç¡®ã€‚é˜…è¯»æˆ–é‡æ„ä»£ç æ—¶ï¼Œéš¾ä»¥å¿«é€Ÿæ‰¾åˆ°åˆ°åº•å“ªäº›æ¨¡å—ä¾èµ–äº†è¿™ä¸ªå•ä¾‹ã€‚

* **è¿èƒŒä¾èµ–æ³¨å…¥åŸåˆ™**ï¼šæœ€ä½³å®è·µé€šå¸¸æ˜¯é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ï¼ˆDependency Injectionï¼‰ï¼Œæ˜¾å¼å£°æ˜ä¾èµ–ï¼Œå¢å¼ºæ¨¡å—çš„å¯æ›¿æ¢æ€§ä¸å¯æµ‹è¯•æ€§ã€‚å•ä¾‹åˆ™æŠŠä¾èµ–æ³¨å…¥â€œè—â€äº†èµ·æ¥ï¼Œä¸åˆ©äºæŒ‰éœ€æ›¿æ¢æˆ–æ¨¡æ‹Ÿã€‚

---

## 3. ç”Ÿå‘½å‘¨æœŸç®¡ç†çš„å¤æ‚æ€§

* **æ„é€ ä¸é”€æ¯é¡ºåºä¸ç¡®å®š**ï¼šC++ ä¸­å•ä¾‹é€šå¸¸ç”¨å‡½æ•°å†…é™æ€å˜é‡æ¥å®ç°ï¼š

  ```cpp
  class Config {
  public:
      static Config& instance() {
          static Config inst;  // åœ¨é¦–æ¬¡è°ƒç”¨æ—¶æ„é€ ï¼Œç¨‹åºç»“æŸæ—¶é”€æ¯
          return inst;
      }
  private:
      Config() { /* ... */ }
  };
  ```

  ä½†å¤šä¸ªå•ä¾‹ä¹‹é—´å¦‚æœäº’ç›¸ä¾èµ–ï¼Œ**é”€æ¯é¡ºåº**å®¹æ˜“å‡ºé”™ï¼Œå¯¼è‡´è®¿é—®å·²é”€æ¯çš„å•ä¾‹å‘ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼ˆâ€œé™æ€åˆå§‹åŒ–æ¬¡åºè¯…å’’â€ï¼‰ã€‚

* **å»¶è¿Ÿåˆå§‹åŒ–é—®é¢˜**ï¼šè™½ç„¶å‡½æ•°å†…é™æ€å®ç°äº†å»¶è¿Ÿåˆå§‹åŒ–ï¼Œä½†å¦‚æœåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ²¡æœ‰åšå¥½åŒæ­¥ï¼Œå°±ä¼šå¼•å‘**å¹¶å‘åˆå§‹åŒ–ç«æ€**ã€‚

---

## 4. éš¾ä»¥å¹¶è¡Œä¸å¤šçº¿ç¨‹å®‰å…¨

* **çº¿ç¨‹å®‰å…¨**ï¼šC++11 ä»¥æ¥ï¼Œå‡½æ•°å†…é™æ€å¯¹è±¡çš„åˆå§‹åŒ–æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†åœ¨ C++11 ä¹‹å‰ï¼Œéœ€è¦æ‰‹åŠ¨åŠ é”ï¼Œä»£ç å¤æ‚ä¸”å®¹æ˜“å‡ºé”™ã€‚è€Œä¸”å³ä¾¿å•ä¾‹çš„åˆå§‹åŒ–æ˜¯å®‰å…¨çš„ï¼Œå…¶å†…éƒ¨çŠ¶æ€çš„ä¿®æ”¹ä»éœ€è€ƒè™‘é”ã€äº’æ–¥ç­‰å¹¶å‘æ§åˆ¶ã€‚

* **éšè—é”å¼€é”€**ï¼šå¦‚æœå•ä¾‹å†…éƒ¨é€šè¿‡é”æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œå„å¤„é¢‘ç¹è®¿é—®å•ä¾‹çš„æ¥å£å°±ä¼šå¸¦æ¥æ€§èƒ½ç“¶é¢ˆã€‚

---

## 5. æ‰©å±•ä¸ç»§æ‰¿å—é™

* **ç±»éš¾ä»¥ç»§æ‰¿**ï¼šå•ä¾‹é€šå¸¸æŠŠæ„é€ å‡½æ•°ç§æœ‰åŒ–ï¼Œç¦æ­¢æ‹·è´/èµ‹å€¼ï¼Œå¯¼è‡´æ— æ³•é€šè¿‡ç»§æ‰¿æ¥æ‰©å±•å•ä¾‹ç±»çš„åŠŸèƒ½ï¼Œä¹Ÿéš¾ä»¥ç”¨å·¥å‚æ–¹æ³•åŠ¨æ€åˆ‡æ¢å®ç°ã€‚

* **ä¸æ˜“æ›¿æ¢å®ç°**ï¼šå¦‚æœéœ€è¦åœ¨ä¸åŒåœºæ™¯ä¸‹ä½¿ç”¨ä¸åŒçš„å®ç°ï¼ˆä¾‹å¦‚ `ILogger` æ¥å£çš„å¤šç§åç«¯ï¼‰ï¼Œå•ä¾‹ç¡¬ç¼–ç å®ç°ä¼šè®©æ›¿æ¢å˜å¾—éå¸¸éº»çƒ¦ã€‚

---

## 6. ä»£ç å¤ç”¨ä¸ç»„ä»¶åŒ–å—é˜»

* **è·¨æ¨¡å—å¤ç”¨å›°éš¾**ï¼šå½“å¤šä¸ªæ¨¡å—éƒ½å„è‡ªå®ç°äº†ä¸€ä»½å•ä¾‹ï¼Œæˆ–ä¸åŒåº“ä¸­æœ‰åŒåå•ä¾‹ç±»ï¼Œä¼šå¯¼è‡´å†²çªæˆ–é‡å¤é€»è¾‘ã€‚è€Œå…±äº«åŒä¸€ä¸ªå•ä¾‹åˆä¼šæŠŠæ‰€æœ‰æ¨¡å—éƒ½è€¦åˆåœ¨ä¸€èµ·ã€‚

* **æ’ä»¶åŒ–ã€çƒ­æ’æ‹”å—é™**ï¼šå•ä¾‹å¸¸é©»å†…å­˜å¹¶ä¸”å’Œåº”ç”¨çš„å¯åŠ¨/é€€å‡ºç´§å¯†ç»‘å®šï¼Œä¸åˆ©äºåŠ¨æ€åŠ è½½ã€å¸è½½æˆ–è¿è¡Œæ—¶æ›¿æ¢ã€‚

---

## æ›¿ä»£æ–¹æ¡ˆä¸æœ€ä½³å®è·µ

1. **ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰**
   é€šè¿‡æ„é€ å‡½æ•°æˆ–å·¥å‚å‡½æ•°ï¼Œå°†æ‰€éœ€å¯¹è±¡ï¼ˆå¯èƒ½æ˜¯å•ä¾‹æˆ–å…¶ä»–ä½œç”¨åŸŸï¼‰æ˜¾å¼æ³¨å…¥åˆ°ç±»ä¸­ï¼Œé¿å…å…¨å±€è®¿é—®ã€‚

2. **å±€éƒ¨é™æ€å¯¹è±¡**
   ä»…åœ¨ç¡®å®éœ€è¦å…¨å±€å”¯ä¸€ã€å¹¶ä¸”æ— çŠ¶æ€æˆ–è½»é‡çš„ç±»ä¸­ä½¿ç”¨ã€‚

3. **æœåŠ¡å®šä½å™¨ï¼ˆService Locatorï¼‰**
   å°†â€œå…¨å±€è®¿é—®ç‚¹â€å°è£…åˆ°ä¸€ä¸ªé›†ä¸­ç®¡ç†çš„å®¹å™¨é‡Œï¼Œé€šè¿‡å®¹å™¨æŸ¥æ‰¾æœåŠ¡ï¼Œä¾èµ–å…³ç³»æ¯”è£¸å•ä¾‹æ›´å®¹æ˜“æ§åˆ¶ã€‚

4. **å‘½åç©ºé—´ + free function + å†…éƒ¨é™æ€**
   å¯¹äºæç®€å•ã€æ— çŠ¶æ€çš„å·¥å…·å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨å‘½åç©ºé—´åŠ å‡½æ•°çš„æ–¹å¼ï¼Œé¿å…å•ä¾‹ç±»çš„å¤æ‚æ€§ã€‚

---

### æ€»ç»“

è™½ç„¶å•ä¾‹æ¨¡å¼åœ¨æŸäº›åœºæ™¯ä¸‹ï¼ˆæ¯”å¦‚é…ç½®ç®¡ç†ã€æ—¥å¿—ç³»ç»Ÿï¼‰èƒ½å¤Ÿæ–¹ä¾¿åœ°æä¾›â€œå…¨å±€å”¯ä¸€â€æœåŠ¡ï¼Œä½†**æ»¥ç”¨å•ä¾‹**ä¼šå¸¦æ¥éšè—çš„å…¨å±€çŠ¶æ€ã€éš¾ä»¥æµ‹è¯•ã€éšå¼ä¾èµ–ã€å¹¶å‘é—®é¢˜ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤æ‚ç­‰ä¸€ç³»åˆ—ç—›ç‚¹ã€‚å»ºè®®åœ¨è®¾è®¡ä¹‹åˆå¤šè€ƒè™‘ä¾èµ–æ³¨å…¥ã€å·¥å‚æ¨¡å¼ç­‰æ›¿ä»£æ–¹æ¡ˆï¼Œå°½é‡å‡å°‘å¯¹å•ä¾‹çš„ä¾èµ–ï¼Œä»è€Œæå‡ä»£ç çš„å¯ç»´æŠ¤æ€§ã€å¯æµ‹è¯•æ€§å’Œå¯æ‰©å±•æ€§ã€‚

åœ¨ C++ ä¸­ï¼Œå•ä¾‹æ¨¡å¼åœ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ä¸Šé€šå¸¸ä¾èµ–äºâ€œå‡½æ•°å†…é™æ€å˜é‡â€æˆ–â€œåŠ¨æ€åˆ†é…ï¼‹atexit æ³¨å†Œâ€çš„æ–¹å¼ï¼Œè¿™ä¸¤ç§å®ç°éƒ½éšè—äº†å¯¹è±¡çš„æ„é€ ä¸ææ„æ—¶æœºï¼Œä»è€Œå¸¦æ¥ä»¥ä¸‹ä¸»è¦é—®é¢˜ï¼š

---

## 1. é™æ€åˆå§‹åŒ–æ¬¡åºä¸ç¡®å®šï¼ˆStatic Initialization Order Fiascoï¼‰

```cpp
// A.h
struct A {
    A();
    ~A();
    static A& instance();
};
// A.cpp
A& A::instance() {
    static A inst;  // æ„é€ æ—¶æœºï¼šé¦–æ¬¡è°ƒç”¨æœ¬å‡½æ•°
    return inst;
}

// B.h / B.cpp åŒç†
```

* å¦‚æœ `A::instance()` ä¸ `B::instance()` ç›¸äº’ä¾èµ–ï¼Œæ¯”å¦‚åœ¨å„è‡ªçš„æ„é€ å‡½æ•°ä¸­è°ƒç”¨å¯¹æ–¹çš„ `instance()`ï¼Œå°±å¯èƒ½å‡ºç°ï¼š

  * ç¨‹åºå…ˆæ„é€ äº† `A`ï¼Œåœ¨å…¶æ„é€ æœŸé—´åˆå»è·å– `B`ï¼Œæ­¤æ—¶ `B` å°šæœªæ„é€ â€”â€”è®¿é—®æœªåˆå§‹åŒ–å†…å­˜ã€‚
  * æˆ–è€…ç¨‹åºææ„æ—¶ï¼Œå…ˆé”€æ¯äº† `A`ï¼Œç„¶ååœ¨ `B` çš„ææ„ä¸­ä»è¯•å›¾è®¿é—® `A`ï¼Œå¯¼è‡´è®¿é—®å·²é”€æ¯å¯¹è±¡ã€‚

è¿™ç±»é—®é¢˜åœ¨å¤šå•ä¾‹ä¾èµ–ä¸­æéš¾è°ƒè¯•ï¼Œä¸”å¾€å¾€åªåœ¨ç¨‹åºé€€å‡ºé˜¶æ®µæ‰è§¦å‘ã€‚

---

## 2. ææ„æ—¶æœºä¸å¯æ§

* **å‡½æ•°å†…é™æ€**ï¼šè™½ä¿è¯äº†é¦–æ¬¡ä½¿ç”¨æ—¶æ„é€ ã€ç¨‹åºç»“æŸæ—¶ææ„ï¼Œä½†ï¼š

  * **ææ„é¡ºåº**ï¼šåŒä¸€ä¸ªç¿»è¯‘å•å…ƒä¸­çš„å¤šä¸ªé™æ€å¯¹è±¡æŒ‰å®šä¹‰é¡ºåºé”€æ¯ï¼Œä¸åŒç¿»è¯‘å•å…ƒé—´åˆ™ç”±é“¾æ¥å™¨æˆ–è¿è¡Œæ—¶ç¯å¢ƒå†³å®šï¼Œéš¾ä»¥é¢„æµ‹ã€‚
  * **èµ„æºå›æ”¶å»¶è¿Ÿ**ï¼šç›´åˆ°ä¸»å‡½æ•°è¿”å›æˆ– `std::exit()` è°ƒç”¨åæ‰å¼€å§‹ææ„ï¼Œè¿™å¯¹éœ€è¦åœ¨é€€å‡ºå‰åšç²¾ç»†æ¸…ç†ï¼ˆä¾‹å¦‚ç½‘ç»œè¿æ¥ã€æ–‡ä»¶å¥æŸ„æå‰é‡Šæ”¾ï¼‰çš„åœºæ™¯å¾ˆä¸å‹å¥½ã€‚

* **åŠ¨æ€åˆ†é… + `atexit` æ³¨å†Œ**ï¼š

  ```cpp
  class Logger {
  public:
    static Logger& instance() {
      static Logger* inst = []{
        Logger* p = new Logger;
        std::atexit([]{ delete p; });
        return p;
      }();
      return *inst;
    }
  private:
    Logger() { /* ... */ }
  };
  ```

  * é€šè¿‡ `new` + `atexit` å¯ä»¥å»¶è¿Ÿææ„ï¼Œä½†è¿™ä¼šè®©ææ„é¡ºåºæ›´æ¨¡ç³Šï¼Œä¸”å¦‚æœç¨‹åºå¼‚å¸¸ç»ˆæ­¢ï¼ˆå¦‚è°ƒç”¨ `std::abort()` æˆ–å‘ç”Ÿè‡´å‘½ä¿¡å·ï¼‰ï¼Œ`atexit` å›è°ƒä¸ä¼šæ‰§è¡Œï¼Œå¯¼è‡´èµ„æºæ³„æ¼ã€‚

---

## 3. æ— æ³•ä¼ é€’æ„é€ å‚æ•°

å•ä¾‹æ„é€ é€šå¸¸ä¸æ¥å—å¤–éƒ¨å‚æ•°ï¼ˆå¦åˆ™æ— æ³•ä¿è¯â€œå…¨å±€å”¯ä¸€â€ï¼‰ï¼Œå¯¼è‡´ï¼š

* **é…ç½®ç¡¬ç¼–ç **ï¼šå¦‚æœæƒ³åœ¨å¯åŠ¨æ—¶æ ¹æ®é…ç½®æ–‡ä»¶æˆ–å‘½ä»¤è¡Œå‚æ•°åˆå§‹åŒ–å•ä¾‹ï¼Œå¿…é¡»åœ¨è°ƒç”¨ `instance()` ä¹‹å‰åšå¥½å…¨å±€é…ç½®ï¼Œæˆ–è€…é¢å¤–æä¾› `init()` æ¥å£â€”â€”å¢åŠ äº†ä½¿ç”¨çº¦å®šçš„å¤æ‚åº¦ã€‚

* **æµ‹è¯•éš”ç¦»å›°éš¾**ï¼šæµ‹è¯•æ—¶è‹¥éœ€ä¸ºå•ä¾‹æä¾›ä¸åŒçš„åˆå§‹åŒ–å‚æ•°ï¼Œå°±åªèƒ½åœ¨æµ‹è¯•å¯åŠ¨æ—¶æ‰‹åŠ¨è°ƒç”¨æŸä¸ª `init()`ï¼Œå¹¶ä¿è¯åœ¨æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹è¿è¡Œå‰å®Œæˆï¼Œææ˜“æ¼è°ƒæˆ–é¡ºåºé”™ä¹±ã€‚

---

## 4. ç”Ÿå‘½å‘¨æœŸä¸ä¾èµ–è§£è€¦éš¾

åœ¨å¤§å‹ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªå•ä¾‹å¸¸å¸¸ä¸ä»…è‡ªèº«ä¾èµ–äºåº•å±‚æœåŠ¡ï¼ˆæ•°æ®åº“ã€ç½‘ç»œã€æ–‡ä»¶ç³»ç»Ÿç­‰ï¼‰ï¼Œä¹Ÿè¢«è®¸å¤šæ¨¡å—æ‰€ä¾èµ–ï¼š

* **å¯åŠ¨é¡ºåº**ï¼šå¿…é¡»ä¿è¯åº•å±‚æœåŠ¡å…ˆäºå•ä¾‹åˆå§‹åŒ–ï¼ˆå¦åˆ™å•ä¾‹æ„é€ ä¸­ä½¿ç”¨çš„æœåŠ¡å°šä¸å¯ç”¨ï¼‰ã€‚
* **å…³é—­é¡ºåº**ï¼šåˆè¦ä¿è¯å•ä¾‹ææ„å‰ï¼Œæ‰€æœ‰ä¾èµ–å®ƒçš„æ¨¡å—å·²å…ˆè¡Œæ¸…ç†ã€‚ä»»ä½•é¡ºåºé”™ä¹±éƒ½ä¼šå¼•å‘â€œé‡æŒ‡é’ˆâ€æˆ–â€œå·²ææ„å¯¹è±¡â€è®¿é—®ã€‚

è¦æ­£ç¡®åœ°ç®¡ç†è¿™äº›é¡ºåºï¼Œå¾€å¾€éœ€è¦æ‰‹åŠ¨ç¼–å†™å¤§é‡æ¡†æ¶ä»£ç æˆ–å¼•å…¥ç”Ÿå‘½å‘¨æœŸç®¡ç†æ¡†æ¶ï¼Œåè€Œè®©å•ä¾‹æœ¬åº”ç®€åŒ–çš„è®¾è®¡å˜å¾—æ›´åŠ è‡ƒè‚¿ã€‚

---

## 5. å»ºè®®ä¸æ›¿ä»£

1. **æ˜¾å¼åˆå§‹åŒ–ï¼æ¸…ç†**
   å°†â€œæ„é€ â€å’Œâ€œææ„â€æµç¨‹äº¤ç»™è°ƒç”¨è€…ç®¡ç†ã€‚ä¾‹å¦‚ï¼š

   ```cpp
   class Config {
   public:
     static std::unique_ptr<Config> create(const Settings& s) {
       return std::make_unique<Config>(s);
     }
     // ...
   private:
     Config(const Settings&);
   };
   // main()
   auto cfg = Config::create(loadSettings());
   // æ˜¾å¼ä¼ é€’ cfg ç»™å„æ¨¡å—
   ```

2. **ä¾èµ–æ³¨å…¥å®¹å™¨**
   ä½¿ç”¨ DI å®¹å™¨ç»Ÿä¸€ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼Œå®¹å™¨è´Ÿè´£æ„é€ é¡ºåºã€ææ„é¡ºåºä»¥åŠä¾èµ–å…³ç³»ï¼Œå¯æ›´ç»†ç²’åº¦åœ°æ§åˆ¶åˆå§‹åŒ–ï¼é”€æ¯é˜¶æ®µã€‚

3. **ç”Ÿå‘½å‘¨æœŸç®¡ç†æ¡†æ¶**
   å¦‚ Googleâ€™s Fruitã€Boost.DI ç­‰ï¼Œå®ƒä»¬èƒ½è®©ä½ å£°æ˜ä¾èµ–å›¾ï¼Œè‡ªåŠ¨æ’åºæ„é€ å’Œææ„ã€‚

---

### å°ç»“

å•ä¾‹æ¨¡å¼è¡¨é¢ç®€æ´ï¼Œä½†å…¶â€œéšè—â€çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†â€”â€”é™æ€åˆå§‹åŒ–é¡ºåºã€ææ„æ—¶æœºã€å‚æ•°ä¼ é€’ã€ä¾èµ–é¡ºåºâ€”â€”éƒ½ææ˜“é€ æˆéš¾ä»¥å¯Ÿè§‰çš„è¿è¡Œæ—¶é”™è¯¯å’Œèµ„æºç®¡ç†é—®é¢˜ã€‚åœ¨éœ€è¦ç²¾ç¡®æ§åˆ¶å¯åŠ¨ï¼æ¸…ç†æµç¨‹çš„ç³»ç»Ÿè®¾è®¡ä¸­ï¼Œ**æ˜¾å¼ç®¡ç†å¯¹è±¡ç”Ÿå‘½å‘¨æœŸã€ä½¿ç”¨ä¾èµ–æ³¨å…¥ç­‰æ›¿ä»£æ–¹æ¡ˆå¾€å¾€æ›´å®‰å…¨ã€æ›´å¯ç»´æŠ¤**ã€‚

åœ¨æƒè¡¡äº†â€œéšè—ç”Ÿå‘½å‘¨æœŸâ€ã€â€œåˆå§‹åŒ–é¡ºåºâ€ã€â€œæµ‹è¯•éš”ç¦»â€ç­‰æ»¥ç”¨å•ä¾‹å¸¸è§é—®é¢˜åï¼Œæˆ‘ä»¬å¯ä»¥éµå¾ªä»¥ä¸‹åŸåˆ™ï¼Œæ¥è®¾è®¡ä¸€ä¸ªæ—¢èƒ½ä¿è¯å…¨å±€å”¯ä¸€ï¼Œåˆä¾¿äºæµ‹è¯•å’Œç®¡ç†çš„ C++ å•ä¾‹ã€‚

---

## 1. â€œæ˜¾å¼åˆå§‹åŒ– + æ™ºèƒ½æŒ‡é’ˆâ€æ¨¡å¼

### è®¾è®¡æ€è·¯

* **ä¸åœ¨ `instance()` é‡Œæ„é€ **ï¼Œè€Œæ˜¯ç”±å¤–éƒ¨åœ¨å¯åŠ¨é˜¶æ®µæ˜¾å¼åˆ›å»ºå®ä¾‹ï¼Œå­˜å‚¨åˆ° `std::unique_ptr`ï¼ˆæˆ–å…¶ä»–æ™ºèƒ½æŒ‡é’ˆï¼‰ã€‚
* `instance()` ä»…è¿”å›å·²æœ‰æŒ‡é’ˆå¼•ç”¨ï¼Œä¸è´Ÿè´£æ„é€ æˆ–ææ„ã€‚
* è¿™æ ·ï¼Œå¯ä»¥çµæ´»ä¼ å‚ã€æ‰‹å·¥æ§åˆ¶ææ„æ—¶æœºï¼Œå¹¶ä¸”åœ¨æµ‹è¯•ä¸­è½»æ¾æ›¿æ¢ã€‚

### ç¤ºä¾‹ä»£ç 

```cpp
// Config.h
class Config {
public:
  // ç¦ç”¨é»˜è®¤æ„é€ ã€æ‹·è´ã€èµ‹å€¼
  Config(const Config&) = delete;
  Config& operator=(const Config&) = delete;

  // å·¥å‚å‡½æ•°ï¼šå¤–éƒ¨å¿…é¡»è°ƒç”¨å®ƒæ¥åˆå§‹åŒ–å•ä¾‹
  static void init(const std::string& filepath) {
    if (!instance_) {
      instance_.reset(new Config(filepath));
    }
  }

  // è·å¾—å¼•ç”¨ï¼ˆä¸è´Ÿè´£æ„é€ ï¼‰
  static Config& instance() {
    if (!instance_) {
      throw std::logic_error("Config::init() must be called before instance()");
    }
    return *instance_;
  }

  // å¯é€‰ï¼šæ‰‹å·¥æ¸…ç†
  static void shutdown() {
    instance_.reset();
  }

  // é…ç½®è¯»å–æ¥å£
  std::string get(const std::string& key) const { /* ... */ }

private:
  explicit Config(const std::string& filepath) {
    // åœ¨è¿™é‡Œè¯»å–å¹¶è§£æé…ç½®æ–‡ä»¶
  }
  ~Config() = default;

  static std::unique_ptr<Config> instance_;
};

// Config.cpp
std::unique_ptr<Config> Config::instance_ = nullptr;
```

#### ä½¿ç”¨æ–¹å¼

```cpp
int main(int argc, char** argv) {
  // 1. ç¨‹åºå¯åŠ¨æ—¶ï¼Œæ˜¾å¼åˆå§‹åŒ–
  Config::init("/etc/myapp/config.json");

  // 2. å„å¤„é€šè¿‡ Config::instance() è®¿é—®
  auto timeout = Config::instance().get("timeout_ms");

  // 3. éœ€è¦æ—¶æ‰‹åŠ¨æ¸…ç†
  Config::shutdown();
  return 0;
}
```

**ä¼˜ç‚¹**

* æ„é€ å‚æ•°å¯ä¼ é€’ï¼Œåˆå§‹åŒ–æ—¶æœºå¯æ§ã€‚
* ææ„æ—¶æœºåœ¨ `shutdown()`ï¼Œé¿å…â€œé™æ€ææ„é¡ºåºâ€é—®é¢˜ã€‚
* æµ‹è¯•ä¸­å¯è½»æ¾æ›¿æ¢ï¼šåªè¦åœ¨æµ‹è¯•å¥—ä»¶çš„ `SetUp()` ä¸­è°ƒç”¨ `init()`ï¼Œåœ¨ `TearDown()` ä¸­è°ƒç”¨ `shutdown()`ï¼Œå°±èƒ½ç¡®ä¿çŠ¶æ€éš”ç¦»ã€‚

---

## 2. â€œä¾èµ–æ³¨å…¥å®¹å™¨ + å•ä¾‹æ³¨å†Œâ€æ¨¡å¼

### è®¾è®¡æ€è·¯

* å¼•å…¥ä¸€ä¸ªè½»é‡çº§çš„ DI å®¹å™¨ï¼ˆæˆ– Service Locatorï¼‰ï¼Œç”±å®¹å™¨ç®¡ç†æ‰€æœ‰â€œå•ä¾‹â€æœåŠ¡çš„ç”Ÿå‘½å‘¨æœŸä¸ä¾èµ–é¡ºåºã€‚
* å„æ¨¡å—é€šè¿‡æ¥å£ç”±å®¹å™¨æ³¨å…¥ï¼Œå®¹å™¨åœ¨ç¨‹åºå¯åŠ¨æ—¶æ„å»ºä¾èµ–å›¾ï¼Œå¹¶æŒ‰æ‹“æ‰‘æ’åºå®Œæˆåˆå§‹åŒ–ï¼Œåœ¨ç¨‹åºç»“æŸæ—¶é€†åºææ„ã€‚

### ç®€åŒ–ç¤ºä¾‹ï¼ˆä¼ªä»£ç ï¼‰

```cpp
// IService.h
struct IService {
  virtual void start() = 0;
  virtual ~IService() = default;
};

// MyService.h / MyService.cpp
class MyService : public IService {
  // ä¾èµ–å¦ä¸€ä¸ªæœåŠ¡
  MyService(OtherService& other);
  void start() override { /* ... */ }
};

// main.cpp
int main() {
  DIContainer di;

  // æ³¨å†ŒæœåŠ¡ç±»å‹ä¸æ„é€ å‡½æ•°
  di.registerType<IService, MyService>();
  di.registerType<OtherService>();

  // å¯åŠ¨å®¹å™¨ï¼Œè‡ªåŠ¨åˆå§‹åŒ–æ‰€æœ‰æœåŠ¡
  di.build();       // è§£æä¾èµ–ã€æŒ‰é¡ºåº new å‡ºæ¥
  di.startAll();    // è°ƒç”¨å„ IService::start()

  // â€¦ è¿è¡Œä¸­ â€¦

  // å®¹å™¨ææ„æ—¶è‡ªåŠ¨é€†åº deleteï¼Œå„æœåŠ¡ææ„é¡ºåºå¯æ§
  return 0;
}
```

**ä¼˜ç‚¹**

* å®Œå…¨è§£è€¦ï¼Œå„æœåŠ¡ä¾èµ–æ˜¾å¼å£°æ˜ã€‚
* å®¹å™¨æ§åˆ¶ç”Ÿå‘½å‘¨æœŸã€é¡ºåºï¼Œæ¶ˆé™¤äº†â€œé™æ€åˆå§‹åŒ–â€ã€â€œææ„é¡ºåºâ€ç¾éš¾ã€‚
* å®¹æ˜“æ›¿æ¢ mock å®ç°ï¼Œåªéœ€åœ¨æ³¨å†Œé˜¶æ®µå°†æ¥å£æŒ‡å‘æµ‹è¯•ç‰ˆç±»å‹ã€‚

---

## 3.  â€œå‡½æ•°å†…é™æ€ + å‚æ•°åŒ– initâ€å°å‹å•ä¾‹

å¯¹äºé‚£äº› **æ— å¤–éƒ¨ä¾èµ–**ã€**ä¸éœ€è¦å‚æ•°**ã€**è®¿é—®æä¸ºé¢‘ç¹**ã€ä¸”ç¡®å®éœ€å…¨å±€å”¯ä¸€çš„è½»é‡çº§å·¥å…·ç±»ï¼ˆå¦‚ Loggerï¼‰ï¼Œå¯ä»¥ä¾ç„¶ä½¿ç”¨ç»å…¸çš„â€œå‡½æ•°å†…é™æ€â€å®ç°ï¼Œä½†é…åˆä¸€ä¸ªå¯é€‰çš„ `init()` è°ƒç”¨æ¥ä¼ å‚æˆ–å¼€å…³åŠŸèƒ½ã€‚

```cpp
class Logger {
public:
  static Logger& instance() {
    static Logger inst;
    return inst;
  }

  // å¯åœ¨ main() å¼€å¤´è®¾ç½®æ—¥å¿—çº§åˆ«
  void init(LogLevel lvl, const std::string& path) {
    level_ = lvl;
    outfile_.open(path);
  }

  void log(const std::string& msg) {
    // ç®€å•æ— é”ç¤ºä¾‹ï¼Œç”Ÿäº§ç¯å¢ƒè¯·åŠ é”
    outfile_ << "[" << level_ << "] " << msg << "\n";
  }

private:
  Logger() = default;
  ~Logger() { if (outfile_) outfile_.close(); }

  LogLevel level_{LogLevel::INFO};
  std::ofstream outfile_;
};
```

ä½¿ç”¨è€…åœ¨ç¨‹åºå¯åŠ¨æ—¶ï¼š

```cpp
Logger::instance().init(LogLevel::DEBUG, "/var/log/app.log");
Logger::instance().log("Started.");
```

è¿™æ ·ï¼Œä½ ä¾ç„¶èƒ½äº«å— â€œMeyersâ€™ Singletonâ€ çš„çº¿ç¨‹å®‰å…¨åˆå§‹åŒ–ï¼ˆC++11 èµ·ä¿è¯ï¼‰ï¼ŒåŒæ—¶æœ‰ `init()` æ¥ä¼ å¤–éƒ¨é…ç½®ï¼Œææ„æ—¶æœºä»æ˜¯ç¨‹åºé€€å‡ºé˜¶æ®µä½†å›  Logger é€šå¸¸ä¸å†ä¾èµ–å…¶ä»–å•ä¾‹ï¼Œé£é™©å¯æ§ã€‚

---

### æ€»ç»“

1. **ä¼˜å…ˆæ˜¾å¼ç®¡ç†**ï¼šå°†å•ä¾‹çš„â€œæ„é€ â€â€œææ„â€äº¤ç»™è°ƒç”¨è€…ï¼Œé€šè¿‡æ™ºèƒ½æŒ‡é’ˆæˆ– DI å®¹å™¨æ§åˆ¶ç”Ÿå‘½æœŸã€‚
2. **éš”ç¦»æµ‹è¯•**ï¼šä¸ºå•ä¾‹æä¾› `init()`/`shutdown()`ï¼Œåœ¨æµ‹è¯•å‰åè¿›è¡ŒçŠ¶æ€æ¸…ç†ã€‚
3. **ç»†ç²’åº¦ä¾èµ–**ï¼šåœ¨å¤§å‹ç³»ç»Ÿä¸­æ¨èå¼•å…¥è½»é‡ DIï¼Œç»Ÿä¸€ç®¡ç†æ‰€æœ‰â€œå…¨å±€æœåŠ¡â€ï¼Œè€Œéåˆ†æ•£çš„è£¸å•ä¾‹ã€‚
4. **è°¨æ…ä½¿ç”¨ç»å…¸å•ä¾‹**ï¼šåªæœ‰åœ¨ç»å¯¹æ— çŠ¶æ€æˆ–æç®€å•åœºæ™¯æ‰ç”¨å‡½æ•°å†…é™æ€ï¼Œå¦åˆ™åˆ‡æ¢åˆ°æ›´çµæ´»çš„æ–¹æ¡ˆã€‚

è¿™æ ·è®¾è®¡çš„å•ä¾‹ï¼Œæ—¢ä¿ç•™äº†â€œå…¨å±€å”¯ä¸€è®¿é—®ç‚¹â€çš„ä¾¿åˆ©ï¼Œä¹Ÿå¤§å¤§é™ä½äº†ç”Ÿå‘½å‘¨æœŸå†²çªã€å‚æ•°ç¡¬ç¼–ç å’Œæµ‹è¯•éš¾åº¦ã€‚
