æ˜¯çš„ï¼Œâœ… **ä¸Šè¿°é‡æ„å®ç°å¯ä»¥å…¼å®¹ C++14**ï¼Œåªéœ€è¦åš **å°‘é‡è°ƒæ•´**ï¼Œå› ä¸ºå½“å‰ä»£ç ä¸»è¦ç”¨åˆ°äº†å¦‚ä¸‹ç‰¹æ€§ï¼š

| ç‰¹æ€§                                 | æ˜¯å¦æ”¯æŒ C++14     | æ›¿ä»£æ–¹æ¡ˆæˆ–è¯´æ˜                        |
| ---------------------------------- | -------------- | ------------------------------ |
| `std::function`, `lambda`          | âœ… æ”¯æŒ           | æ— éœ€ä¿®æ”¹                           |
| å‡½æ•°æ¨¡æ¿ã€å®Œç¾è½¬å‘                          | âœ… æ”¯æŒ           | æ— éœ€ä¿®æ”¹                           |
| æŠ˜å è¡¨è¾¾å¼ `(std::cout << ... << args)` | âŒ ä¸æ”¯æŒ C++14    | âœ… éœ€è¦ä¿®æ”¹ä¸ºé€’å½’æ–¹å¼æˆ– initializer\_list |
| `##__VA_ARGS__`                    | âœ… GCC/Clang æ‰©å±• | MSVC ä¹Ÿæ”¯æŒï¼Œå®å®šä¹‰å¯ä¿ç•™                |
| NVI æ¨¡å¼ + æ¨¡æ¿ç»„åˆ                      | âœ… æ”¯æŒ           | è™½ç„¶æ¨¡æ¿ä¸èƒ½è™šæ‹Ÿï¼Œä½†ç»„åˆä½¿ç”¨æ˜¯åˆæ³•              |

---

## âŒ ä¸å…¼å®¹ç‚¹ï¼šæŠ˜å è¡¨è¾¾å¼

è¿™ä¸€è¡Œä»£ç ä½¿ç”¨äº† C++17 çš„æŠ˜å è¡¨è¾¾å¼ï¼š

```cpp
(std::cout << ... << args) << std::endl;
```

> âŒ è¿™æ˜¯ C++17 å¼•å…¥çš„æ–°è¯­æ³•ã€‚C++14 ä¸æ”¯æŒã€‚

---

## âœ… æ›¿ä»£æ–¹æ¡ˆï¼ˆå…¼å®¹ C++14ï¼‰

æˆ‘ä»¬ç”¨ `std::initializer_list` å’Œé€—å·è¡¨è¾¾å¼æ¨¡æ‹Ÿè¾“å‡ºå¤šä¸ªå‚æ•°ï¼š

```cpp
template<typename... Args>
int ReportError(bool /*mode*/, int code, Args&&... args) {
    std::cout << "[ReportError] code: " << code << ", args: ";
    using expander = int[];
    (void)expander{0, ((std::cout << args << " "), 0)...};
    std::cout << std::endl;
    return 0;
}
```

è§£é‡Šï¼š

* `expander` æ˜¯ä¸€ç§å¸¸è§æŠ€å·§ï¼Œç”¨æ¥**åœ¨ C++14 ä¸­å±•å¼€å‚æ•°åŒ…**ã€‚
* `(std::cout << args << " ", 0)` æ˜¯é€—å·è¡¨è¾¾å¼ï¼Œè¿”å› `0`ï¼Œç”¨äºå¡«å……æ•°ç»„ã€‚
* æ•´ä½“ä¿è¯å‚æ•°å±•å¼€é¡ºåºæ‰§è¡Œï¼Œä¸”æ— å‰¯ä½œç”¨ã€‚

---

## âœ… ç»“è®ºï¼šå…¼å®¹ C++14 åçš„å…³é”®ä¿®æ”¹

å”¯ä¸€éœ€è¦æ”¹åŠ¨çš„éƒ¨åˆ†å¦‚ä¸‹ï¼š

### ä¿®æ”¹å‰ï¼ˆC++17ï¼‰ï¼š

```cpp
(std::cout << ... << args) << std::endl;
```

### ä¿®æ”¹åï¼ˆC++14ï¼‰ï¼š

```cpp
using expander = int[];
(void)expander{0, ((std::cout << args << " "), 0)...};
std::cout << std::endl;
```

---

## ğŸ“Œ æœ€ç»ˆç»“è®º

âœ… **å¯ä»¥å…¼å®¹ C++14**ã€‚
åªéœ€æ›¿æ¢ **æŠ˜å è¡¨è¾¾å¼**ï¼Œå…¶ä»–å¦‚ï¼š

* æ¨¡æ¿ + lambda
* `std::function`
* å®Œç¾è½¬å‘
* éè™šæ¨¡æ¿ç»„åˆ
* `##__VA_ARGS__` å®æ‹¼æ¥

éƒ½æ˜¯ **C++14 å®Œæ•´æ”¯æŒçš„ç‰¹æ€§**ã€‚

---

å¦‚ä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ä¸ºä½ è¾“å‡º **C++14 å®Œæ•´å…¼å®¹ç‰ˆä»£ç **ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ


éå¸¸æ£’çš„é—®é¢˜ï¼æˆ‘ä»¬ç°åœ¨è®¨è®ºçš„æ˜¯ï¼š

---

# ğŸ¯ ç›®æ ‡ï¼š**å¯¹å¯å˜å‚æ•°æ¨¡æ¿å‡½æ•°è¿›è¡Œ GMock**

---

## âœ… èƒŒæ™¯æ¡ä»¶

ä½ å½“å‰çš„ç»“æ„ä¸­ï¼š

```cpp
template<typename... Args>
int Report(int code, Args&&... args) {
    return logger_->ReportWithArgs(code, [&]() {
        return logger_->HandleReport(code, std::forward<Args>(args)...);
    });
}
```

* `Report(...)` æ˜¯ä¸€ä¸ªæ¨¡æ¿å‡½æ•°
* æœ€ç»ˆè°ƒç”¨çš„æ˜¯ `ILogger::ReportWithArgs(...)`ï¼ˆéæ¨¡æ¿ã€è™šå‡½æ•°ï¼‰

---

## ğŸš« é—®é¢˜ï¼š**GMock ä¸èƒ½ mock æ¨¡æ¿å‡½æ•°**

**GMock é™åˆ¶ï¼šæ¨¡æ¿å‡½æ•°ä¸èƒ½ç›´æ¥ MOCK\_METHODã€‚**

ä¾‹å¦‚ï¼Œä¸èƒ½è¿™æ ·å†™ï¼š

```cpp
MOCK_METHOD(int, Report, (int code, auto&&... args), (override)); // âŒ ä¸åˆæ³•
```

---

## âœ… æ­£ç¡®åšæ³•ï¼š**ç»•å¼€æ¨¡æ¿å‡½æ•°æœ¬èº«ï¼ŒMock å…¶è½¬å‘çš„éæ¨¡æ¿è™šå‡½æ•°**

### ä½ åŸæ¥çš„åšæ³•å…¶å®æ˜¯**æ­£ç¡®çš„è®¾è®¡æ¨¡å¼**ï¼š

```cpp
return logger_->ReportWithArgs(code, [&]() {
    return logger_->HandleReport(code, std::forward<Args>(args)...);
});
```

ä½ åœ¨æ¨¡æ¿å‡½æ•°ä¸­å°†è°ƒç”¨å°è£…æˆï¼š

```cpp
std::function<int()> invoker
```

ç„¶åä¼ ç»™è™šå‡½æ•°ï¼š

```cpp
virtual int ReportWithArgs(int code, const std::function<int()>& invoker);
```

### âœ… åœ¨ GMock ä¸­ mock çš„å°±æ˜¯è¿™ä¸ªæ¥å£ï¼š

```cpp
MOCK_METHOD(int, ReportWithArgs, (int code, const std::function<int()>&), (override));
```

### ğŸ‘‰ æ‰€ä»¥**ä½ ä¸éœ€è¦ mock æ¨¡æ¿å‡½æ•°**ï¼Œåªéœ€è¦ï¼š

1. ä¿è¯æ‰€æœ‰å¯å˜å‚æ•°æ¨¡æ¿è°ƒç”¨éƒ½é€šè¿‡ `ReportWithArgs(...)` è½¬å‘
2. åœ¨ mock ä¸­éªŒè¯å®ƒæ˜¯å¦è¢«è°ƒç”¨ï¼Œå¹¶å¯é€‰æ‹©æ‰§è¡Œ `invoker()`

---

## âœ… ç¤ºä¾‹ï¼šMock å¯å˜å‚æ•°è°ƒç”¨

```cpp
#include <gmock/gmock.h>
#include <gtest/gtest.h>

class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int code), (override));
    MOCK_METHOD(int, ReportWithArgs, (int code, const std::function<int()>&), (override));
};

TEST(LoggerTest, VariadicArgsShouldInvokeInvoker) {
    MockLogger mock;
    LoggerAdapter adapter(&mock);

    using ::testing::_;
    using ::testing::Invoke;

    EXPECT_CALL(mock, ReportWithArgs(1002, _))
        .WillOnce(Invoke([](int, const std::function<int()>& invoker) {
            std::cout << "[GMock] Intercept ReportWithArgs" << std::endl;
            return invoker();  // âœ… æ‰§è¡Œå˜å‚é€»è¾‘
        }));

    adapter.Report(1002, "hello", 42);  // âœ… å¯å˜å‚æ•°è°ƒç”¨æ¨¡æ¿å‡½æ•°
}
```

---

## ğŸ“Œ æ€»ç»“ï¼šå¯¹æ¨¡æ¿å‡½æ•°è¿›è¡Œ GMock çš„æ­£ç¡®åšæ³•

| é—®é¢˜              | è§£æ³•è¯´æ˜                                          |
| --------------- | --------------------------------------------- |
| ä¸èƒ½ mock æ¨¡æ¿å‡½æ•°    | âœ… è®¾è®¡æ¥å£ï¼Œå°†é€»è¾‘å°è£…åˆ°éæ¨¡æ¿è™šå‡½æ•°                           |
| å¦‚ä½•è§¦å‘ invoker æ‰§è¡Œ | âœ… åœ¨ mock ä¸­è°ƒç”¨ `invoker()`                      |
| å¦‚ä½•éªŒè¯å‚æ•°ï¼Ÿ         | âœ… mock æ—¶åŒ¹é… codeï¼›å¦‚éœ€æ·±åº¦å‚æ•°æ£€æŸ¥ï¼Œå¯åœ¨ `invoker` ä¸­åŠ æ–­è¨€    |
| ä¿æŒæµ‹è¯•çµæ´»æ€§å’Œæ‰©å±•æ€§     | âœ… ç»§ç»­ä½¿ç”¨ `ReportWithArgs(code, invoker)` æ¨¡å¼è½¬å‘å˜å‚ |

---

å¦‚æœä½ æƒ³ mock **å…·ä½“å‚æ•°å€¼çš„å†…å®¹**ï¼ˆä¾‹å¦‚ `"hello", 42`ï¼‰ï¼Œå¯ä»¥å°† `invoker` å°è£…çš„å‡½æ•°æ›¿æ¢ä¸º mockable å‡½æ•°å¯¹è±¡ï¼Œæˆ–è€…åœ¨å†…éƒ¨è®¾ç½®æ ‡å¿—/å˜é‡ã€‚

æ˜¯å¦éœ€è¦æˆ‘ä¸ºä½ æ¼”ç¤ºä¸€ä¸ªå¸¦å‚æ•°æ–­è¨€çš„é«˜çº§æµ‹è¯•ç¤ºä¾‹ï¼Ÿ
