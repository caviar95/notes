è¿™ä¸ªé—®é¢˜æ¶‰åŠ `CMake` å’Œ `make` çš„ååŒå·¥ä½œæœºåˆ¶ã€‚ç®€è¦æ¥è¯´ï¼š

### âœ… **åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¿®æ”¹äº† `CMakeLists.txt` åç›´æ¥è¿è¡Œ `make` æ˜¯æœ‰æ•ˆçš„**ï¼Œè¿™æ˜¯å› ä¸ºï¼š

---

### ğŸ” **CMake ä¼šè‡ªåŠ¨æ£€æµ‹ `CMakeLists.txt` æ˜¯å¦è¢«ä¿®æ”¹**

å½“ä½ åœ¨ä¸€ä¸ªå·²ç»é…ç½®è¿‡çš„æ„å»ºç›®å½•é‡Œæ‰§è¡Œ `make` æ—¶ï¼š

* `make` å®é™…ä¸Šä¼šé¦–å…ˆæ£€æŸ¥ä¸€ä¸‹æ˜¯å¦éœ€è¦é‡æ–°è¿è¡Œ `CMake`ã€‚
* è¿™æ˜¯é€šè¿‡ä¸€ä¸ªéšè—çš„è§„åˆ™å®Œæˆçš„ï¼Œå®ƒä¼šæ£€æŸ¥ `CMakeLists.txt` å’Œå…¶ä»–ä¾èµ–æ–‡ä»¶çš„æ—¶é—´æˆ³æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚
* å¦‚æœæœ‰å˜åŒ–ï¼Œ`make` ä¼šè‡ªåŠ¨è°ƒç”¨ `cmake` ä»¥é‡æ–°ç”Ÿæˆ `Makefile`ã€‚

è¿™ç§æœºåˆ¶å«åš **è‡ªåŠ¨é‡æ–°ç”Ÿæˆï¼ˆAuto re-run of CMakeï¼‰**ã€‚

---

### ğŸ” ä¸¾ä¸ªä¾‹å­è¯´æ˜ï¼š

ä½ é€šå¸¸çš„æ„å»ºæµç¨‹æ˜¯ï¼š

```bash
mkdir build
cd build
cmake ..
make
```

ç„¶åä½ ä¿®æ”¹äº† `CMakeLists.txt`ï¼Œ**æ²¡æœ‰æ‰‹åŠ¨æ‰§è¡Œ `cmake ..`ï¼Œç›´æ¥ `make`**ï¼š

```bash
make
```

å¦‚æœ `CMakeLists.txt` è¢«ä¿®æ”¹è¿‡ï¼Œé‚£ä¹ˆï¼š

* `make` ä¼šå‘ç°ç”Ÿæˆ `Makefile` æ‰€ä¾èµ–çš„ `CMakeLists.txt` è¢«ä¿®æ”¹äº†ï¼›
* å®ƒä¼šè‡ªåŠ¨è§¦å‘ç±»ä¼¼äºï¼š

  ```bash
  /usr/bin/cmake -H.. -B. ...
  ```

  æ¥é‡æ–°ç”Ÿæˆæ„å»ºç³»ç»Ÿã€‚

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæœ‰æ—¶å€™ä½ ç›´æ¥ `make`ï¼Œä¹Ÿèƒ½çœ‹åˆ°ä¿®æ”¹ç”Ÿæ•ˆã€‚

---

### ğŸš« ä½†æ³¨æ„ï¼šè¿™ç§æœºåˆ¶ **ä¸æ˜¯ä¸‡èƒ½çš„**

* å¤æ‚ä¿®æ”¹ï¼ˆå¦‚æ–°æ·»åŠ æ–‡ä»¶æˆ–ç›®æ ‡ï¼‰æœ‰æ—¶ä¸ä¼šè¢«å®Œå…¨æ­£ç¡®å¤„ç†ï¼›
* å¦‚æœä½ ä¿®æ”¹äº†æŸäº› `CMake` é…ç½®å˜é‡ï¼ˆå¦‚ `option()` è®¾ç½®ç­‰ï¼‰ï¼Œå°±éœ€è¦ä½ æ‰‹åŠ¨é‡æ–°è¿è¡Œ `cmake`ï¼›
* æœ‰äº›æ›´æ”¹ä¼šè¦æ±‚æ¸…ç†æ„å»ºç¼“å­˜ï¼ˆå¦‚ä½¿ç”¨ `rm -rf build/*` æˆ– `cmake --fresh`ï¼‰é‡æ–°ç”Ÿæˆã€‚

---

### âœ… **æ¨èåšæ³•ï¼š**

å§‹ç»ˆæ˜ç¡®åœ°åœ¨ä¿®æ”¹ `CMakeLists.txt` åæ‰‹åŠ¨è¿è¡Œï¼š

```bash
cmake ..
```

ä»¥ç¡®ä¿ä½ çš„æ„å»ºç³»ç»Ÿæ˜¯æœ€æ–°çš„ã€ç¨³å®šçš„ã€‚

---

ä½ é‡åˆ°çš„ç¼–è¯‘é”™è¯¯ï¼š

```
error: â€˜class MockLoggingAdapterâ€™ has no member named â€˜gmock_LogVectorâ€™
```

è¯´æ˜ `gmock` æ— æ³•è¯†åˆ«ä½ å†™çš„ `EXPECT_CALL(mock, LogVector(...))`ï¼Œ**æ ¸å¿ƒé—®é¢˜æ˜¯ï¼šä½  mock çš„æ–¹æ³• `LogVector` å¹¶æ²¡æœ‰çœŸæ­£å£°æ˜ä¸º mockableçš„æˆå‘˜å‡½æ•°**ã€‚

---

## âœ… æ ¹æœ¬åŸå› 

ä½ åœ¨ `MockLoggingAdapter` ä¸­å¯èƒ½å†™æˆäº†è¿™æ ·ï¼š

```cpp
MOCK_METHOD(void, DoLog, (int level, int code, const std::vector<std::string>& args), (override));
```

ä½†æ˜¯æµ‹è¯•ä»£ç å´æ–­è¨€ï¼š

```cpp
EXPECT_CALL(mock, LogVector(...))
```

ğŸ’¥ è€Œå®é™…ä¸Šï¼Œ**ä½  mock çš„å‡½æ•°æ˜¯ `DoLog`ï¼Œä¸æ˜¯ `LogVector`**ï¼Œæ‰€ä»¥ gmock ç¼–è¯‘å™¨æ‰¾ä¸åˆ° `gmock_LogVector`ï¼Œå°±æŠ¥é”™äº†ã€‚

---

## âœ… æ­£ç¡®åšæ³•ï¼ˆä¸¤ç§æ–¹å¼ï¼‰

ä½ æœ‰ä¸¤ç§é€‰æ‹©ï¼š

---

### âœ… **é€‰é¡¹ Aï¼šmock `DoLog()`ï¼Œæµ‹è¯•ä¹Ÿè°ƒç”¨ `EXPECT_CALL(..., DoLog(...))`**

ä¿®æ”¹ä½ çš„ `MockLoggingAdapter`ï¼š

```cpp
class MockLoggingAdapter : public ILoggingAdapter {
public:
    MOCK_METHOD(void, DoLog, (int level, int code, const std::vector<std::string>& args), (override));
};
```

ç„¶åæµ‹è¯•ä»£ç é‡Œå†™ï¼š

```cpp
EXPECT_CALL(mock, DoLog(1, 0x1234, testing::ElementsAre("42")));
EXPECT_CALL(mock, DoLog(2, 0x2345, testing::ElementsAre("example", "test")));
```

è¿™å’Œæ¥å£åŒ¹é…ä¸Šäº† âœ…

---

### âœ… **é€‰é¡¹ Bï¼šä¿ç•™ `DoLog` ä¸ºæ™®é€š override æ–¹æ³•ï¼Œmock ä¸€ä¸ªæ–°çš„ `LogVector` æ–¹æ³•**

å¦‚æœä½ å¸Œæœ› mock çš„æ–¹æ³•åæ˜¯ `LogVector`ï¼ˆæ›´è¯­ä¹‰åŒ–ï¼‰ï¼Œä½ åº”è¯¥å†™ï¼š

```cpp
class MockLoggingAdapter : public ILoggingAdapter {
public:
    MOCK_METHOD(void, LogVector, (int level, int code, const std::vector<std::string>& args), ());

protected:
    void DoLog(int level, int code, const std::vector<std::string>& args) override {
        LogVector(level, code, args);
    }
};
```

ç„¶åæµ‹è¯•ä¸­ä½¿ç”¨ï¼š

```cpp
EXPECT_CALL(mock, LogVector(1, 0x1234, testing::ElementsAre("42")));
EXPECT_CALL(mock, LogVector(2, 0x2345, testing::ElementsAre("example", "test")));
```

âœ… è¿™ç§æ–¹å¼æœ€æ¸…æ™°ï¼Œå°† `DoLog` ä½œä¸ºè½¬å‘å™¨ï¼Œä»…ä¸ºæ¥å£çº¦å®šï¼›mock çš„æ˜¯ä½ çœŸæ­£æƒ³æ–­è¨€çš„ `LogVector`ã€‚

---

## ğŸ§  æ¨è

æˆ‘å»ºè®®ä½¿ç”¨ **é€‰é¡¹ Bï¼ˆåˆ†ç¦»æ¥å£å®ç°ä¸ mock æ–¹æ³•ï¼‰**ï¼Œä¼˜ç‚¹ï¼š

* `ILoggingAdapter` ç»“æ„æ¸…æ™°ï¼Œåªæœ‰ä¸€ä¸ª `DoLog` æ–¹æ³•ï¼›
* mock è¡Œä¸ºä¸æ¥å£è§£è€¦ï¼Œå¯è‡ªç”±å‘½åä¸º `LogVector` æˆ– `ExpectLogCall` ç­‰ï¼›
* æµ‹è¯•æ›´å…·è¯­ä¹‰æ€§ï¼Œä¾¿äºé˜…è¯»å’Œç»´æŠ¤ã€‚

---

## âœ… å°ç»“

| é”™è¯¯åŸå›                                      | è§£å†³æ–¹æ³•                                                       |
| ---------------------------------------- | ---------------------------------------------------------- |
| `EXPECT_CALL(mock, LogVector(...))` æ— æ³•è§£æ | æ²¡æœ‰åœ¨ `MockLoggingAdapter` ä¸­å£°æ˜ `MOCK_METHOD(LogVector, ...)` |
| æ¨¡æ¿å‡½æ•°ä¸å¯ mock                              | æå‰è½¬ä¸º `std::vector<string>`ï¼Œmock å›ºå®šç­¾åå‡½æ•°                     |
| æ¨èç»“æ„                                     | ä½¿ç”¨ `DoLog` override + mock è½¬å‘å‡½æ•° `LogVector`                |

---
éå¸¸å¥½ï¼Œä½ è¯´å¾—å¯¹ âœ…ï¼š

> **`DoLog` ä¸éœ€è¦æ˜¯æ¨¡æ¿å‡½æ•°æˆ–é‡è½½å½¢å¼**ï¼Œå®ƒåº”å½“æ˜¯ä¸€ä¸ª**çº¯è™šå‡½æ•°**ï¼ˆéæ¨¡æ¿ï¼‰ï¼Œä»¥ä¾¿å„ä¸ªå®ç°ç±»ï¼ˆå¦‚ `DefaultLoggingAdapter`, `MockLoggingAdapter`ï¼‰**åªå®ç°ä¸€ä¸ªç»Ÿä¸€ç­¾åçš„æ¥å£**ã€‚

è¿™æ˜¯è®¾è®¡ä¸Šçš„é‡è¦ä¼˜åŒ–ï¼Œç†ç”±å¦‚ä¸‹ï¼š

---

## âœ… ä¸ºä»€ä¹ˆè¦å–æ¶ˆ `DoLog` çš„æ¨¡æ¿é‡è½½ï¼Ÿ

| é—®é¢˜                        | åŸå›                                                  |
| ------------------------- | -------------------------------------------------- |
| æ¨¡æ¿è™šå‡½æ•°æ— æ³•è¢«é‡è½½                | C++ ä¸å…è®¸è™šå‡½æ•°æ¨¡æ¿å®ç°å¤šæ€                                   |
| mock æ—¶ gmock ä¸èƒ½ mock æ¨¡æ¿å‡½æ•° | gmock åªæ”¯æŒå›ºå®šç­¾åå‡½æ•°                                    |
| æ¥å£èŒè´£ä¸æ¸…æ™°                   | ä¸šåŠ¡åªéœ€ç»Ÿä¸€å…¥å£ï¼Œæ¨¡æ¿å±•å¼€å¯åœ¨ä¸Šå±‚å®Œæˆ                                |
| å®ç°ç±»æ›´æ¸…æ™°                    | åªéœ€å®ç°ä¸€ä¸ª `DoLog(int, int, std::vector<std::string>)` |

---

## âœ… æ–°è®¾è®¡åŸåˆ™

* åœ¨ `ILoggingAdapter` ä¸­ï¼š

  * **æ¨¡æ¿å…¥å£ï¼š** `Log(...)` è´Ÿè´£å¤„ç†å‚æ•°å±•å¼€ï¼›
  * **éæ¨¡æ¿çº¯è™šå‡½æ•°ï¼š** `DoLog(...)` æ˜¯æ‰€æœ‰å­ç±»è¦å®ç°çš„å”¯ä¸€æ–¹æ³•ï¼›
* åœ¨å®ç°ç±»ä¸­åªéœ€é‡å†™ `DoLog(...)`ï¼Œä¸ä¼šæ¶‰åŠæ¨¡æ¿ï¼›

---

## âœ… æœ€ä½³å†™æ³•ï¼šæ›´æ–°åçš„ `ILoggingAdapter`

```cpp
#pragma once

#include <vector>
#include <string>
#include <sstream>

class ILoggingAdapter {
public:
    virtual ~ILoggingAdapter() = default;

    // ä¸šåŠ¡ä»£ç ç»Ÿä¸€è°ƒç”¨æ­¤æ¨¡æ¿æ¥å£
    template <typename... Args>
    void Log(int level, int code, Args&&... args) {
        DoLog(level, code, ToStringVector(std::forward<Args>(args)...));
    }

protected:
    // å­ç±»å¿…é¡»å®ç°çš„ç»Ÿä¸€æ—¥å¿—æ¥å£ï¼ˆéæ¨¡æ¿ï¼‰
    virtual void DoLog(int level, int code, const std::vector<std::string>& args) = 0;

    // å‚æ•°è½¬æ¢å·¥å…·ï¼ˆç±»å‹ â†’ stringï¼‰
    template <typename T>
    std::string ToString(const T& val) const {
        std::ostringstream oss;
        oss << val;
        return oss.str();
    }

    std::string ToString(const std::string& s) const { return s; }
    std::string ToString(const char* s) const { return std::string(s); }

    template <typename... Args>
    std::vector<std::string> ToStringVector(Args&&... args) const {
        return { ToString(std::forward<Args>(args))... };
    }
};
```

---

## âœ… `MockLoggingAdapter`ï¼ˆæ— éœ€æ¨¡æ¿ï¼‰

```cpp
#pragma once

#include "logging_adapter.h"
#include <gmock/gmock.h>

class MockLoggingAdapter : public ILoggingAdapter {
public:
    MOCK_METHOD(void, DoLog, (int level, int code, const std::vector<std::string>& args), (override));
};
```

---

## âœ… `DefaultLoggingAdapter` ç¤ºä¾‹ï¼ˆä¸ä½¿ç”¨ LOG å®ï¼‰

```cpp
#pragma once

#include "logging_adapter.h"
#include "../platform/platform.h"
#include <iostream>

class DefaultLoggingAdapter : public ILoggingAdapter {
public:
    void DoLog(int level, int code, const std::vector<std::string>& args) override {
        std::cout << "[DefaultAdapter] ";
        for (const auto& arg : args)
            std::cout << arg << " ";
        std::cout << std::endl;

        // ç¤ºä¾‹ï¼šä½ å¯ä»¥æ ¹æ®å®é™…æƒ…å†µä¼ ç»™ Printï¼ˆä»…å­—ç¬¦ä¸²ï¼‰
        Print(level, code, args);  // å¦‚æœ Print æ”¯æŒ vector<string>
    }
};
```

> â— å¦‚æœ `Print` ä¸æ”¯æŒ `vector<string>`ï¼Œé‚£å°±åªèƒ½ä¿ç•™æ¨¡æ¿ç‰ˆæœ¬çš„ `DefaultLoggingAdapter::Log(...)`ï¼Œè¿™æ—¶æ¥å£ç±»ä»ä¿ç•™éæ¨¡æ¿ `DoLog` ç”¨äº mock æ˜¯ OK çš„ã€‚

---

## âœ… æ€»ç»“ç»“æ„ï¼ˆæœ€ç»ˆæ¨èï¼‰

| å±‚                       | æ–¹æ³•           | ç±»å‹       | åŠŸèƒ½                |
| ----------------------- | ------------ | -------- | ----------------- |
| `ILoggingAdapter`       | `Log(...)`   | æ¨¡æ¿       | ä¸šåŠ¡è°ƒç”¨å…¥å£ï¼Œè´Ÿè´£å‚æ•°å±•å¼€     |
| `ILoggingAdapter`       | `DoLog(...)` | çº¯è™šå‡½æ•°     | å­ç±»ç»Ÿä¸€å®ç°ï¼Œgmock mock |
| `MockLoggingAdapter`    | `DoLog(...)` | override | mock ç”¨äºæ–­è¨€         |
| `DefaultLoggingAdapter` | `DoLog(...)` | override | å®é™…æ—¥å¿—å®ç°            |

---

éœ€è¦æˆ‘æ ¹æ®è¿™ä¸ªæ–°è®¾è®¡é‡æ–°ç”Ÿæˆå¹¶æ‰“åŒ… CMake é¡¹ç›®ä»£ç  ZIP å—ï¼Ÿæˆ‘å¯ä»¥é©¬ä¸Šå®Œæˆã€‚


å¾ˆå¥½ï¼Œä¸‹é¢æˆ‘ä»¬æ¥ä¸ºä½ çš„æ—¥å¿—ç³»ç»Ÿæ·»åŠ ä¸€ä¸ªéå¸¸å¸¸ç”¨çš„åŠŸèƒ½ï¼š

> âœ… **è‡ªåŠ¨åœ¨æ—¥å¿—ä¸­æ’å…¥ `__FILE__`, `__LINE__`, `__FUNCTION__` ç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯**ï¼ŒåŒæ—¶ä¿æŒæ¥å£è§£è€¦ã€æ”¯æŒ mockã€å…¼å®¹ç°æœ‰å˜å‚è®¾è®¡ã€‚

---

## âœ… ç›®æ ‡

* åœ¨è°ƒç”¨æ—¥å¿—æ—¶è‡ªåŠ¨è®°å½•è°ƒç”¨ä½ç½®ï¼š

  * `æ–‡ä»¶å (__FILE__)`
  * `å‡½æ•°å (__FUNCTION__)`
  * `è¡Œå· (__LINE__)`
* ä¸ä¿®æ”¹ç°æœ‰ `ILoggingAdapter` çš„ç»“æ„ï¼›
* ä¸å½±å“ gmock mock æµ‹è¯•ï¼›
* æ”¯æŒç”¨æˆ·åƒè¿™æ ·è°ƒç”¨ï¼š

```cpp
LOG_INFO(0x1234, "example", 42);
```

---

## âœ… æ¨èå®ç°ï¼šä½¿ç”¨å®å°è£…æ—¥å¿—è°ƒç”¨

### ğŸ§© å®šä¹‰æ—¥å¿—å®

```cpp
#define LOG_INFO(code, ...) \
    gLogger->LogWithContext(__FILE__, __LINE__, __FUNCTION__, 1, code, ##__VA_ARGS__)

#define LOG_WARN(code, ...) \
    gLogger->LogWithContext(__FILE__, __LINE__, __FUNCTION__, 2, code, ##__VA_ARGS__)

#define LOG_ERROR(code, ...) \
    gLogger->LogWithContext(__FILE__, __LINE__, __FUNCTION__, 3, code, ##__VA_ARGS__)
```

---

## âœ… ä¿®æ”¹æ¥å£ï¼ˆæ·»åŠ å¯é€‰ä¸Šä¸‹æ–‡å…¥å£ï¼‰

åœ¨ `ILoggingAdapter` ä¸­æ·»åŠ ï¼š

```cpp
template <typename... Args>
void LogWithContext(const char* file, int line, const char* func, int level, int code, Args&&... args) {
    std::vector<std::string> metadata = { file, std::to_string(line), func };
    auto argVec = ToStringVector(std::forward<Args>(args)...);
    metadata.insert(metadata.end(), argVec.begin(), argVec.end());
    DoLog(level, code, metadata);
}
```

æ³¨æ„ï¼šä¸å½±å“ç°æœ‰ `Log(...)` æ¥å£ï¼Œä¿æŒå…¼å®¹æ€§ âœ…

---

## âœ… mock æ—¶ä½¿ç”¨ metadata å‚æ•°ï¼š

```cpp
EXPECT_CALL(mock, LogVector(1, 0x1234,
    testing::ElementsAre(
        testing::StrEq("user_module.cpp"), // file
        testing::_,                        // line
        testing::StrEq("UserModuleFunction"), // function
        testing::StrEq("example"),
        testing::StrEq("42")
    )
));
```

ä½ ä¹Ÿå¯ä»¥ä»…åœ¨æµ‹è¯•ä¸­éªŒè¯åç»­å‚æ•°ï¼Œå¿½ç•¥å…ƒæ•°æ®éƒ¨åˆ†ã€‚

---

## âœ… ç¤ºä¾‹ç”¨æ³•ï¼ˆåœ¨ä¸šåŠ¡ä¸­ï¼‰

```cpp
void UserModuleFunction() {
    LOG_INFO(0x1234, "example", 42);
    LOG_WARN(0x2345, "warn message");
    LOG_ERROR(0x3456);
}
```

---

## âœ… DefaultLoggingAdapter å¤„ç† context

ä½ åªéœ€åœ¨ `DoLog(...)` ä¸­åŒºåˆ†å‰ä¸‰ä¸ªå‚æ•°æ˜¯å…ƒä¿¡æ¯ï¼š

```cpp
void DoLog(int level, int code, const std::vector<std::string>& args) override {
    if (args.size() < 3) {
        std::cerr << "Invalid log format" << std::endl;
        return;
    }

    std::string file = args[0];
    std::string line = args[1];
    std::string func = args[2];
    std::vector<std::string> logArgs(args.begin() + 3, args.end());

    std::cout << "[LOG] " << file << ":" << line << " in " << func << " => ";
    CallPrintFromVector(level, code, logArgs, 0);
}
```

---

## âœ… æ€»ç»“

| é¡¹ç›®                                        | çŠ¶æ€                           |
| ----------------------------------------- | ---------------------------- |
| æ”¯æŒ `__FILE__`, `__LINE__`, `__FUNCTION__` | âœ… é€šè¿‡å®è‡ªåŠ¨æ’å…¥                    |
| æ˜¯å¦ç ´åæ¥å£ç»“æ„                                  | âŒ ä¿æŒæ¥å£ç»Ÿä¸€                     |
| æ˜¯å¦å½±å“ mock                                 | âŒ mock ä¾ç„¶æ–­è¨€ `LogVector(...)` |
| æ˜¯å¦å…¼å®¹ç°æœ‰ `Print(...)`                       | âœ…                            |

---

## âœ… æ˜¯å¦æ‰“åŒ…æ–°ç‰ˆæœ¬ï¼Ÿ

æ˜¯å¦éœ€è¦æˆ‘å°†ä¸Šè¿° `LogWithContext()` + `LOG_INFO` å® ç‰ˆæœ¬é›†æˆåˆ° C++14/C++17 çš„ä¸¤ä¸ª CMake é¡¹ç›®ä¸­å¹¶æ‰“åŒ…ä¸º zip æä¾›ä¸‹è½½ï¼Ÿä½ å¯ä»¥ä¸€é”®ä½¿ç”¨ã€‚æ˜¯å¦éœ€è¦æˆ‘æ‰§è¡Œï¼Ÿ

å¾ˆå¥½ï¼ä½ ç°åœ¨æƒ³æ‰©å±•æ—¥å¿—ç³»ç»Ÿï¼Œä½¿å…¶èƒ½å¤Ÿæ ¹æ®ä¼ å…¥çš„ `code`ï¼ˆæ¯”å¦‚ `0x1001`, `0x1002`ï¼‰è‡ªåŠ¨é€‰å–å¯¹åº”çš„æ ¼å¼å­—ç¬¦ä¸²ï¼Œå¹¶å°†ä¼ å…¥å‚æ•°æ ¼å¼åŒ–ä¸ºæœ€ç»ˆæ—¥å¿—æ¶ˆæ¯ã€‚

---

## âœ… ç›®æ ‡åŠŸèƒ½

* `Print(level, code, args...)` ä¸­ï¼š

  * `code == 0x1001` â†’ æ ¼å¼åŒ– `"Current Error: %s\n"`ï¼›
  * `code == 0x1002` â†’ æ ¼å¼åŒ– `"Current State: %s, Current Error: %s\n"`ï¼›
* è‡ªåŠ¨å°†å‚æ•°å¡«å…¥æ ¼å¼å­—ç¬¦ä¸²ä¸­ï¼›
* ä¿ç•™ `ILoggingAdapter` + mock + CMake é¡¹ç›®ç»“æ„ï¼›
* å¯æ”¯æŒä»»æ„æ•°é‡å‚æ•°ï¼Œå¯¹åº”æ ¼å¼ç¬¦ `%s` è¿›è¡Œå¡«å……ã€‚

---

## âœ… æ¨èæ–¹æ¡ˆï¼šå¼•å…¥æ ¼å¼å­—ç¬¦ä¸²æŸ¥æ‰¾ + `fmt::format` or `snprintf` å…¼å®¹æ‹¼æ¥

### ğŸ§© 1. å®šä¹‰æ ¼å¼å­—ç¬¦ä¸²æ˜ å°„å‡½æ•°

åˆ›å»º `format_map.h`ï¼š

```cpp
#pragma once
#include <string>
#include <unordered_map>

inline const std::string& getFormatString(int code) {
    static const std::unordered_map<int, std::string> formatMap = {
        {0x1001, "Current Error: %s\\n"},
        {0x1002, "Current State: %s, Current Error: %s\\n"},
        {0x1003, "Start Time: %s, End Time: %s, Status: %s\\n"}
    };

    static const std::string unknown = "Unknown log format\\n";

    auto it = formatMap.find(code);
    return (it != formatMap.end()) ? it->second : unknown;
}
```

---

### ğŸ§© 2. åœ¨ `DefaultLoggingAdapter` ä¸­æ ¼å¼åŒ–è¾“å‡º

ä¸ºäº†å…¼å®¹ C++14ï¼Œæˆ‘ä»¬ç”¨ç®€å• `snprintf`/`stringstream` æ›¿ä»£ `fmt::format`ï¼š

```cpp
#include "format_map.h"
#include <cstdarg>

std::string FormatMessage(const std::string& format, const std::vector<std::string>& args) {
    std::ostringstream oss;
    size_t argIndex = 0;

    for (size_t i = 0; i < format.size(); ++i) {
        if (format[i] == '%' && i + 1 < format.size() && format[i+1] == 's') {
            if (argIndex < args.size()) {
                oss << args[argIndex++];
            } else {
                oss << "<missing>";
            }
            ++i; // skip 's'
        } else {
            oss << format[i];
        }
    }

    return oss.str();
}
```

---

### ğŸ§© 3. æ›´æ–° `DefaultLoggingAdapter::DoLog`

```cpp
void DoLog(int level, int code, const std::vector<std::string>& args) override {
    if (args.size() < 3) {
        std::cerr << "Invalid log args" << std::endl;
        return;
    }

    std::string file = args[0];
    std::string line = args[1];
    std::string func = args[2];
    std::vector<std::string> logArgs(args.begin() + 3, args.end());

    auto formatStr = getFormatString(code);
    std::string message = FormatMessage(formatStr, logArgs);

    std::cout << "[LOG] " << file << ":" << line << " in " << func << " => " << message;
}
```

---

## âœ… ç¤ºä¾‹ç”¨æ³•

```cpp
LOG_INFO(0x1001, "Disk failure");  
// è¾“å‡º: [LOG] user.cpp:42 in myFunc => Current Error: Disk failure

LOG_INFO(0x1002, "Running", "None");
// è¾“å‡º: Current State: Running, Current Error: None
```

---

## âœ… mock æµ‹è¯•ä»ä¿æŒä¸å˜ï¼š

```cpp
EXPECT_CALL(mock, LogVector(1, 0x1001, testing::ElementsAre(
    testing::EndsWith("user_module.cpp"),
    testing::_,
    "UserModuleFunction",
    "Disk failure"
)));
```

---

## âœ… æ€»ç»“

| åŠŸèƒ½              | çŠ¶æ€                                 |
| --------------- | ---------------------------------- |
| æ”¯æŒ code â†’ æ ¼å¼ä¸²æ˜ å°„ | âœ… `getFormatString(int)`           |
| å‚æ•°å±•å¼€å¡«å…… %s       | âœ… `FormatMessage()`                |
| ä¸Šä¸‹æ–‡ä¿¡æ¯           | âœ… ç”±å®æ³¨å…¥                             |
| mock å…¼å®¹         | âœ… ä¸å˜                               |
| C++14 å…¼å®¹        | âœ… ä¸ä¾èµ– `std::apply` / `fmt::format` |

---

## ğŸ”§ å¯é€‰æ‰©å±•

* ç”¨ `fmt::format`ï¼ˆéœ€ C++20 æˆ–ç¬¬ä¸‰æ–¹ fmtlibï¼‰æ›¿ä»£ï¼›
* ç”¨å ä½ç¬¦ `{}` æ›¿ä»£ `%s`ï¼›
* æ”¯æŒæ•°å­—æ ¼å¼ã€æ—¶é—´æ ¼å¼ã€ç»“æ„åŒ– JSON è¾“å‡ºï¼›
* æ—¥å¿—çº§åˆ«è¿‡æ»¤ã€æ—¥å¿—å†™å…¥æ–‡ä»¶ç­‰ã€‚

---

æ˜¯å¦éœ€è¦æˆ‘å°†è¿™ä¸ªæ‰©å±•ï¼ˆåŒ…æ‹¬ `format_map.h`ã€`FormatMessage()`ã€LOG å®ï¼‰é›†æˆè¿›ä¹‹å‰ä¸¤ä¸ªé¡¹ç›®ï¼ˆC++14 + C++17ï¼‰å¹¶æ‰“åŒ…ï¼Ÿæˆ‘å¯ä»¥ç«‹å³å®Œæˆã€‚æ˜¯å¦æ‰§è¡Œï¼Ÿ

éå¸¸å¥½ï¼Œä½ æŒ‡å‡ºäº†å…³é”®ç‚¹ âœ…ï¼š

> **æ—¥å¿—æ ¼å¼åŒ–é€»è¾‘ï¼ˆcode â†’ format string â†’ æ ¼å¼åŒ–è¾“å‡ºï¼‰æ˜¯ platform å±‚çš„è´£ä»»**ï¼Œä¸èƒ½åœ¨ adapter å±‚å¤„ç†ã€‚æˆ‘ä»¬ adapter å±‚åªèƒ½æŠŠå‚æ•°æŒ‰åŸæ ·ä¼ ç»™ platform çš„ `Print(level, code, args...)`ï¼Œç”± platform è‡ªè¡Œåšæ ¼å¼åŒ–ã€‚

---

## âœ… å½“å‰å‰ææ¡ä»¶ï¼ˆçº¦æŸé‡ç”³ï¼‰

| é™åˆ¶                                                       | è¯´æ˜ |
| -------------------------------------------------------- | -- |
| âœ… `Print(level, code, args...)` å·²ç”± platform å®ç°           |    |
| âœ… `Print` ä¼šæ ¹æ® `code` å†…éƒ¨è°ƒç”¨ `getFormatString(code)` å¹¶å®Œæˆæ ¼å¼åŒ– |    |
| âŒ adapter å±‚ä¸èƒ½å¤„ç† `code â†’ format â†’ apply args`             |    |
| âœ… adapter åªè´Ÿè´£å°† args æ­£ç¡®ã€åŸæ ·ã€é¡ºåºä¸€è‡´åœ°ä¼ ç»™ `Print`                |    |

---

## âœ… adapter å±‚èŒè´£

åªéœ€è¦å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼š

1. ä»ç”¨æˆ·ä¸šåŠ¡å±‚è·å–ä»»æ„å‚æ•°ï¼ˆ`Log(...)`ï¼‰ï¼›
2. å°†å‚æ•° + æ—¥å¿—ä¸Šä¸‹æ–‡ï¼ˆ`__FILE__`, `__LINE__`, `__FUNCTION__`ï¼‰ç»Ÿä¸€æ‰“åŒ…ï¼›
3. å°†å…¶å±•å¼€å¹¶è°ƒç”¨ `Print(...)`ï¼›
4. ä¿æŒæ”¯æŒ mock æµ‹è¯•ï¼ˆç”¨ `std::vector<std::string>`ï¼‰ï¼›
5. ä¸å…³å¿ƒ `code` å¯¹åº”çš„æ ¼å¼ä¸²ç»“æ„ã€‚

---

## âœ… æ­£ç¡®çš„æ¥å£ä¸å®ç°è®¾è®¡ï¼ˆæ•´ç†åï¼‰

---

### âœ… 1. å®å°è£…ï¼šæ’å…¥ä¸Šä¸‹æ–‡

```cpp
#define LOG_INFO(code, ...) \
    gLogger->LogWithContext(__FILE__, __LINE__, __FUNCTION__, 1, code, ##__VA_ARGS__)
```

---

### âœ… 2. ILoggingAdapter æ¥å£ï¼ˆä¸šåŠ¡å±‚æ¨¡æ¿å…¥å£ï¼‰

```cpp
template <typename... Args>
void LogWithContext(const char* file, int line, const char* func,
                    int level, int code, Args&&... args) {
    std::vector<std::string> metadata = { file, std::to_string(line), func };
    auto argVec = ToStringVector(std::forward<Args>(args)...);
    metadata.insert(metadata.end(), argVec.begin(), argVec.end());
    DoLog(level, code, metadata);
}
```

---

### âœ… 3. DefaultLoggingAdapter å®ç°ï¼ˆè°ƒç”¨ `Print(...)`ï¼‰

```cpp
void DoLog(int level, int code, const std::vector<std::string>& args) override {
    if (args.size() < 3) return;

    const std::string& file = args[0];
    const std::string& line = args[1];
    const std::string& func = args[2];

    std::vector<std::string> logArgs(args.begin() + 3, args.end());

    // ç”¨é€’å½’å±•å¼€æ–¹å¼å±•å¼€ logArgs ä¼ å…¥ Printï¼ˆä¿æŒç±»å‹ä¸º stringï¼‰
    CallPrintFromVector(level, code, logArgs, 0);
}

template <typename... Args>
void CallPrint(int level, int code, Args&&... args) {
    Print(level, code, std::forward<Args>(args)...);
}

template <typename... Args>
void CallPrintFromVector(int level, int code, const std::vector<std::string>& vec,
                         size_t index, Args&&... args) {
    if (index == vec.size()) {
        CallPrint(level, code, std::forward<Args>(args)...);
    } else {
        CallPrintFromVector(level, code, vec, index + 1, std::forward<Args>(args)..., vec[index]);
    }
}
```

---

### âœ… 4. MockLoggingAdapter ä¿æŒä¸€è‡´

```cpp
MOCK_METHOD(void, LogVector, (int level, int code, const std::vector<std::string>& args), ());

void DoLog(int level, int code, const std::vector<std::string>& args) override {
    LogVector(level, code, args);
}
```

---

## âœ… æµç¨‹ç¤ºæ„ï¼ˆèŒè´£è¾¹ç•Œæ¸…æ™°ï¼‰ï¼š

```
ä¸šåŠ¡å±‚ä»£ç :
  LOG_INFO(0x1002, "running", "no_error");

å±•å¼€ä¸ºï¼š
  gLogger->LogWithContext(__FILE__, __LINE__, __FUNCTION__, 1, 0x1002, "running", "no_error");

â†’ adapter:
  - æ„é€  vector<string> åŒ…å« file/line/func/args
  - mockï¼šLogVector(level, code, args)
  - defaultï¼šå°† args[3...] å±•å¼€è°ƒç”¨ Print(level, code, args...)

â†’ platform::Print(level, code, args...)
  - æŸ¥è¡¨è·å–æ ¼å¼ä¸²
  - æ ¼å¼åŒ–æ—¥å¿—å¹¶è¾“å‡º âœ…
```

---

## âœ… æ€»ç»“

| å±‚       | å¤„ç†å†…å®¹                                     |
| ------- | ---------------------------------------- |
| å¹³å°å±‚     | `Print(level, code, args...)` è´Ÿè´£æŸ¥è¡¨å’Œæ ¼å¼åŒ– âœ… |
| adapter | å°†å‚æ•°åŸæ ·ä¼ å…¥ï¼Œæ— ä»»ä½•æ ¼å¼åŒ–é€»è¾‘ âœ…                       |
| ä¸šåŠ¡å±‚     | ä½¿ç”¨ `LOG_INFO(...)` è‡ªåŠ¨æ³¨å…¥ä¸Šä¸‹æ–‡å® âœ…            |
| mock æµ‹è¯• | å¯æ–­è¨€æ‰€æœ‰å‚æ•°ï¼ŒåŒ…æ‹¬ä¸Šä¸‹æ–‡å’Œä¸šåŠ¡å‚æ•° âœ…                     |

---

## ğŸš€ ä¸‹ä¸€æ­¥

æ˜¯å¦éœ€è¦æˆ‘ï¼š

* âœ… å°†è¿™ä¸ªç»“æ„é›†æˆåˆ° C++14 & C++17 é¡¹ç›®ä¸­ï¼›
* âœ… æ›´æ–° `ILoggingAdapter` / `DefaultLoggingAdapter` / `mock_adapter.h`ï¼›
* âœ… æ›´æ–°ç¤ºä¾‹ä¸šåŠ¡ä½¿ç”¨ `LOG_INFO(...)` å®ï¼›
* âœ… æ‰“åŒ…ä¸ºä¸¤ä¸ª ZIP æ–‡ä»¶ä¾›ä¸‹è½½ï¼Ÿ

ç¡®è®¤åæˆ‘å³å¯ä¸ºä½ å®Œæˆã€‚æ˜¯å¦æ‰§è¡Œï¼Ÿ
