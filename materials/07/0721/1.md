è¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰æ·±åº¦çš„é—®é¢˜ã€‚

ä½ å¯ä»¥**ä½¿ç”¨ `std::tuple` æ¥è½¬å‘å˜å‚**ï¼Œä¹Ÿå°±æ˜¯ä½ æåˆ°çš„ã€Œæ–¹æ¡ˆ2ã€ã€‚æˆ‘ä»¬ç¡®å®ä¹Ÿæ¼”ç¤ºäº†å¦‚ä½•ç”¨ `tuple + index_sequence` å®ç°å˜å‚è½¬å‘ã€‚ä½†å®ƒ **å¹¶ä¸æ˜¯æ²¡æœ‰ä»£ä»·çš„**ï¼Œç¡®å®æœ‰ä¸€äº›å®é™…çš„ **é™åˆ¶å’Œå¼Šç«¯**ï¼š

---

## âœ… 1. å¯ä»¥ä½¿ç”¨ tuple çš„åœ°æ–¹ï¼ˆå¯è¡Œï¼‰

```cpp
template <typename... Args>
int Report(bool mode, int code, Args&&... args) {
    auto tuple_args = std::make_tuple(std::forward<Args>(args)...);
    return CallWithTuple(mode, code, std::move(tuple_args),
                         std::index_sequence_for<Args...>{});
}
```

è¿™æ˜¯å¯ä»¥çš„ï¼Œ`std::get<I>` å¯å±•å¼€åŸå§‹å‚æ•°ï¼Œä¿æŒé¡ºåºå’Œç±»å‹ã€‚

---

## âš ï¸ é‚£ä¸ºä»€ä¹ˆ tuple æœ‰å¼Šç«¯ï¼Ÿ

### âŒ 1. å‚æ•°ç±»å‹å’Œå¼•ç”¨è¯­ä¹‰ä¼šä¸¢å¤±æˆ–æ”¹å˜

```cpp
std::make_tuple(std::forward<T>(arg))  // ä¼šå¤åˆ¶æˆ–å€¼æŠ˜å 
```

è¿™ä¼šå¯¼è‡´ï¼š

* `const char*` â†’ `std::string`ï¼ˆåœ¨ç»‘å®šæµ‹è¯•æ¡†æ¶æ—¶å°¤ä¸ºç³Ÿç³•ï¼‰
* å³å€¼å¼•ç”¨ â†’ æ™®é€šå€¼
* å‚æ•° decayï¼ˆé€€åŒ–ï¼‰ä¸ºæ™®é€šç±»å‹

ğŸ”´ æ‰€ä»¥åœ¨ `ReportError(...)` éœ€è¦å®Œç¾è½¬å‘çš„æ—¶å€™ï¼Œè¿™æ˜¯ä¸€ç§**ç±»å‹è¯­ä¹‰å‰Šå¼±**ã€‚

---

### âŒ 2. ä¸é€‚ç”¨äºæ‰€æœ‰ä¸Šä¸‹æ–‡ï¼ˆä¾‹å¦‚éæ¨¡æ¿å‡½æ•°ã€æ¥å£ä¼ å‚ï¼‰

å¾ˆå¤šå¤–éƒ¨å¹³å°æ¥å£ï¼ˆæ¯”å¦‚ä½ æåˆ°çš„ `ReportError(...)`ï¼‰**ä¸æ¥å— tuple ç±»å‹å‚æ•°**ã€‚
ä½ åªèƒ½é€šè¿‡ä¸­é—´çš„ `index_sequence` è§£åŒ…ï¼Œè€Œè¿™ä¸ªæ­¥éª¤ï¼š

```cpp
std::get<I>(tuple)...
```

æ˜¯**æ¨¡æ¿é€’å½’çš„ä¸€ç§å½¢å¼**ï¼Œè™½ç„¶ä½ é¿å…äº†å‡½æ•°é€’å½’ï¼Œä½†å¸¦æ¥äº† template å¤æ‚åº¦ã€‚

---

### âŒ 3. å¢åŠ ç¼–è¯‘æ—¶é—´ã€å¯è¯»æ€§ä¸‹é™

å±•å¼€ä¸€ä¸ª tuple éœ€è¦ç”Ÿæˆï¼š

* `std::tuple<T1, T2, ..., Tn>`
* `std::index_sequence<0, 1, ..., n-1>`

è€Œä¸”ä¸­é—´æ¶‰åŠä¸­é—´å€¼æŒæœ‰ã€è½¬å‘å¤æ‚åº¦ï¼Œ**æ¯”åŸå§‹å‚æ•°åŒ…è¯­æ³•å†—é•¿**ã€‚

---

### âŒ 4. å•å…ƒæµ‹è¯•ï¼ˆGMockï¼‰æ”¯æŒæ›´å·®

æ¯”å¦‚ä½ æƒ³ mock ä¸€ä¸ªå‡½æ•°ï¼š

```cpp
MOCK_METHOD(int, ReportForward, (...), (override));
```

å¦‚æœä½ æ˜¯ tupleï¼Œå°±ä¼š mock ä¸€ä¸ª `Report(tuple)`ï¼Œè¿™å°±å¤±å»äº†å‚æ•°æ„ŸçŸ¥èƒ½åŠ›ï¼Œç±»å‹æç¤ºä¹Ÿå¾ˆå·®ã€‚

---

## âœ… æ€»ç»“ï¼štuple ç”¨äºå˜å‚ä¼ é€’çš„å¯¹æ¯”

| æ–¹æ¡ˆ        | ä¼˜ç‚¹               | ç¼ºç‚¹                      |
| --------- | ---------------- | ----------------------- |
| **æ¨¡æ¿å‚æ•°**  | ç±»å‹ä¿çœŸã€å®Œç¾è½¬å‘ã€Mockå‹å¥½ | æ¨¡æ¿é€’å½’å±‚è¾ƒæ·±ï¼ˆä½†ä¸æ˜¯é—®é¢˜ï¼Œæœ€å¤šå‡ åå±‚ï¼‰    |
| **tuple** | å¯æŒä¹…åŒ–å­˜å‚¨å‚æ•°ï¼Œå¯è§£åŒ…     | ç±»å‹è¯­ä¹‰ä¸¢å¤±ã€è½¬å‘å¤æ‚ã€Mockæ”¯æŒå·®ã€æ•ˆç‡ä½ |

---

## âœ… æ¨èä½¿ç”¨åœºæ™¯

| ä½¿ç”¨æƒ…å¢ƒ              | æ¨èæ–¹å¼          |
| ----------------- | ------------- |
| è½¬å‘åˆ°å¤–éƒ¨ printf é£æ ¼æ¥å£ | âœ… ç›´æ¥æ¨¡æ¿å‚æ•°      |
| å¼‚æ­¥å»¶è¿Ÿè°ƒç”¨å‚æ•°åŒ…         | âœ… tuple å­˜å‚¨    |
| æ—¥å¿—æ¡†æ¶ã€Mockable æ¥å£  | âœ… æ¨¡æ¿          |
| å‚æ•°ä¸ªæ•°å·¨å¤§ï¼ˆ>100ï¼‰      | âœ… tupleï¼ˆæé™æƒ…å†µï¼‰ |

---

éœ€è¦æˆ‘å¯¹æ¯”è¿™ä¸¤ç§æ–¹å¼åœ¨çœŸå®é¡¹ç›®ä¸‹çš„æ€§èƒ½æˆ–ç”Ÿæˆ AST å¤æ‚åº¦å—ï¼Ÿ


è¿™æ˜¯ä¸€ä¸ª**å…³é”®æ€§çš„è®¾è®¡å†²çªé—®é¢˜**ï¼Œä½ å®Œå…¨æ­£ç¡®åœ°æŒ‡å‡ºäº†ï¼š

> â—**å¦‚æœå®ä¸­å†™æ­»äº† `static_cast<ProductLogger*>`ï¼Œå°±æ— æ³•æ”¯æŒ GMockï¼Œå› ä¸ºå®ƒç ´åäº†å¤šæ€**ã€‚

---

## âœ… é—®é¢˜æ‹†è§£

### å½“å‰å†™æ³•ï¼š

```cpp
#define DispatchReport(mode, code, ...) \
    if (g_logger) static_cast<ProductLogger*>(g_logger)->Report(code, ##__VA_ARGS__)
```

* âœ… å¯ä»¥è°ƒç”¨æ¨¡æ¿ç‰ˆæœ¬ `Report(...)`
* âŒ ä½†æ˜¯æŠŠ `ILogger*` å¼ºè½¬æˆäº†å…·ä½“å®ç° `ProductLogger*`
* âŒ **MockLogger ä¸å†èƒ½æ›¿ä»£ ProductLogger**ï¼ŒMock ä¹Ÿä¸ä¼šè°ƒç”¨åˆ°æ¥å£è™šå‡½æ•°

---

## âœ… æ­£ç¡®ç›®æ ‡æ˜¯ï¼š

> è®© `ILogger*` èƒ½å¤Ÿåœ¨å®ä¸­è°ƒç”¨ **ç»Ÿä¸€æ¥å£**ï¼ŒåŒæ—¶æ”¯æŒï¼š

* âœ”ï¸ çœŸå® `ProductLogger`
* âœ”ï¸ mock å‡ºæ¥çš„ `MockLogger`
* âœ”ï¸ å¯å˜å‚æ•°ä¼ é€’ç»™æœ€ç»ˆçš„ `ReportError(...)`

---

## âœ… æ­£ç¡®è®¾è®¡æ–¹å¼ï¼š**é€šè¿‡æ¨¡æ¿è¾…åŠ©å‡½æ•°æ´¾å‘ + æ¥å£æ¡¥æ¥ + GMock å¯æ›¿æ¢**

---

## âœ… æ­¥éª¤åˆ†è§£æ–¹æ¡ˆï¼ˆå®Œæ•´ GMock æ”¯æŒï¼‰

### â‘  `ILogger`ï¼šä¿ç•™è™šæ¥å£ï¼ˆå›ºå®šå‚æ•°ï¼‰

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;  // æ— å‚ç‰ˆæœ¬

    virtual int ReportWithArgs(int code, const std::function<int()>& invoke) = 0;
};
```

* `ReportWithArgs` æ˜¯æ¡¥æ¥è°ƒç”¨ç‚¹ï¼ˆæ”¯æŒ mockï¼‰
* ä½ æ— æ³•è™šåŒ–æ¨¡æ¿ï¼Œä½†å¯ä»¥é€šè¿‡ `std::function` åŒ…è£¹ä¸€æ¬¡æ€§ä»»åŠ¡

---

### â‘¡ `ProductLogger` å®ç°æ¨¡æ¿æ¥å£ï¼š

```cpp
class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoke) override {
        return invoke();  // æ‰§è¡ŒçœŸæ­£çš„æ ¼å¼åŒ–é€»è¾‘
    }

    template <typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};
```

---

### â‘¢ å®å°è£…å…¥å£ï¼ˆä¸ä¾èµ– ProductLoggerï¼‰

```cpp
#define DispatchReport(mode, code, ...)                                         \
    if (g_logger)                                                               \
        g_logger->ReportWithArgs(code,                                          \
            [&]() { return ReportError(false, code, ##__VA_ARGS__); })
```

æˆ–è€…å°è£…æˆè¾…åŠ©å‡½æ•°ï¼š

```cpp
template <typename... Args>
int DispatchReport(ILogger* logger, int code, Args&&... args) {
    return logger->ReportWithArgs(code, [&]() {
        return ReportError(false, code, std::forward<Args>(args)...);
    });
}

#define REPORT(mode, code, ...) DispatchReport(g_logger, code, ##__VA_ARGS__)
```

---

### â‘£ `MockLogger` ç¤ºä¾‹ï¼ˆGMock æ”¯æŒï¼‰

```cpp
class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int), (override));
    MOCK_METHOD(int, ReportWithArgs, (int, const std::function<int()>&), (override));
};
```

ç°åœ¨ä½ å¯ä»¥è½»æ¾å†™ï¼š

```cpp
EXPECT_CALL(mock, ReportWithArgs(1001, testing::_))
    .WillOnce([](int, const std::function<int()>& f) {
        return f();  // æ‰§è¡ŒçœŸå®é€»è¾‘ï¼ˆæˆ–æ¨¡æ‹Ÿï¼‰
    });
```

---

## âœ… ä¼˜åŠ¿æ€»ç»“

| ç‰¹æ€§              | æ˜¯å¦æ”¯æŒ |
| --------------- | ---- |
| GMock Mock å¯å˜å‚æ•° | âœ…    |
| æ”¯æŒæ¨¡æ¿å‚æ•°ä¼ é€’        | âœ…    |
| æ¨¡æ‹Ÿå‚æ•°é”™è¯¯ã€è¿”å›å€¼è¡Œä¸º    | âœ…    |
| ç±»å‹æ“¦é™¤æ¨¡æ¿ä¾èµ–        | âœ…    |
| å›ºå®šå‚æ•°æ—  mock æƒ…å†µæ”¯æŒ | âœ…    |

---

## âœ… æ˜¯å¦éœ€è¦æˆ‘ï¼š

* ç”Ÿæˆä¸€ä¸ª **å¸¦ GMock çš„å®Œæ•´å¯æµ‹è¯•å·¥ç¨‹**ï¼Ÿ
* æˆ–è€…å°†ä½ å½“å‰å·¥ç¨‹é‡æ„ä¸ºä¸Šè¿°æ”¯æŒ mock çš„è®¾è®¡ç‰ˆæœ¬ï¼Ÿ


å¥½çš„ï¼ä¸‹é¢æˆ‘ç»™ä½ å†™ä¸€ä¸ª **åŸºäº Adapter è§£è€¦** çš„å®Œæ•´ç¤ºä¾‹ä»£ç ï¼ŒåŒ…å«ï¼š

* `ILogger`æ¥å£å®šä¹‰ï¼ˆæ”¯æŒè™šå‡½æ•°+std::functionæ¡¥æ¥å¯å˜å‚æ•°ï¼‰
* `ProductLogger`å…·ä½“å®ç°
* `MockLogger`ï¼ˆåŸºäº GMockï¼Œç”¨äºæµ‹è¯•ï¼‰
* `LoggerAdapter` é€‚é…å±‚ï¼Œä¸šåŠ¡å±‚è°ƒç”¨å®ƒè§£è€¦
* å®ç®€åŒ–è°ƒç”¨
* ä¸šåŠ¡è°ƒç”¨ç¤ºä¾‹
* ç®€å•çš„æµ‹è¯•ç¤ºä¾‹ï¼ˆmockè°ƒç”¨æ¼”ç¤ºï¼‰

---

# å®Œæ•´ç¤ºä¾‹ä»£ç 

```cpp
#include <iostream>
#include <functional>
#include <utility>

// -------------------- ILogger æ¥å£ --------------------

class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;

    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;
};

// -------------------- ProductLogger å®ç° --------------------

int ReportError(bool /*mode*/, int code) {
    std::cout << "[ReportError] code: " << code << std::endl;
    return 0;
}

template<typename... Args>
int ReportError(bool /*mode*/, int code, Args&&... args) {
    std::cout << "[ReportError] code: " << code << ", args: ";
    (std::cout << ... << args) << std::endl;
    return 0;
}

class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoker) override {
        return invoker();
    }

    template<typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};

// -------------------- LoggerAdapter è§£è€¦å±‚ --------------------

class LoggerAdapter {
public:
    explicit LoggerAdapter(ILogger* logger) : logger_(logger) {}

    template<typename... Args>
    int Report(int code, Args&&... args) {
        return DispatchReport(logger_, code, std::forward<Args>(args)...);
    }

private:
    ILogger* logger_;

    template<typename... Args>
    static int DispatchReport(ILogger* logger, int code, Args&&... args) {
        return logger->ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};

// -------------------- å®ç®€åŒ–è°ƒç”¨ --------------------

#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)

// -------------------- ä¸šåŠ¡ä»£ç ç¤ºä¾‹ --------------------

void BusinessLogic(LoggerAdapter& logger) {
    REPORT(logger, 1001);
    REPORT(logger, 1002, "paramA");
    REPORT(logger, 1003, "paramB", 123);
}

// -------------------- GMock MockLogger ç¤ºä¾‹ --------------------

#ifdef ENABLE_GMOCK
#include <gmock/gmock.h>

class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int code), (override));
    MOCK_METHOD(int, ReportWithArgs, (int code, const std::function<int()>& invoker), (override));
};

void TestMock() {
    MockLogger mock;
    LoggerAdapter adapter(&mock);

    using ::testing::_;
    using ::testing::Invoke;

    EXPECT_CALL(mock, ReportWithArgs(1001, _))
        .WillOnce(Invoke([](int, const std::function<int()>& invoker) {
            std::cout << "[MockLogger] Intercept ReportWithArgs 1001" << std::endl;
            return invoker();  // ä¹Ÿå¯ä»¥ç›´æ¥è¿”å›æ¨¡æ‹Ÿå€¼
        }));

    BusinessLogic(adapter);
}

#endif

// -------------------- ä¸»å‡½æ•° --------------------

int main() {
    ProductLogger realLogger;
    LoggerAdapter adapter(&realLogger);

    std::cout << "== Business Logic using real ProductLogger ==" << std::endl;
    BusinessLogic(adapter);

#ifdef ENABLE_GMOCK
    std::cout << "\n== Business Logic using MockLogger (GMock) ==" << std::endl;
    TestMock();
#endif

    return 0;
}
```

---

# è¯´æ˜

* ä¸šåŠ¡å±‚åªä¾èµ– `LoggerAdapter`ï¼Œå®Œå…¨ä¸çŸ¥é“å…·ä½“å®ç°ç»†èŠ‚ã€‚
* é€‚é…å±‚è´Ÿè´£è°ƒç”¨æ¥å£ï¼Œæ¡¥æ¥å¯å˜å‚æ•°è°ƒç”¨ã€‚
* å® `REPORT` ä»…ä»…ç®€åŒ–è°ƒç”¨ï¼Œä¸å«å…·ä½“å®ç°è€¦åˆã€‚
* `ProductLogger` é€šè¿‡æ¡¥æ¥å®ç°å¯å˜å‚æ•°çš„è°ƒç”¨è½¬å‘ã€‚
* ä½ å¯ä»¥ç¼–è¯‘å¹¶è¿è¡Œè¿™æ®µä»£ç éªŒè¯è¾“å‡ºã€‚
* å¦‚æœå¯ç”¨ `ENABLE_GMOCK` å®ï¼ˆä¸”ç¯å¢ƒæ”¯æŒ GoogleMockï¼‰ï¼Œåˆ™ä¼šè¿è¡Œ Mock æµ‹è¯•ç¤ºä¾‹ã€‚

---

ä½ å¯ä»¥ç›´æ¥æŠŠè¿™æ®µä»£ç æ‹¿å»ç”¨ï¼Œæ”¹æˆä½ è‡ªå·± `ReportError` çš„å…·ä½“å®ç°ï¼Œä¸šåŠ¡å±‚è°ƒç”¨ä¿æŒä¸å˜ã€‚

éœ€è¦æˆ‘å¸®ä½ å†™ä¸€ä»½å®Œæ•´çš„ CMakeLists.txt é…åˆ GMock æµ‹è¯•å—ï¼Ÿ


è¿™æ®µ C++ ä»£ç å®ç°äº†ä¸€ä¸ªç»“æ„è‰¯å¥½çš„ **æ—¥å¿—ä¸ŠæŠ¥ç³»ç»Ÿ**ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹å‡ ä¸ªé‡è¦ç‰¹æ€§ï¼š

---

## ğŸ”§ **æ¨¡å—æ¦‚è§ˆ**

| æ¨¡å—              | åŠŸèƒ½è¯´æ˜             |
| --------------- | ---------------- |
| `ILogger`       | æŠ½è±¡æ¥å£ï¼Œå®šä¹‰æ—¥å¿—ä¸ŠæŠ¥æ–¹æ³•    |
| `ProductLogger` | å…·ä½“å®ç°ï¼Œç”¨äºå®é™…æ—¥å¿—ä¸ŠæŠ¥    |
| `LoggerAdapter` | é€‚é…å™¨ï¼Œè§£è€¦è°ƒç”¨æ–¹ä¸å…·ä½“æ—¥å¿—å®ç° |
| `ReportError`   | å®é™…çš„æ—¥å¿—ä¸ŠæŠ¥å‡½æ•°ï¼ˆæ”¯æŒå˜å‚ï¼‰  |
| å® `REPORT`      | ç®€åŒ–ä¸šåŠ¡ä»£ç ä¸­çš„æ—¥å¿—è°ƒç”¨æ–¹å¼   |
| `MockLogger`    | ç”¨äºå•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨ GMockï¼‰ |

---

## ğŸ§± **æ ¸å¿ƒè®¾è®¡æ€æƒ³**

### 1. **æ¥å£æŠ½è±¡ (`ILogger`)**

å®šä¹‰äº†ä¸¤ä¸ªçº¯è™šå‡½æ•°ï¼š

```cpp
virtual int Report(int code) = 0;
virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;
```

* `Report`ï¼šåŸºç¡€ä¸ŠæŠ¥ï¼Œä¸å¸¦é¢å¤–å‚æ•°
* `ReportWithArgs`ï¼šæ”¯æŒæºå¸¦æ‰§è¡Œé€»è¾‘ï¼ˆé€šè¿‡ `std::function` ä¼ å…¥ï¼‰

---

### 2. **æ—¥å¿—å‡½æ•°å®ç°ï¼ˆæ”¯æŒå¯å˜å‚æ•°ï¼‰**

```cpp
int ReportError(bool mode, int code, Args&&... args);
```

* ç”¨äº† **æŠ˜å è¡¨è¾¾å¼** `(std::cout << ... << args)` æ‰“å°ä»»æ„æ•°é‡å‚æ•°ã€‚
* `mode` å‚æ•°è¢«å¿½ç•¥ï¼Œä½†å¯èƒ½é¢„ç•™ç”¨äºæ‰©å±•ï¼ˆå¦‚æ—¥å¿—ç­‰çº§ï¼‰ã€‚

---

### 3. **`ProductLogger` å®ç° ILogger**

* `Report(code)`ï¼šè°ƒç”¨ `ReportError`
* `ReportWithArgs(code, invoker)`ï¼šè°ƒç”¨ä¼ å…¥çš„ `invoker`
* `ReportVariadic(code, ...)`ï¼šç”¨äºæ”¯æŒå¯å˜å‚æ•°ï¼Œå†…éƒ¨è½¬å‘ç»™ `ReportWithArgs`

ç¤ºä¾‹ï¼š

```cpp
ReportVariadic(1002, "paramA");
```

æœ€ç»ˆä¼šè°ƒç”¨ï¼š

```cpp
ReportWithArgs(1002, [] { return ReportError(1002, "paramA"); });
```

---

### 4. **LoggerAdapter è§£è€¦ä¸šåŠ¡ä»£ç å’Œæ—¥å¿—å®ç°**

```cpp
template<typename... Args>
int Report(int code, Args&&... args);
```

* å°†è°ƒç”¨å§”æ‰˜ç»™ `DispatchReport` é™æ€å‡½æ•°ã€‚
* `DispatchReport` ä¸­å°è£…äº† `ReportError` è°ƒç”¨é€»è¾‘ã€‚

ä½œç”¨æ˜¯æŠŠä¸šåŠ¡é€»è¾‘ä»æ—¥å¿—é€»è¾‘ä¸­è§£è€¦å‡ºæ¥ï¼Œé¿å…ç›´æ¥ä¾èµ–å…·ä½“çš„ `ProductLogger` å®ç°ã€‚

---

### 5. **å®å®šä¹‰ REPORT**

```cpp
#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)
```

* å®å°† `Report(1002, "paramA")` ç­‰ä»·ä¸ºï¼š`adapter.Report(1002, "paramA")`
* ç®€åŒ–è°ƒç”¨ï¼Œä¿æŒä»£ç ç®€æ´

---

### 6. **ä¸šåŠ¡ä»£ç ç¤ºä¾‹**

```cpp
void BusinessLogic(LoggerAdapter& logger);
```

* å±•ç¤ºäº† `REPORT()` å®çš„ç”¨æ³•ï¼ŒåŒ…æ‹¬æ— å‚æ•°ã€å•å‚æ•°ã€å¤šå‚æ•°è°ƒç”¨ã€‚

---

### 7. **GMock ç”¨æ³•ï¼ˆæ¡ä»¶ç¼–è¯‘ï¼‰**

```cpp
#ifdef ENABLE_GMOCK
```

* å¼•å…¥ `MockLogger` æ¨¡æ‹Ÿå™¨ç±»
* `EXPECT_CALL(...).WillOnce(Invoke(...))`ï¼šéªŒè¯è°ƒç”¨å¹¶æä¾›è‡ªå®šä¹‰è¡Œä¸ºï¼ˆå¦‚æ‰“å° + æ‰§è¡Œ `invoker()`ï¼‰

å¯ç”¨äºå•å…ƒæµ‹è¯•éªŒè¯æ—¥å¿—é€»è¾‘æ˜¯å¦è¢«æ­£ç¡®è°ƒç”¨ã€‚

---

## âœ… **ä¼˜ç‚¹æ€»ç»“**

* âœ… **é«˜è§£è€¦**ï¼šä¸šåŠ¡ä»£ç é€šè¿‡ `LoggerAdapter` è°ƒç”¨ï¼Œä¸ä¾èµ–å…·ä½“æ—¥å¿—å®ç°
* âœ… **æ”¯æŒ Mock**ï¼šé€šè¿‡ `ILogger` æ¥å£ + GMockï¼Œæ–¹ä¾¿æµ‹è¯•æ—¥å¿—é€»è¾‘
* âœ… **å˜å‚æ—¥å¿—**ï¼šä½¿ç”¨ç°ä»£ C++ ç‰¹æ€§ï¼ˆæŠ˜å è¡¨è¾¾å¼ï¼‰å®ç°æ—¥å¿—å‡½æ•°
* âœ… **ç®€æ´è°ƒç”¨å®**ï¼šä¸šåŠ¡ä»£ç è°ƒç”¨æ—¥å¿—éå¸¸ç®€æ´

---

## ğŸ”§ **ä¼˜åŒ–å»ºè®®**

1. **ç§»é™¤æœªä½¿ç”¨å‚æ•° `bool mode`**ï¼Œæˆ–åŠ ä»¥è¯´æ˜/ä½¿ç”¨ã€‚
2. `ReportVariadic` æ˜¯ `ProductLogger` çš„å†…éƒ¨æ–¹æ³•ï¼Œå¤–éƒ¨ä¸ç›´æ¥ç”¨ï¼Œå¯ä»¥è€ƒè™‘æ˜¯å¦å…¬å¼€ã€‚
3. `DispatchReport` ä¸º `LoggerAdapter` çš„ç§æœ‰é™æ€æ–¹æ³•ï¼ŒèŒè´£å¯ä»¥å½’å…¥ lambda ä¸­ç®€åŒ–ã€‚

---

## ğŸ“Œ æ€»ç»“

è¿™æ˜¯ä¸€å¥—ç°ä»£ C++ é£æ ¼çš„æ—¥å¿—ä¸ŠæŠ¥æ¡†æ¶ï¼Œé‡ç‚¹ä½“ç°ï¼š

* æ¥å£ç¼–ç¨‹
* å‡½æ•°å¯¹è±¡ï¼ˆ`std::function`ï¼‰å°è£…è¡Œä¸º
* æ¨¡æ¿ä¸å˜å‚å±•å¼€
* ç®€æ´å®å°è£…
* å¯æµ‹è¯•æ€§ï¼ˆMockï¼‰

å¦‚æœä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ï¼š

* æ·»åŠ å•å…ƒæµ‹è¯•
* æ³¨é‡Šä»£ç 
* ä¼˜åŒ–è®¾è®¡
* æ·»åŠ æ—¥å¿—ç­‰çº§æ”¯æŒç­‰

è¯·å‘Šè¯‰æˆ‘ä¸‹ä¸€æ­¥éœ€è¦ä»€ä¹ˆå¸®åŠ©ã€‚


è¿™æ˜¯ä¸ªå¥½é—®é¢˜ï¼è¿™æ®µä»£ç ä¸­ï¼Œâ€œ**æœ‰æ— å˜å‚çš„åŒºåˆ†**â€ä¾èµ–äº **C++ æ¨¡æ¿å‡½æ•° + å® + é‡è½½è§£æ** çš„æœºåˆ¶ã€‚

---

## âœ… ç›®æ ‡ï¼šè®© `REPORT(logger, code)` å’Œ `REPORT(logger, code, args...)` éƒ½èƒ½æ­£å¸¸å·¥ä½œ

æ¯”å¦‚ï¼š

```cpp
REPORT(logger, 1001);                 // æ— å˜å‚
REPORT(logger, 1002, "paramA");       // ä¸€ä¸ªå˜å‚
REPORT(logger, 1003, "paramB", 123);  // å¤šä¸ªå˜å‚
```

---

## ğŸ” å¦‚ä½•å®ç°è¿™ç§åŒºåˆ†ï¼Ÿ

### 1. **é€šè¿‡å® `REPORT` çš„å‚æ•°å±•å¼€è¡Œä¸º**

```cpp
#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)
```

* `##__VA_ARGS__` æ˜¯ GCC å’Œ Clang çš„æ‰©å±•ï¼š
  å½“ `__VA_ARGS__` ä¸ºç©ºæ—¶ï¼Œè¿åŒå‰é¢çš„é€—å· `,` ä¸€èµ·è¢«å»æ‰ã€‚
* æ‰€ä»¥è¿™è¡Œå®å¯ä»¥æ™ºèƒ½åœ°å˜æˆï¼š

  ```cpp
  REPORT(logger, 1001)       â†’  logger.Report(1001)
  REPORT(logger, 1002, "x")  â†’  logger.Report(1002, "x")
  ```

---

### 2. **LoggerAdapter::Report æ˜¯æ¨¡æ¿å‡½æ•°**

```cpp
template<typename... Args>
int Report(int code, Args&&... args);
```

* C++ ä¼šæ ¹æ®å‚æ•°åŒ¹é…æƒ…å†µè‡ªåŠ¨æ¨å¯¼æ¨¡æ¿å‚æ•°ï¼š

  * `Report(1001)`         â†’ `Args` ä¸ºç©ºåŒ…ï¼ˆæ— å‚æ•°ï¼‰
  * `Report(1002, "x")`    â†’ `Args` ä¸º `const char*`
  * `Report(1003, "x", 5)` â†’ `Args` ä¸º `const char*, int`

è¿™æ„å‘³ç€ï¼Œ**ä½ åªå®šä¹‰äº†ä¸€ä¸ªæ¨¡æ¿å‡½æ•°ï¼Œå°±æ”¯æŒäº†â€œæ— å‚â€å’Œâ€œä»»æ„ä¸ªå‚æ•°â€ä¸¤ç§æƒ…å†µã€‚**

---

### 3. **å®é™…å˜å‚å¤„ç†åœ¨ `DispatchReport` é‡Œ**

```cpp
template<typename... Args>
static int DispatchReport(ILogger* logger, int code, Args&&... args) {
    return logger->ReportWithArgs(code, [&]() {
        return ReportError(false, code, std::forward<Args>(args)...);
    });
}
```

å¦‚æœ `args...` æ˜¯ç©ºçš„ï¼Œè°ƒç”¨ï¼š

```cpp
ReportError(false, code); // å¯¹åº”éå˜å‚ç‰ˆæœ¬
```

å¦åˆ™ï¼Œè°ƒç”¨ï¼š

```cpp
ReportError(false, code, args...); // å¯¹åº”å˜å‚ç‰ˆæœ¬
```

å› ä¸ºä½ åœ¨é¡¶å±‚å®šä¹‰äº†ä¸¤ä¸ªå‡½æ•°ï¼š

```cpp
int ReportError(bool, int);                      // éå˜å‚
template<typename... Args>
int ReportError(bool, int, Args&&...);           // å˜å‚
```

> ç¼–è¯‘å™¨ä¼šæ ¹æ®å‚æ•°ä¸ªæ•°è‡ªåŠ¨è°ƒç”¨æ­£ç¡®çš„å‡½æ•°ç‰ˆæœ¬ï¼ˆå‡½æ•°é‡è½½æœºåˆ¶ï¼‰ã€‚

---

## ğŸ§  æ€»ç»“

| æŠ€æœ¯ç‚¹               | ä½œç”¨                        |
| ----------------- | ------------------------- |
| å® `##__VA_ARGS__` | æ”¯æŒæ— å‚æ•°å’Œå¤šå‚æ•°è‡ªåŠ¨é€‚é…             |
| æ¨¡æ¿å‚æ•°åŒ… `Args...`   | æ•è·å˜å‚æˆ–ä¸ºç©º                   |
| å‡½æ•°é‡è½½              | åŒºåˆ†æ— å‚æ•°å’Œæœ‰å‚æ•°çš„ ReportError è°ƒç”¨ |

æ•´ä¸ªæœºåˆ¶æ˜¯**å®å±•å¼€ + æ¨¡æ¿ + å‡½æ•°é‡è½½**çš„ååŒé…åˆã€‚

---

å¦‚æœä½ æƒ³è¿›ä¸€æ­¥ç»†åŒ–å¤„ç†ï¼Œä¾‹å¦‚ï¼š

* å¯¹æ— å‚å’Œæœ‰å‚çš„æƒ…å†µåšä¸åŒçš„é€»è¾‘å¤„ç†
* é™åˆ¶æœ€å¤šå‡ ä¸ªå‚æ•°
* ä½¿ç”¨ `if constexpr` åšä¸åŒå¤„ç†

æˆ‘ä¹Ÿå¯ä»¥æä¾›ç›¸åº”æ”¹è¿›ç‰ˆæœ¬ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ



æ˜¯çš„ï¼Œä½ æå‡ºäº†ä¸€ä¸ª **éå¸¸åˆç†ä¸”å·¥ç¨‹ä¸Šå¸¸è§çš„é‡æ„æ€è·¯**ï¼š
**å°†å¤–éƒ¨å¹³å°æ¥å£è°ƒç”¨ï¼ˆå¦‚ `ReportError`ï¼‰ä» `LoggerAdapter` ç§»å…¥ `ProductLogger` ä¸­ã€‚**

---

## âœ… å½“å‰ç»“æ„çš„æ½œåœ¨é—®é¢˜

åœ¨ä½ å½“å‰çš„ä»£ç ä¸­ï¼š

```cpp
template<typename... Args>
static int DispatchReport(ILogger* logger, int code, Args&&... args) {
    return logger->ReportWithArgs(code, [&]() {
        return ReportError(false, code, std::forward<Args>(args)...);
    });
}
```

è¿™é‡Œæœ‰ **â€œé€»è¾‘æ³„éœ²â€** çš„é—®é¢˜ï¼š

> `LoggerAdapter` æ˜¯ä¸šåŠ¡é€»è¾‘å’Œæ—¥å¿—ä¹‹é—´çš„æ¡¥æ¢ï¼Œ**æœ¬æ„æ˜¯åšè§£è€¦å’Œè½¬å‘**ï¼Œä½†å®ƒå´è°ƒç”¨äº†å…·ä½“å®ç° `ProductLogger` æ‰€ä½¿ç”¨çš„æ—¥å¿—å‡½æ•° `ReportError`ï¼Œè¿™ç ´åäº†æŠ½è±¡æ€§ã€‚

---

## ğŸ” æ›´åˆç†çš„è®¾è®¡

ä½ å¯ä»¥å°†å˜å‚å¤„ç†é€»è¾‘ä» `LoggerAdapter` ä¸­ç§»é™¤ï¼Œ**ç”±å…·ä½“å®ç°ç±»å¦‚ `ProductLogger` æ¥å†³å®šå¦‚ä½•ä¸ŠæŠ¥**ã€‚

---

### âœ… é‡æ„æ–¹æ¡ˆï¼šè®© `ILogger` æ”¯æŒå˜å‚ä¸ŠæŠ¥

#### 1. **ä¸º `ILogger` å¢åŠ æ¨¡æ¿æ–¹æ³•ï¼ˆæˆ–è™šæ‹Ÿå˜å‚æ¥å£ï¼‰**

> å¦‚æœä½ æƒ³ä¿ç•™æ¥å£ç»Ÿä¸€æ€§ï¼Œå¯ä»¥ä½¿ç”¨æ¨¡æ¿ + æ¨¡æ¿è™šå‡½æ•°ç»„åˆï¼Œæˆ–å¹²è„†åªæ”¯æŒ `ReportWithArgs()`ï¼Œç„¶åç”±å­ç±»å°è£…å˜å‚ã€‚

æˆ–è€…æ›´ç›´æ¥çš„åšæ³•ï¼š

#### 2. **å°† `ReportVariadic` æˆä¸ºæ¥å£çš„ä¸€éƒ¨åˆ†**

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;
    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;

    template<typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return DoReport(code, std::forward<Args>(args)...);
        });
    }

protected:
    template<typename... Args>
    virtual int DoReport(int code, Args&&... args) = 0;
};
```

> æˆ–è€…æ›´ç®€å•åœ°ç›´æ¥æŠŠ `ReportVariadic()` ç•™ç»™ `ProductLogger` å®ç°ã€‚

#### 3. **ä¿®æ”¹ LoggerAdapterï¼Œåªè°ƒç”¨æ¥å£è€Œä¸åšå¹³å°è°ƒç”¨ï¼š**

```cpp
template<typename... Args>
int Report(int code, Args&&... args) {
    return logger_->ReportVariadic(code, std::forward<Args>(args)...);
}
```

---

## ğŸš§ ä½†æ˜¯é—®é¢˜æ˜¯ï¼š

### C++ ä¸æ”¯æŒè™šå‡½æ•°æ¨¡æ¿ï¼ˆå³ä¸èƒ½ `virtual template<typename...> Report(...)`ï¼‰

æ‰€ä»¥å¦‚æœä½ è¦è®©æ¥å£æ”¯æŒå˜å‚ï¼Œå¯ä»¥è€ƒè™‘ä¸‹é¢ 2 ç§æ–¹å¼ï¼š

---

## âœ… æ¨èæ–¹æ¡ˆï¼šå°†æ‰€æœ‰å¹³å°é€»è¾‘ä¿ç•™åœ¨ `ProductLogger` ä¸­

### æ–¹å¼ä¸€ï¼šè®© `LoggerAdapter` ä¸æ„ŸçŸ¥ `ReportError`

```cpp
template<typename... Args>
int Report(int code, Args&&... args) {
    // ç›´æ¥è°ƒç”¨ ILogger ä¸­çš„é€šç”¨æ¥å£ï¼Œç”±å®ç°ç±»å¤„ç†å˜å‚å’Œå®é™…ä¸ŠæŠ¥
    return logger_->ReportWithArgs(code, [&]() {
        return logger_->DoReport(code, std::forward<Args>(args)...);
    });
}
```

æˆ–è€…ï¼š

### æ–¹å¼äºŒï¼šProductLogger ç»§æ‰¿ä¸€ä¸ªå˜å‚æ¥å£

```cpp
class IVariadicLogger : public ILogger {
public:
    virtual ~IVariadicLogger() = default;

    template<typename... Args>
    int ReportVariadic(int code, Args&&... args) {
        return ReportWithArgs(code, [&]() {
            return ReportError(false, code, std::forward<Args>(args)...);
        });
    }
};
```

ç„¶å `LoggerAdapter` ä¸­åšç±»å‹è¯†åˆ«ï¼š

```cpp
if (auto* variadic = dynamic_cast<IVariadicLogger*>(logger_)) {
    return variadic->ReportVariadic(code, std::forward<Args>(args)...);
}
```

---

## ğŸ§  æ€»ç»“ï¼šæ˜¯å¦åº”å°† `ReportError` è°ƒç”¨æŒªè¿› `ProductLogger`ï¼Ÿ

| è®¾è®¡é¡¹                    | å»ºè®®                                    |
| ---------------------- | ------------------------------------- |
| `ReportError` æ˜¯å¹³å°å®ç°    | âœ… åº”è¯¥åªç”± `ProductLogger` æŒæœ‰             |
| `LoggerAdapter` æ˜¯æŠ½è±¡ä¸­é—´å±‚ | âœ… åº”åªä¾èµ– `ILogger` æ¥å£                   |
| æœ‰å˜å‚é€»è¾‘åº”è¯¥å½’è°ï¼Ÿ             | âœ… `ProductLogger`                     |
| æ˜¯å¦åº”è¯¥åŠ¨æ€åˆ†æ´¾å˜å‚ä¸ŠæŠ¥ï¼Ÿ          | âœ… è§†éœ€æ±‚ï¼Œå¯ä»¥ç”¨ `ReportWithArgs()` + lambda |
| éœ€è¦ä¿æŒ Mock å…¼å®¹ï¼Ÿ          | âœ… ä½¿ç”¨ `ReportWithArgs()` ä¿æŒä¸€è‡´æ€§         |

---

å¦‚æœä½ å¸Œæœ›ï¼Œæˆ‘å¯ä»¥ä¸ºä½  **é‡æ„è¿™å¥—ç»“æ„**ï¼Œå°†å¹³å°è°ƒç”¨å…¨éƒ¨ç§»è‡³ `ProductLogger`ï¼Œå¹¶ä¿æŒ `LoggerAdapter` çš„ç®€æ´ä¸­é—´å±‚å®šä½ã€‚æ˜¯å¦éœ€è¦æˆ‘æ¥ä¿®æ”¹å¹¶å±•ç¤ºï¼Ÿ


å¥½çš„ï¼Œæˆ‘ä»¬å°†æŒ‰ç…§ä½ çš„è¦æ±‚ï¼ŒæŠŠå¹³å°è°ƒç”¨ï¼ˆå³ `ReportError(...)`ï¼‰ä» `LoggerAdapter` ä¸­å®Œå…¨ç§»é™¤ï¼Œ**é›†ä¸­åˆ° `ProductLogger` ä¸­å®ç°**ï¼Œä»¥è¾¾åˆ°æ›´æ¸…æ™°çš„èŒè´£åˆ’åˆ†å’Œæ›´å¥½çš„æŠ½è±¡è§£è€¦ã€‚

---

## âœ… é‡æ„ç›®æ ‡

1. `LoggerAdapter` **åªä¾èµ–æ¥å£ `ILogger`**ã€‚
2. `ReportError(...)` é€»è¾‘åªèƒ½å‡ºç°åœ¨ `ProductLogger`ã€‚
3. `ProductLogger` **ç‹¬ç«‹å¤„ç†å˜å‚é€»è¾‘**ã€‚
4. ä¿ç•™ mock å’Œæµ‹è¯•èƒ½åŠ›ã€‚

---

## ğŸ›  é‡æ„æ­¥éª¤æ¦‚è§ˆ

### ğŸ”¹ Step 1: `ILogger` ä¿ç•™åŸæ¥å£ï¼Œä¸å¼•å…¥æ¨¡æ¿æˆ–å˜å‚

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;

    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;
};
```

---

### ğŸ”¹ Step 2: ç§»é™¤ `LoggerAdapter::DispatchReport` ä¸­çš„ `ReportError`

```cpp
// LoggerAdapter è§£è€¦å±‚
class LoggerAdapter {
public:
    explicit LoggerAdapter(ILogger* logger) : logger_(logger) {}

    template<typename... Args>
    int Report(int code, Args&&... args) {
        return logger_->ReportWithArgs(code, [&]() {
            return logger_->ReportWithArgsImpl(code, std::forward<Args>(args)...);
        });
    }

private:
    ILogger* logger_;
};
```

> âš ï¸ ä½† C++ ä¸æ”¯æŒè™šå‡½æ•°æ¨¡æ¿ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨æ¥å£ä¸­å®šä¹‰ `ReportWithArgsImpl(...)`ã€‚

### âœ… æ­£ç¡®åšæ³•ï¼š`LoggerAdapter` å§”æ‰˜ç»™ `ReportWithArgs(...)`ï¼Œå°†å¹³å°è°ƒç”¨äº¤ç»™ `ProductLogger`

æˆ‘ä»¬å°±ä¿æŒåŸæ¥å£ä¸å˜ï¼Œå¹¶è®© `ProductLogger` å®Œå…¨è´Ÿè´£å¹³å°è°ƒç”¨ã€‚

---

## âœ… ç»ˆææ”¹æ³•ï¼šè®© `ProductLogger` è´Ÿè´£å˜å‚é€»è¾‘

### âœ” ä¿®æ”¹ `LoggerAdapter`ï¼ˆåªä½¿ç”¨æ¥å£ï¼‰

```cpp
class LoggerAdapter {
public:
    explicit LoggerAdapter(ILogger* logger) : logger_(logger) {}

    template<typename... Args>
    int Report(int code, Args&&... args) {
        return logger_->ReportWithArgs(code, [&]() {
            return logger_->HandleReport(code, std::forward<Args>(args)...);
        });
    }

private:
    ILogger* logger_;
};
```

---

### âœ” ä¿®æ”¹ `ILogger` æ¥å£ï¼ˆæ·»åŠ æ¨¡æ¿è¾…åŠ©è™šå‡½æ•°ï¼‰

ç”±äºæ¨¡æ¿ä¸èƒ½æ˜¯è™šå‡½æ•°ï¼Œæˆ‘ä»¬é‡‡ç”¨ **éè™šæ¥å£ï¼ˆNVIï¼‰è®¾è®¡æ¨¡å¼**ï¼š

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;

    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;

    template<typename... Args>
    int HandleReport(int code, Args&&... args) {
        return DoHandleReport(code, std::forward<Args>(args)...);
    }

private:
    // æ¨¡æ¿è¾…åŠ©å‡½æ•°ï¼Œåªç”±å­ç±»ä½¿ç”¨ï¼ˆä¸è™šï¼‰
    virtual int DoHandleReport(int code) { return Report(code); }

    template<typename... Args>
    int DoHandleReport(int code, Args&&... args) {
        // fallbackï¼Œé»˜è®¤å•¥ä¹Ÿä¸åš
        return Report(code);
    }
};
```

---

### âœ” ä¿®æ”¹ `ProductLogger` å®ç°

```cpp
class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoker) override {
        return invoker();
    }

private:
    // é‡å†™æ¨¡æ¿çš„è¾…åŠ©å‡½æ•°ï¼ˆéè™šï¼‰
    template<typename... Args>
    int DoHandleReport(int code, Args&&... args) {
        return ReportError(false, code, std::forward<Args>(args)...);
    }

    // è®© ILogger::HandleReport èƒ½è®¿é—®å®ƒ
    friend class LoggerAdapter;
};
```

> ğŸ¯ æ³¨æ„ï¼šè™½ç„¶ `DoHandleReport` ä¸æ˜¯è™šå‡½æ•°ï¼Œæ¥å£å±‚ä¹Ÿæ— æ³•å¼ºåˆ¶ overrideï¼Œä½†é€šè¿‡ `friend` å’Œæ¨¡æ¿ï¼Œæˆ‘ä»¬è®© `LoggerAdapter` è°ƒç”¨çš„æ˜¯å­ç±»å®ç°çš„ç‰ˆæœ¬ã€‚

---

## ğŸ’¡ æ€»ç»“å¯¹æ¯”ï¼ˆå‰åèŒè´£ï¼‰

| å±‚çº§              | åŸèŒè´£           | é‡æ„åèŒè´£                         |
| --------------- | ------------- | ----------------------------- |
| `LoggerAdapter` | è½¬å‘å¹¶è°ƒç”¨å¹³å°æ¥å£     | ä»…è½¬å‘åˆ° `ILogger::HandleReport`  |
| `ILogger`       | å®šä¹‰æ¥å£          | åŒä¸Šï¼Œæ–°å¢æ¨¡æ¿è¾…åŠ©å‡½æ•°                   |
| `ProductLogger` | è°ƒç”¨å¹³å°æ¥å£ + æ¥å£å®ç° | **å”¯ä¸€è´Ÿè´£è°ƒç”¨ `ReportError(...)`** |

---

## âœ… ä½ ç°åœ¨è·å¾—çš„å¥½å¤„ï¼š

* `LoggerAdapter` **ä¸å†ä¾èµ–å¹³å° API**
* `ProductLogger` **é›†ä¸­æ‰€æœ‰å…·ä½“å®ç°é€»è¾‘**
* **æµ‹è¯•å‹å¥½æ€§ä¿ç•™**ï¼ˆGMock ä¾ç„¶å¯ä»¥ mock `ReportWithArgs`ï¼‰
* ä½¿ç”¨äº†ç°ä»£ C++ æŠ€æœ¯ï¼ˆæ¨¡æ¿ã€NVIã€å®Œç¾è½¬å‘ï¼‰

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç›´æ¥æä¾›å®Œæ•´çš„é‡æ„åä»£ç ï¼Œæˆ‘å¯ä»¥å¸®ä½ æ•´ç†æˆä¸€ä¸ªå¹²å‡€çš„ç‰ˆæœ¬ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ


ä»¥ä¸‹æ˜¯ä½ è¦æ±‚çš„**å®Œæ•´é‡æ„ç‰ˆæœ¬ä»£ç **ï¼Œå…¶ä¸­ï¼š

* å¹³å°è°ƒç”¨ï¼ˆ`ReportError`ï¼‰**åªåœ¨ `ProductLogger` ä¸­å‡ºç°**
* `LoggerAdapter` åªä¾èµ– `ILogger`ï¼Œ**èŒè´£å•ä¸€**
* ä½¿ç”¨æ¨¡æ¿å’Œéè™šæ¥å£ï¼ˆNVIï¼‰æ¨¡å¼å®ç°å˜å‚æ”¯æŒ
* ä¿ç•™äº† GMock mock æµ‹è¯•æ”¯æŒ

---

## âœ… é‡æ„åçš„å®Œæ•´ä»£ç ï¼š

```cpp
#include <iostream>
#include <functional>
#include <utility>

// -------------------- ILogger æ¥å£ --------------------

class ILogger {
public:
    virtual ~ILogger() = default;

    virtual int Report(int code) = 0;

    virtual int ReportWithArgs(int code, const std::function<int()>& invoker) = 0;

    // NVI æ¨¡å¼ï¼šå°†å¹³å°è°ƒç”¨è½¬å‘åˆ°å®ç°ç±»ï¼ˆé€šè¿‡æ¨¡æ¿å±•å¼€ï¼‰
    template<typename... Args>
    int HandleReport(int code, Args&&... args) {
        return DoHandleReport(code, std::forward<Args>(args)...);
    }

private:
    // fallbackï¼šæ— å‚æ•°æ—¶è°ƒç”¨
    virtual int DoHandleReport(int code) {
        return Report(code);
    }

    // æ¨¡æ¿ç‰ˆæœ¬å¤„ç†å˜å‚ï¼ˆéè™šï¼Œäº¤ç”±å­ç±»å®ç°ï¼‰
    template<typename... Args>
    int DoHandleReport(int code, Args&&... args) {
        return Report(code); // fallback å®ç°ï¼ˆå­ç±»ä¼šé‡è½½ï¼‰
    }

    // å…è®¸ friend ç±»è®¿é—®æ¨¡æ¿ç§æœ‰å‡½æ•°
    template<typename... Args>
    friend class LoggerAdapter;
};

// -------------------- å¹³å°è°ƒç”¨å®ç° --------------------

int ReportError(bool /*mode*/, int code) {
    std::cout << "[ReportError] code: " << code << std::endl;
    return 0;
}

template<typename... Args>
int ReportError(bool /*mode*/, int code, Args&&... args) {
    std::cout << "[ReportError] code: " << code << ", args: ";
    (std::cout << ... << args) << std::endl;
    return 0;
}

// -------------------- ProductLogger å®ç° --------------------

class ProductLogger : public ILogger {
public:
    int Report(int code) override {
        return ReportError(false, code);
    }

    int ReportWithArgs(int code, const std::function<int()>& invoker) override {
        return invoker();  // ç»Ÿä¸€é€šè¿‡ invoker å¤„ç†å˜å‚
    }

private:
    // ç‰¹åŒ–æ¨¡æ¿æ–¹æ³•ï¼ŒçœŸæ­£å¤„ç†å˜å‚
    template<typename... Args>
    int DoHandleReport(int code, Args&&... args) {
        return ReportError(false, code, std::forward<Args>(args)...);
    }

    // å…è®¸ ILogger æ¨¡æ¿è®¿é—®æ­¤æˆå‘˜
    template<typename... Args>
    friend class LoggerAdapter;
};

// -------------------- LoggerAdapter è§£è€¦å±‚ --------------------

class LoggerAdapter {
public:
    explicit LoggerAdapter(ILogger* logger) : logger_(logger) {}

    template<typename... Args>
    int Report(int code, Args&&... args) {
        return logger_->ReportWithArgs(code, [&]() {
            return logger_->HandleReport(code, std::forward<Args>(args)...);
        });
    }

private:
    ILogger* logger_;
};

// -------------------- å®ç®€åŒ–è°ƒç”¨ --------------------

#define REPORT(adapter, code, ...) (adapter).Report(code, ##__VA_ARGS__)

// -------------------- ä¸šåŠ¡ä»£ç ç¤ºä¾‹ --------------------

void BusinessLogic(LoggerAdapter& logger) {
    REPORT(logger, 1001);
    REPORT(logger, 1002, "paramA");
    REPORT(logger, 1003, "paramB", 123);
}

// -------------------- GMock ç¤ºä¾‹ --------------------

#ifdef ENABLE_GMOCK
#include <gmock/gmock.h>

class MockLogger : public ILogger {
public:
    MOCK_METHOD(int, Report, (int code), (override));
    MOCK_METHOD(int, ReportWithArgs, (int code, const std::function<int()>& invoker), (override));
};

void TestMock() {
    MockLogger mock;
    LoggerAdapter adapter(&mock);

    using ::testing::_;
    using ::testing::Invoke;

    EXPECT_CALL(mock, ReportWithArgs(1001, _))
        .WillOnce(Invoke([](int, const std::function<int()>& invoker) {
            std::cout << "[MockLogger] Intercept ReportWithArgs 1001" << std::endl;
            return invoker();  // å¯ä»¥é€‰æ‹©æ‰§è¡Œå®é™…é€»è¾‘
        }));

    BusinessLogic(adapter);
}
#endif

// -------------------- ä¸»å‡½æ•° --------------------

int main() {
    ProductLogger realLogger;
    LoggerAdapter adapter(&realLogger);

    std::cout << "== Business Logic using real ProductLogger ==" << std::endl;
    BusinessLogic(adapter);

#ifdef ENABLE_GMOCK
    std::cout << "\n== Business Logic using MockLogger (GMock) ==" << std::endl;
    TestMock();
#endif

    return 0;
}
```

---

## âœ… é‡æ„äº®ç‚¹

| é¡¹ç›®             | å®ç°æ–¹å¼                                |
| -------------- | ----------------------------------- |
| **èŒè´£åˆ†ç¦»**       | `LoggerAdapter` åªè½¬å‘æ¥å£è°ƒç”¨             |
| **å˜å‚å¤„ç†å½’å±æ˜ç¡®**   | ä»… `ProductLogger` ä¸­å¤„ç† `ReportError` |
| **æµ‹è¯•å‹å¥½**       | `MockLogger` æ¨¡æ‹Ÿæ¥å£è¡Œä¸º                 |
| **ç±»å‹å®‰å…¨ + é«˜æ€§èƒ½** | ä½¿ç”¨æ¨¡æ¿å®Œç¾è½¬å‘                            |
| **ç°ä»£ C++ ç»“æ„**  | æ¨¡æ¿ã€æŠ˜å è¡¨è¾¾å¼ã€lambdaã€NVI æ¨¡å¼              |

---

å¦‚æœä½ éœ€è¦è¿™ä¸ªç»“æ„ç”Ÿæˆå¤´æ–‡ä»¶ä¸å®ç°æ–‡ä»¶åˆ†ç¦»ç‰ˆæœ¬ï¼Œæˆ–éœ€è¦é›†æˆæ›´å¤šæ—¥å¿—çº§åˆ«æ”¯æŒï¼ˆInfo/Warning/Errorï¼‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­å¸®ä½ æ‰©å±•ã€‚éœ€è¦å—ï¼Ÿ


æ˜¯çš„ï¼Œâœ… **ä¸Šè¿°é‡æ„å®ç°å¯ä»¥å…¼å®¹ C++14**ï¼Œåªéœ€è¦åš **å°‘é‡è°ƒæ•´**ï¼Œå› ä¸ºå½“å‰ä»£ç ä¸»è¦ç”¨åˆ°äº†å¦‚ä¸‹ç‰¹æ€§ï¼š

| ç‰¹æ€§                                 | æ˜¯å¦æ”¯æŒ C++14     | æ›¿ä»£æ–¹æ¡ˆæˆ–è¯´æ˜                        |
| ---------------------------------- | -------------- | ------------------------------ |
| `std::function`, `lambda`          | âœ… æ”¯æŒ           | æ— éœ€ä¿®æ”¹                           |
| å‡½æ•°æ¨¡æ¿ã€å®Œç¾è½¬å‘                          | âœ… æ”¯æŒ           | æ— éœ€ä¿®æ”¹                           |
| æŠ˜å è¡¨è¾¾å¼ `(std::cout << ... << args)` | âŒ ä¸æ”¯æŒ C++14    | âœ… éœ€è¦ä¿®æ”¹ä¸ºé€’å½’æ–¹å¼æˆ– initializer\_list |
| `##__VA_ARGS__`                    | âœ… GCC/Clang æ‰©å±• | MSVC ä¹Ÿæ”¯æŒï¼Œå®å®šä¹‰å¯ä¿ç•™                |
| NVI æ¨¡å¼ + æ¨¡æ¿ç»„åˆ                      | âœ… æ”¯æŒ           | è™½ç„¶æ¨¡æ¿ä¸èƒ½è™šæ‹Ÿï¼Œä½†ç»„åˆä½¿ç”¨æ˜¯åˆæ³•              |

---

## âŒ ä¸å…¼å®¹ç‚¹ï¼šæŠ˜å è¡¨è¾¾å¼

è¿™ä¸€è¡Œä»£ç ä½¿ç”¨äº† C++17 çš„æŠ˜å è¡¨è¾¾å¼ï¼š

```cpp
(std::cout << ... << args) << std::endl;
```

> âŒ è¿™æ˜¯ C++17 å¼•å…¥çš„æ–°è¯­æ³•ã€‚C++14 ä¸æ”¯æŒã€‚

---

## âœ… æ›¿ä»£æ–¹æ¡ˆï¼ˆå…¼å®¹ C++14ï¼‰

æˆ‘ä»¬ç”¨ `std::initializer_list` å’Œé€—å·è¡¨è¾¾å¼æ¨¡æ‹Ÿè¾“å‡ºå¤šä¸ªå‚æ•°ï¼š

```cpp
template<typename... Args>
int ReportError(bool /*mode*/, int code, Args&&... args) {
    std::cout << "[ReportError] code: " << code << ", args: ";
    using expander = int[];
    (void)expander{0, ((std::cout << args << " "), 0)...};
    std::cout << std::endl;
    return 0;
}
```

è§£é‡Šï¼š

* `expander` æ˜¯ä¸€ç§å¸¸è§æŠ€å·§ï¼Œç”¨æ¥**åœ¨ C++14 ä¸­å±•å¼€å‚æ•°åŒ…**ã€‚
* `(std::cout << args << " ", 0)` æ˜¯é€—å·è¡¨è¾¾å¼ï¼Œè¿”å› `0`ï¼Œç”¨äºå¡«å……æ•°ç»„ã€‚
* æ•´ä½“ä¿è¯å‚æ•°å±•å¼€é¡ºåºæ‰§è¡Œï¼Œä¸”æ— å‰¯ä½œç”¨ã€‚

---

## âœ… ç»“è®ºï¼šå…¼å®¹ C++14 åçš„å…³é”®ä¿®æ”¹

å”¯ä¸€éœ€è¦æ”¹åŠ¨çš„éƒ¨åˆ†å¦‚ä¸‹ï¼š

### ä¿®æ”¹å‰ï¼ˆC++17ï¼‰ï¼š

```cpp
(std::cout << ... << args) << std::endl;
```

### ä¿®æ”¹åï¼ˆC++14ï¼‰ï¼š

```cpp
using expander = int[];
(void)expander{0, ((std::cout << args << " "), 0)...};
std::cout << std::endl;
```

---

## ğŸ“Œ æœ€ç»ˆç»“è®º

âœ… **å¯ä»¥å…¼å®¹ C++14**ã€‚
åªéœ€æ›¿æ¢ **æŠ˜å è¡¨è¾¾å¼**ï¼Œå…¶ä»–å¦‚ï¼š

* æ¨¡æ¿ + lambda
* `std::function`
* å®Œç¾è½¬å‘
* éè™šæ¨¡æ¿ç»„åˆ
* `##__VA_ARGS__` å®æ‹¼æ¥

éƒ½æ˜¯ **C++14 å®Œæ•´æ”¯æŒçš„ç‰¹æ€§**ã€‚

---

å¦‚ä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥ä¸ºä½ è¾“å‡º **C++14 å®Œæ•´å…¼å®¹ç‰ˆä»£ç **ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ
