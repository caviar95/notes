# 掩码状态机（Mask State Machine）设计 — C++ 实现方案

下面给出一个**通用、可扩展**的 C++17 实现方案，满足你提出的需求：

* 支持**多个子系统**（每个子系统用一段位掩码表示）组合成一个 `CombinedState`；
* `CombinedState` 提供常用匹配接口（包含/重叠/按规则匹配）；
* 能把\*\*当前组合状态匹配到一组“最终状态（FinalState）”\*\*并返回可匹配到的最终状态集合；
* 能从一组组合状态中按自定义比较规则（优先级 / 字典序）得到**最高的组合状态**；
* 提供便捷的组合/交/比较/可视化方法，并考虑可扩展与线程安全（注册/查询分离，注册可在启动阶段进行）。

下面先给出完整实现代码，随后给出说明和示例。

---

## 代码（C++17）

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// CombinedState: N 个子系统，每个子系统用 uint64_t 表示位集合（支持每子系统最多64位）
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem (bit0..bit63)

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // 检查 this 是否包含 other（即 other 的每一位都在 this 中）
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // 检查对每个子系统，都至少存在一位重叠（用于要求每个子系统都匹配到某些状态）
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // 检查任意子系统存在重叠（任意一处匹配就算匹配）
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // 验证每个子系统的位宽不超过允许的 widths（由外部传入配置）
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            if (widths[i] <= 0 || widths[i] > 64) throw std::invalid_argument("invalid width");
            if (widths[i] < 64) {
                uint64_t mask = (widths[i] == 64) ? ~uint64_t(0) : ((uint64_t(1) << widths[i]) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << widths[i];
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    // 将 CombinedState 转为可读字符串（便于调试）
    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// FinalState: 一个最终态/目标态，使用一个 CombinedState 的掩码描述，附带名字与优先级
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // 哪些组合状态能匹配到这个最终态（掩码含义由使用者定义）
    int priority = 0;         // 用于排序/选择最高最终态，数字越大优先级越高

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// MaskStateMachine: 管理 FinalState 注册与匹配逻辑
// 比较规则：优先级（越大越优先），若优先级相同，按 lexicographic（从 subs[0] ... subs[N-1]）比较 CombinedState 的数值大小（可视为“权重”）
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // widths: 每个子系统允许的位宽（用于 validate）
    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // 注册最终态（线程安全：建议在初始化阶段注册）
    void register_final(const FS& f) {
        // validate mask fits width
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // 返回当前状态匹配到的所有最终态（匹配策略可选）
    // match_mode:
    //   "contains" : final.mask is subset of current -> current.contains_all(final.mask)
    //   "overlaps_all_subsystems": each subsystem has at least one overlapping bit
    //   "overlaps_any": any subsystem overlap
    std::vector<FS> match_final_states(const CS& current, const std::string& match_mode = "contains") const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            if (match_mode == "contains") {
                ok = current.contains_all(f.mask);
            } else if (match_mode == "overlaps_all_subsystems") {
                ok = current.overlaps_all_subsystems(f.mask);
            } else if (match_mode == "overlaps_any") {
                ok = current.overlaps_any(f.mask);
            } else {
                throw std::invalid_argument("unknown match_mode");
            }
            if (ok) out.push_back(f);
        }
        // sort by priority desc, then by lexicographic mask desc (so highest first)
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
        });
        return out;
    }

    // 给定一组 CombinedState，从中选出“最高”的一个（依据与 finals 无关的纯比较）
    // 规则：先比较某个权重序列（priority_weights；如果不提供则按 subs 索引顺序作为显著性，从低索引更重要）
    // 返回 std::optional<CS> （如果输入为空则返回 std::nullopt）
    std::optional<CS> highest_of_set(const std::vector<CS>& set,
                                     const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // 计算带权值比较：对每个子系统，权 * value，加和比较（注意 uint64->unsigned long long）
                __int128 va = 0, vb = 0;
                for (size_t i = 0; i < N; ++i) {
                    va = va * (__int128(priority_weights->at(i) + 1)) + __int128(a.subs[i]);
                    vb = vb * (__int128(priority_weights->at(i) + 1)) + __int128(b.subs[i]);
                }
                return va > vb;
            } else {
                // 默认 lexicographic 从 subs[0] ... subs[N-1]，subs[0] 更重要（高位）
                return lexicographic_mask_cmp<N>(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) {
            if (cmp(set[i], *best)) best = &set[i];
        }
        return *best;
    }

    // 获取已注册的所有 FinalState（只读）
    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    // helper lexicographic comparator: 返回 >0 if a> b, 0 if equal, <0 if a<b
    template <size_t M>
    static int lexicographic_mask_cmp(const CombinedState<M>& a, const CombinedState<M>& b) {
        for (size_t i = 0; i < M; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// ----------------- 简短示例 -----------------
/*
假设有4个子系统（N=4），每个子系统用8位（0..7）来表示状态（最多 8 个可组合状态位）。
例如：
 - 子系统0 位0 表示 Ready，位1 表示 Busy，位2 表示 Error ...
 - 子系统1 的位表示其它子系统状态细分
*/
void example() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8}; // 每个子系统 8 位
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // 定义 final states：
    // Final A: 要求 子系统0 固定位0（0x1） && 子系统2 任意位（示例）
    CS finalA_mask = CS::from_array({{0x1, 0x0, 0xFF, 0x0}});
    m.register_final(FS("FinalA", finalA_mask, 10)); // priority 10

    // Final B:
    CS finalB_mask = CS::from_array({{0x2, 0x04, 0x00, 0x00}});
    m.register_final(FS("FinalB", finalB_mask, 5));

    // 当前组合状态（来自运行时）
    CS cur = CS::from_array({{0x3, 0x04, 0x01, 0x00}}); // sub0 bits 0 and 1, sub1 bit2, sub2 bit0

    // match finals by "contains"（即 cur 包含 final.mask）
    auto matches = m.match_final_states(cur, "contains");
    std::cout << "Matched finals (contains):\n";
    for (const auto& f : matches) {
        std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask.to_string() << "\n";
    }

    // 从一个组合状态集合中选最高
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest: " << highest->to_string() << "\n";
}
```

---

## 设计说明（为什么这样设计 & 如何使用）

### 1. 子系统 & 位宽

* 每个子系统用一个 `uint64_t` 存放位集合（因此每个子系统最多支持 64 个状态位）。整体 `CombinedState` 是 `std::array<uint64_t, N>`。
* 在 `MaskStateMachine` 构造时传入 `widths`（每个子系统位宽），用于在注册/验证时防止越界（例如你的例子 4 个子系统，每个 8 位，就是 `{8,8,8,8}`）。

### 2. 匹配语义（三种常见）

* `contains`：`current.contains_all(final.mask)` —— final.mask 的所有位都必须在 current 中（用于“必须完全满足某些必需位”的场景）；
* `overlaps_all_subsystems`：对每个子系统都要求至少有一个位重叠（用于“每个子系统都必须处于某个可接受状态”的场景）；
* `overlaps_any`：任意子系统有重叠即视为匹配（较宽松）。

你可以按需扩展更多匹配规则，例如“子系统 i 要求包含某个位集合并且子系统 j 要求至少有一位重叠”——可以把规则封装成对象/策略。

### 3. FinalState 与优先级

* `FinalState` 包含 `mask`、`name`、`priority`。匹配返回结果默认按 `priority` 降序排序；priority 相同则用 `lexicographic` 的掩码比较作为 tiebreaker（可改为其它策略）。

### 4. 从集合中选出“最高”组合状态

* `highest_of_set` 提供两种比较：默认按 lexicographic（从 subs\[0] 开始，越高越“更重要”），或提供 `priority_weights`（每个子系统的权值，用以合并比较）。
* 比较可根据实际业务调整：你可以把某个子系统当作“高权重”主导位。

### 5. 扩展性与线程安全

* 该实现把注册（`register_final`）与查询（`match_final_states`）分离。若需要并发环境：

  * 在启动阶段完成所有 `register_final`，之后只做只读 `match_final_states`（无需加锁）。
  * 若需运行时动态注册/注销，则在 `finals_` 上加互斥（或使用读写锁 / atomic shared\_ptr 替换 vector）以保证并发安全。

### 6. 关于“最高的组合状态”的另一种理解

* 有时“最高”并不是按位数值比较，而是“位的位置更高优先”或“包含更多位优先”。你可以定义 `CombinedState` 的 `score()` 函数来量化（例如加权和、位数计数、或某些关键位权重），然后在 `highest_of_set` 中使用这个 `score`。

---

## 使用场景举例（回到你之前提到的4个子系统，每个8位）

* 你可以把一个 32 位整型看成 4 个子系统各 8 位的集合，但更灵活的是把每个子系统独立为 `uint64_t`，这样当需要扩展到不均匀的位数（例如子系统0用8位、子系统1用12位）时也很方便。
* 示例中展示了如何注册两个 FinalState，并把当前状态匹配到能到达的 FinalState 列表中，按 priority 排序返回。

---

如果你愿意我可以：

* 把示例扩展为完整可运行的 demo（包含编译并运行的 `main()`）；
* 把 `match` 规则扩展为可配置的策略对象（策略模式），并演示如何基于 JSON 配置加载规则；
* 改用位字段拼接成单一大整数（比如在已知各子系统固定宽度时）以获得更快的比较；或改为可变宽度（runtime widths）并提供序列化/反序列化方法。

你想要哪个方向我就直接把代码补全成可编译的 demo（不再问 clarifying question）？


好——我明白你的规则：**“最高最终状态匹配”**的语义是：只要**任意一个子系统**当前状态能够单独匹配到某个最终态（按子系统级别的匹配规则），就把该最终态作为候选；在所有候选最终态中选择优先级最高的那个并返回。下面我把之前的实现扩展出一个清晰、可复用的方法 `highest_final_by_any_subsystem`，并给出示例和说明。

---

### 关键实现（在之前 `MaskStateMachine<N>` 类中加入）

```cpp
// 返回任意子系统级别能匹配到的最高 FinalState（按 priority -> lexicographic mask）
template <size_t N>
std::optional<FinalState<N>> highest_final_by_any_subsystem(
    const CombinedState<N>& current,
    const std::string& per_subsystem_match = "contains"    // "contains" 或 "overlaps"
) const {
    std::vector<FinalState<N>> candidates;
    candidates.reserve(finals_.size());

    for (const auto &f : finals_) {
        bool matched_by_some_sub = false;
        for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
            uint64_t cur_bits = current.subs[i];
            uint64_t final_bits = f.mask.subs[i];

            if (per_subsystem_match == "contains") {
                // 子系统 i 的所有 final_bits 都被 current.subs[i] 包含
                if ((cur_bits & final_bits) == final_bits && final_bits != 0) {
                    matched_by_some_sub = true;
                }
            } else if (per_subsystem_match == "overlaps") {
                // 子系统 i 存在任意 bit 重叠
                if ((cur_bits & final_bits) != 0) {
                    matched_by_some_sub = true;
                }
            } else {
                throw std::invalid_argument("unknown per_subsystem_match mode");
            }
        }
        if (matched_by_some_sub) candidates.push_back(f);
    }

    if (candidates.empty()) return std::nullopt;

    // 选择最高：按 priority 降序，然后按掩码字典序降序
    std::sort(candidates.begin(), candidates.end(), [](const FinalState<N>& a, const FinalState<N>& b){
        if (a.priority != b.priority) return a.priority > b.priority;
        return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
    });

    return candidates.front();
}
```

---

### 语义说明与可配置点

* `per_subsystem_match == "contains"`：当某个最终态的**在某个子系统上的要求位**被当前子系统状态**完全包含**时（即该子系统就足以满足该最终态在该子系统上的需求），就把该最终态作为候选。通常用在“final 的某些子系统位是必需位（must-have）”的语义下。
* `per_subsystem_match == "overlaps"`：只要某子系统有位与 final 在该子系统上的位**任意重叠**，就视为该子系统“能匹配到”这个 final。语义更宽松，适合“部分匹配也能触发更高态”的场景。
* 如果多个最终态都被某些子系统匹配到，函数会按 `priority`（更大优先）并以 lexicographic 掩码作为 tiebreaker 来选出**单个最高最终态**返回。
* 如果没有任何子系统匹配到任何 final，则返回 `std::nullopt`。

---

### 小示例（基于之前的 `example()`）

```cpp
// 在 example() 注册完 FinalA (prio 10) 和 FinalB (prio 5) 后：
CS cur = CS::from_array({{0x04, 0x00, 0x00, 0x00}}); // 只有子系统0的 bit2 被置位

// 假设 FinalC 的 mask 在子系统0 上为 0x04，priority = 20
CS finalC_mask = CS::from_array({{0x04,0x00,0x00,0x00}});
m.register_final(FS("FinalC", finalC_mask, 20));

// 使用子系统级别的 contains 匹配
auto best = m.highest_final_by_any_subsystem(cur, "contains");
if (best) {
    std::cout << "Best final by any subsystem: " << best->name
              << " (prio=" << best->priority << ")\n";
} else {
    std::cout << "No final matched by any single subsystem.\n";
}
```

在上面例子里，`cur` 的子系统0 包含 `FinalC` 在子系统0 上的位，因此 `FinalC` 会成为候选，且因其 priority=20 为最高被返回。

---

### 注意事项与建议

1. **子系统位语义要清晰**：决定使用 `contains` 还是 `overlaps`，取决于 final 的掩码如何定义（是“必需位”还是“提示位/部分匹配即可”）。
2. **避免误触发**：若某些 final 的掩码在多个子系统均为 0（即没有在某子系统上设置任何位），这会影响匹配逻辑；在实现里 `contains` 检查我额外排除了 `final_bits != 0` 的情形，避免把“空位”当成匹配条件，你也可以在 FinalState 定义阶段强制要求每个 final 在至少一个子系统上有非零位。
3. **并发**：此方法读取 `finals_`，若运行时可能动态注册/注销 final，请加锁或采用读写锁/原子替换容器策略。
4. **可扩展性**：如果你后来需要更复杂的规则（例如“某子系统匹配到 X 且另一个子系统匹配到 Y 时才视为候选”），建议把匹配规则拆成策略对象并在注册 final 时把规则一并注册。

---

如果你愿意我可以：

* 把上述方法合并进完整类并给出可编译的 `main()` demo；
* 或者直接把匹配规则变成策略模式（`PerSubsystemMatchPolicy`），并展示如何用 JSON 配置 final 的匹配策略（例如某 final 需要 `contains` 在子系统0 且 `overlaps` 在子系统2）。

你想要哪个（我直接把代码写成可编译 demo）？


我已把修改后的**完整、可编译 C++ 源文件**放到画布（名为 **Mask State Machine**）里，你可以在旁边查看/复制。下面是对代码能力的说明、设计注意点和可能的提示（prompt）修正建议 —— 便于你快速调整或让我继续迭代。

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// Mask State Machine - single-file demo
// C++17

// -------------------- CombinedState --------------------
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // Checks whether 'this' contains all bits from other
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // For each subsystem, there must be at least one overlapping bit
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // Any subsystem overlaps
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // Validate each subsystem does not use bits beyond 'widths'
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            int w = widths[i];
            if (w <= 0 || w > 64) throw std::invalid_argument("invalid width");
            if (w < 64) {
                uint64_t mask = ((uint64_t(1) << w) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << w;
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// -------------------- FinalState --------------------
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // mask that describes bits relevant for this final
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// -------------------- Match enums --------------------
enum class MatchMode {
    Contains,            // current contains final.mask
    OverlapsAllSubsystems,
    OverlapsAny
};

enum class PerSubsystemMatch {
    Contains, // per-subsystem: final_bits fully contained in current.subs[i]
    Overlaps  // per-subsystem: any overlap
};

// -------------------- MaskStateMachine --------------------
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // Register a final state (call validate on mask)
    void register_final(const FS& f) {
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // Match finals according to high-level MatchMode
    std::vector<FS> match_final_states(const CS& current, MatchMode mode = MatchMode::Contains) const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            switch (mode) {
                case MatchMode::Contains: ok = current.contains_all(f.mask); break;
                case MatchMode::OverlapsAllSubsystems: ok = current.overlaps_all_subsystems(f.mask); break;
                case MatchMode::OverlapsAny: ok = current.overlaps_any(f.mask); break;
                default: throw std::invalid_argument("unknown match mode");
            }
            if (ok) out.push_back(f);
        }
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return out;
    }

    // Highest final matched by any single subsystem (per-subsystem policy: Contains or Overlaps)
    std::optional<FS> highest_final_by_any_subsystem(const CS& current, PerSubsystemMatch policy = PerSubsystemMatch::Contains) const {
        std::vector<FS> candidates;
        candidates.reserve(finals_.size());

        for (const auto &f : finals_) {
            bool matched_by_some_sub = false;
            for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
                uint64_t cur_bits = current.subs[i];
                uint64_t final_bits = f.mask.subs[i];
                if (final_bits == 0) continue; // skip empty per-subsystem requirement
                if (policy == PerSubsystemMatch::Contains) {
                    if ((cur_bits & final_bits) == final_bits) matched_by_some_sub = true;
                } else { // Overlaps
                    if ((cur_bits & final_bits) != 0) matched_by_some_sub = true;
                }
            }
            if (matched_by_some_sub) candidates.push_back(f);
        }

        if (candidates.empty()) return std::nullopt;

        std::sort(candidates.begin(), candidates.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return candidates.front();
    }

    // From a set of CombinedState pick the highest according to optional priority weights (or lexicographic)
    std::optional<CS> highest_of_set(const std::vector<CS>& set, const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // compute weighted lexicographic-like comparison
                for (size_t i = 0; i < N; ++i) {
                    if (priority_weights->at(i) != 0) {
                        if (a.subs[i] != b.subs[i]) return a.subs[i] * priority_weights->at(i) > b.subs[i] * priority_weights->at(i);
                    }
                }
                return lexicographic_mask_cmp(a, b) > 0;
            } else {
                return lexicographic_mask_cmp(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (cmp(set[i], *best)) best = &set[i];
        return *best;
    }

    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    static int lexicographic_mask_cmp(const CS& a, const CS& b) {
        for (size_t i = 0; i < N; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// -------------------- Demo main --------------------
int main() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8};
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // Register some final states
    CS maskA = CS::from_array({{0x01, 0x00, 0xFF, 0x00}}); // final A needs sub0 bit0 and sub2 any
    CS maskB = CS::from_array({{0x02, 0x04, 0x00, 0x00}});
    CS maskC = CS::from_array({{0x04, 0x00, 0x00, 0x00}});

    m.register_final(FS("FinalA", maskA, 10));
    m.register_final(FS("FinalB", maskB, 5));
    m.register_final(FS("FinalC", maskC, 20));

    // Current state
    CS cur = CS::from_array({{0x04, 0x04, 0x01, 0x00}});

    // 1) match by "contains"
    auto matched_contains = m.match_final_states(cur, MatchMode::Contains);
    std::cout << "Matched (Contains):\n";
    for (auto &f : matched_contains) std::cout << "  " << f.name << " prio=" << f.priority << " mask=" << f.mask.to_string() << "\n";

    // 2) match by overlaps_any
    auto matched_any = m.match_final_states(cur, MatchMode::OverlapsAny);
    std::cout << "Matched (OverlapsAny):\n";
    for (auto &f : matched_any) std::cout << "  " << f.name << " prio=" << f.priority << "\n";

    // 3) highest final by any subsystem (contains)
    auto best_by_sub_contains = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Contains);
    if (best_by_sub_contains) std::cout << "Best by any-subsystem (Contains): " << best_by_sub_contains->name << " prio=" << best_by_sub_contains->priority << "\n";
    else std::cout << "No best final (Contains)\n";

    // 4) highest final by any subsystem (overlaps)
    auto best_by_sub_overlaps = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Overlaps);
    if (best_by_sub_overlaps) std::cout << "Best by any-subsystem (Overlaps): " << best_by_sub_overlaps->name << " prio=" << best_by_sub_overlaps->priority << "\n";
    else std::cout << "No best final (Overlaps)\n";

    // 5) highest of a set
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest of set: " << highest->to_string() << "\n";

    return 0;
}

```

# 能力概览（代码提供的功能）

* 支持任意数量子系统（模板参数 `N`），每个子系统用 `uint64_t` 保存位掩码。
* 每个子系统可配置位宽（在 `MaskStateMachine` 构造时传入 `widths`），会在注册 `FinalState` 时做验证以防越界。
* `CombinedState` 提供常用操作：

  * 位或（`|`）、位与（`&`）、相等比较；
  * `contains_all`（当前包含另一个掩码的所有位）；
  * `overlaps_all_subsystems`（每个子系统都有至少一个重叠位）；
  * `overlaps_any`（任意子系统有重叠）；
  * `validate_widths` 与 `to_string`（调试友好）。
* `FinalState`：包含 `name`、`mask` 和 `priority`。
* `MaskStateMachine` 提供：

  * `register_final()`：注册最终态（并验证掩码合法性）；
  * `match_final_states(current, MatchMode)`：按三种高层匹配模式返回所有匹配的最终态，按 `priority`（降序）和掩码字典序排序；
  * `highest_final_by_any_subsystem(current, PerSubsystemMatch)`：实现你要求的“**只要任意一个子系统能够匹配到更高的最终态，就返回该最终态**”策略；支持两种子系统级别策略：`Contains`（子系统必须完全包含 final 在该子系统的位）和 `Overlaps`（任意重叠即可）；
  * `highest_of_set(...)`：从一组 `CombinedState` 里选最高项（默认字典序，或用可选的权重向量来自定义比较）。
* 含一个 `main()` 演示：注册若干 Final、演示三类匹配、演示“最高最终态匹配（按任意子系统）”、演示从集合选择最高组合状态。

# 设计与行为细节（重要）

* **优先级决定最终态优先顺序**：`priority` 数字越大越优先；相同优先级时使用掩码字典序（从 `subs[0]` 到 `subs[N-1]`）作为 tiebreaker。
* 在 `highest_final_by_any_subsystem` 内，默认跳过 `final.mask` 在某子系统上的空位（`final_bits == 0`），以避免把“没有要求”的子系统当成匹配触发器。
* `PerSubsystemMatch::Contains` 更严格（用于 final 在某子系统上定义了必需位）；`Overlaps` 更宽松（用于提示/模糊匹配）。
* 当前代码对 `finals_` 的注册和查询**未**做并发保护：推荐在初始化阶段完成注册，之后读取即可无锁使用；如果需要运行时动态注册/注销，请用互斥/读写锁或用 `std::shared_ptr<std::vector<...>>` 原子替换策略。

# 可选改进点（我可以帮助实现任意一项）

* 把 `MatchMode` / `PerSubsystemMatch` 做成策略对象（策略模式），使每个 `FinalState` 能携带自定义匹配策略（例如：finalA 用 `contains`，finalB 用 `overlaps`）。
* 支持按子系统组合的更复杂规则（例如：final 要求 `sub0` contains X **且** (`sub1` overlaps Y **或** `sub2` contains Z））。可通过注册时附带布尔表达式或小型规则树实现。
* 动态注册/注销：增加 `std::mutex` 或 `std::shared_mutex` 保护 `finals_`，或使用无锁读多写少的原子交换容器。
* 序列化/反序列化：把 final 状态列表导出为 JSON（便于 UI），并可以从 JSON 恢复。
* 性能优化：当 N 很大或 final 很多时，可建立索引（例如按子系统位建立倒排表）以加速 `highest_final_by_any_subsystem` 的查找。
* 增加单元测试和 fuzz 测试示例，确保匹配语义在边界位（如位宽边界、mask 全 0）时符合预期。

# 测试与验证建议（快速检查点）

* 测试 `Contains` 与 `Overlaps` 在边界位：例如 final.mask 在某子系统为 `0`（应被视作无要求）；
* 测试多个 final 同时满足条件：优先级较大的应被返回；
* 测试 `highest_of_set` 的比较策略是否符合你的业务（如果不是，告诉我你期望如何比较）。
* 测试在 N、各子系统宽度与 mask 较大时是否越界（构造非法 mask 应抛异常）。

# 如何提示我改动（示例 prompt 模板）

* 如果你想我把“每个 final 携带自己的匹配策略”实现成策略对象：`请把 FinalState 扩展为包含一个匹配策略对象，并在 register_final 时允许传入 lambda 或策略类型。给出完整代码。`
* 要我把注册线程安全化并实现运行时注销：`请把 MaskStateMachine 修改为线程安全，支持 register 和 unregister（根据 name），并给出使用示例。`
* 要我把匹配模式从 enum 改成可由 JSON 指定：`请实现从 JSON 加载 final 列表，并支持 per-final 指定 \"per_subsystem_match\": \"contains\"/\"overlaps\"。给出示例 JSON 与完整代码。`
* 如果你想改变 tiebreaker（比如“包含更多位优先而不是掩码字典序”）：`请修改排序规则使得优先级相同的 final 中包含位数更多的 final 优先；如果位数相同再用字典序。`

---

如果你希望，我可以直接按你选中的改动把源文件更新为新的版本（我会把改动后的完整源码放到画布并在此说明）。你想现在先让我把哪个改进/调整实现为可编译 demo？



```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>

// Enum-based Mask State Machine
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// CombinedState: holds one enum value per subsystem
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }

private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << to_underlying(std::get<I>(subs)) ) ) );
    }
};

// ------------------------------------------------------
// FinalState: each subsystem may be optional (std::nullopt means "don't care")
// ------------------------------------------------------
template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<std::optional<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // optional per-subsystem requirement
    int priority = 0;

    FinalState() = default;

    FinalState(std::string n, MaskTuple m, int p = 0)
        : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), (std::get<I>(mask).has_value() ? (oss << "sub"<<I<<":"<< to_underlying(*std::get<I>(mask))) : (oss << "sub"<<I<<":-")) ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // register final state (call during init)
    void register_final(const FS& f) {
        finals_.push_back(f);
    }

    // match all finals that fully match the current CombinedState (every non-empty mask entry equals the current value)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem (i.e., any subsystem value equals that final's requirement for that subsystem)
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem (useful for debugging)
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS>& finals() const { return finals_; }

private:
    std::vector<FS> finals_;

    // full-match: for all indexes: either final.mask is nullopt or equal to cur.subs
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void)( ok = ok && ( !std::get<I>(f.mask).has_value() || *std::get<I>(f.mask) == std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where final.mask == current.subs (and mask not nullopt)
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).has_value() && *std::get<I>(f.mask) == std::get<I>(cur.subs) ) ) ));
        return triggered;
    }

    // compare CombinedState lexicographically by underlying enum integer values
    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    // sort finals by priority desc, then by mask lexicographic desc (higher underlying values first)
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [this](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    // compare masks lexicographically where nullopt is treated as lowest
    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }
    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_opt(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    template <typename E>
    static int compare_opt(const std::optional<E> &a, const std::optional<E> &b) {
        if (a.has_value() && b.has_value()) {
            auto ua = to_underlying(*a);
            auto ub = to_underlying(*b);
            if (ua == ub) return 0; return ua > ub ? 1 : -1;
        }
        if (a.has_value()) return 1;   // has value considered > no-value
        if (b.has_value()) return -1;
        return 0;
    }
};

// ------------------------------------------------------
// Example enums and demo usage
// ------------------------------------------------------
enum class EngineState { Idle = 0, Running = 1, Error = 2 };
enum class NetworkState { Disconnected = 0, Connecting = 1, Connected = 2 };
enum class PowerState { Off = 0, On = 1 };
enum class SensorState { OK = 0, Warn = 1, Fail = 2 };

int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals. For masks use std::make_tuple with std::optional values (std::nullopt == don't care)
    // Final: Engine Running, any network, Power On, any sensor
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        std::optional<EngineState>(EngineState::Running),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(PowerState::On),
        std::optional<SensorState>(std::nullopt)
    ), 10));

    // Final: Network Connected (regardless other subsystems), highest priority
    sm.register_final(FS("NetworkConnected", std::make_tuple(
        std::optional<EngineState>(std::nullopt),
        std::optional<NetworkState>(NetworkState::Connected),
        std::optional<PowerState>(std::nullopt),
        std::optional<SensorState>(std::nullopt)
    ), 30));

    // Final: Sensor Fail (alerts)
    sm.register_final(FS("SensorFail", std::make_tuple(
        std::optional<EngineState>(std::nullopt),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(std::nullopt),
        std::optional<SensorState>(SensorState::Fail)
    ), 20));

    // Final: Engine Error + Power On (combined)
    sm.register_final(FS("EngineError_Powered", std::make_tuple(
        std::optional<EngineState>(EngineState::Error),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(PowerState::On),
        std::optional<SensorState>(std::nullopt)
    ), 25));

    // Current state example
    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);
    std::cout << "Current: " << cur.to_string() << "
";

    // 1) All finals that fully match current
    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    // 2) All finals that match any subsystem
    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    // 3) Highest final triggered by any single subsystem
    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // 4) Highest of a set of CombinedState
    std::vector<CS> set = { CS(EngineState::Idle, NetworkState::Disconnected, PowerState::Off, SensorState::OK),
                            CS(EngineState::Running, NetworkState::Connected, PowerState::On, SensorState::Warn),
                            CS(EngineState::Error, NetworkState::Connecting, PowerState::On, SensorState::Fail) };
    auto h = sm.highest_of_set(set);
    if (h) std::cout << "Highest of set: " << h->to_string() << "
";

    return 0;
}

```

我已把 **完整修改后的枚举版源码** 更新到画布（文件名仍为 **Mask State Machine**）。你可以在画布中查看/运行该文件。下面是对修改点、能力和如何提示我继续改进的简短说明 — 方便你直接给出修改指示。

## 本次主要改动（概要）

* 把“子系统状态为位掩码”的实现，全面改为**每个子系统由 enum 表示**（类型安全、易读）。
* `CombinedState` 现在是 `std::tuple<Enum...>`，每个子系统仅能处于单一枚举值。
* `FinalState` 的掩码为 `std::tuple<std::optional<Enum>...>`：`nullopt` 表示该子系统**不关心**。
* 提供核心接口：

  * `match_full_all(cur)`：返回与当前状态完全匹配（所有非空字段相等）的最终态集合（按优先级排序）。
  * `match_by_any_subsystem_all(cur)`：返回至少在一个子系统匹配的最终态集合。
  * `highest_final_by_any_subsystem(cur)`：实现你要的“只要任意子系统能匹配到更高最终态就返回它”的策略（返回优先级最高的那个）。
  * `highest_of_set(...)`：从若干 `CombinedState` 中选出“最高”的一个（按枚举底层值的字典序）。
* 增加打印（`to_string()` / `mask_to_string()`）用于调试与展示。
* 附带 `main()` 演示：定义 4 个子系统枚举（Engine/Network/Power/Sensor），注册若干 FinalState，并演示各种匹配结果。

## 能力与语义说明（快速参考）

* Final 的优先级 (`priority`) 决定冲突时哪个先返回；优先级相同时按掩码字典序比较（有值视为大于无值）。
* `highest_final_by_any_subsystem` 的语义：只要**某个子系统**的当前枚举值与某 Final 在该子系统的要求相等（且该 Final 在该子系统上有要求），该 Final 即被视作候选；在所有候选中返回 `priority` 最大的。
* 设计便于扩展：你可让 FinalState 的掩码更复杂（支持集合、多值、条件表达式）——我可以帮你把 mask 从 `optional<Enum>` 扩展为 `std::vector<Enum>`（允许一组可接受值）或一个小规则表达式树。

## 进一步改进建议（你可以直接挑一项让我实现）

* 让 FinalState 在每个子系统上支持**多个可接受枚举值**（例如子系统0 可接受 {Idle, Running}）；
* 支持 per-Final 自定义匹配策略（例如某个 Final 对子系统0 用“equals”，对子系统1 用“in set”或“negation”）——策略对象或 lambda 的方式；
* 运行时的注册/注销线程安全（添加 `std::shared_mutex`）；
* 把 FinalState 列表导入/导出为 JSON（方便 UI 配置），以及从 JSON 创建 `FinalState`（我可以加入 `nlohmann::json` 示例）；
* 把枚举到字符串的映射（更可读的打印）自动化（通过宏或映射表）。

告诉我你想继续哪一项（例如：`把每个 final 的每个子系统改为支持一组可接受枚举值`），我会直接在画布把文件改好并在此说明改动细节。


```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>
#include <functional>
#include <shared_mutex>
#include <unordered_set>

// Enum-based Mask State Machine (advanced)
// - Each subsystem uses an enum type (defined via X-macro for automatic string mapping)
// - FinalState supports per-subsystem multi-value matching (sets) and custom predicates
// - Per-Final per-subsystem matching policies via SubMatcher
// - Thread-safe register/unregister using std::shared_mutex
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// X-macro helper to declare enums with string mapping
// Usage:
// #define LIST 
 X(Idle) 
 X(Running)
// DECLARE_ENUM_WITH_STRINGS(EngineState, LIST)
// ------------------------------------------------------
#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST)                 \
    enum class NAME {                                       \
        LIST(ENUM_DECLARE_ELEM)                             \
    };                                                      \
    inline const char* to_string(NAME v) {                  \
        static const char* _names[] = { LIST(ENUM_STRING_ELEM) }; \
        auto idx = static_cast<size_t>(to_underlying(v));   \
        return _names[idx];                                 \
    }

#define ENUM_DECLARE_ELEM(x) x,
#define ENUM_STRING_ELEM(x) #x,

// Helper to expand list macro style
// We'll require lists to be provided as a macro that takes one macro argument
// Example:
// #define ENGINE_STATE_LIST(M) M(Idle) M(Running) M(Error)

// ------------------------------------------------------
// SubMatcher: per-subsystem matching policy and accepted values
// ------------------------------------------------------
template <typename E>
struct SubMatcher {
    // kinds of matcher
    enum class Kind { Any, Equals, InSet, NotEquals, NotInSet, Predicate };

    Kind kind = Kind::Any;
    std::vector<E> values; // used for Equals (single) or InSet
    std::function<bool(E)> pred; // used for Predicate

    SubMatcher() = default;
    static SubMatcher Any() { return SubMatcher(); }
    static SubMatcher Equals(E v) { SubMatcher m; m.kind = Kind::Equals; m.values = {v}; return m; }
    static SubMatcher InSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::InSet; m.values = vs; return m; }
    static SubMatcher NotEquals(E v) { SubMatcher m; m.kind = Kind::NotEquals; m.values = {v}; return m; }
    static SubMatcher NotInSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::NotInSet; m.values = vs; return m; }
    static SubMatcher Predicate(std::function<bool(E)> p) { SubMatcher m; m.kind = Kind::Predicate; m.pred = std::move(p); return m; }

    bool matches(E cur) const {
        switch (kind) {
            case Kind::Any: return true;
            case Kind::Equals: return !values.empty() && cur == values[0];
            case Kind::InSet: return std::any_of(values.begin(), values.end(), [&](E v){ return v == cur; });
            case Kind::NotEquals: return !values.empty() && cur != values[0];
            case Kind::NotInSet: return !std::any_of(values.begin(), values.end(), [&](E v){ return v == cur; });
            case Kind::Predicate: return pred ? pred(cur) : false;
            default: return false;
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        switch (kind) {
            case Kind::Any: oss << "Any"; break;
            case Kind::Equals: oss << "= " << to_underlying(values[0]); break;
            case Kind::InSet: {
                oss << "in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::NotEquals: oss << "!= " << to_underlying(values[0]); break;
            case Kind::NotInSet: {
                oss << "not_in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::Predicate: oss << "pred(...)"; break;
        }
        return oss.str();
    }
};

// ------------------------------------------------------
// CombinedState: holds one enum value per subsystem
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << to_string(std::get<I>(subs)) ) ) );
    }
};

// ------------------------------------------------------
// FinalState: each subsystem represented by SubMatcher<E>
// ------------------------------------------------------
template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<SubMatcher<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // per-subsystem matcher
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, MaskTuple m, int p = 0) : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub"<<I<<":"<< std::get<I>(mask).to_string() ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic with thread-safety
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // Register final state (thread-safe)
    void register_final(const FS& f) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        finals_.push_back(f);
    }

    // Unregister final state by name (thread-safe)
    bool unregister_final(const std::string& name) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        auto it = std::remove_if(finals_.begin(), finals_.end(), [&](const FS &f){ return f.name == name; });
        if (it == finals_.end()) return false;
        finals_.erase(it, finals_.end());
        return true;
    }

    // match all finals that fully match the current CombinedState (every subsystem matcher returns true)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS> snapshot_finals() const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        return finals_;
    }

private:
    mutable std::shared_mutex mu_;
    std::vector<FS> finals_;

    // full-match: for all indexes: matcher.matches(cur.subs[index]) must be true
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void) ( ok = ok && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where matcher.matches(cur.subs[index]) is true and matcher is not Any
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).kind != SubMatcher<typename std::tuple_element<I, std::tuple<Subsystems...>>::type>::Kind::Any && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ) ));
        return triggered;
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    // sort finals by priority desc, then by mask specificity/lexicographic desc
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_submatcher(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }

    // compare two SubMatcher<E>
    template <typename E>
    static int compare_submatcher(const SubMatcher<E> &a, const SubMatcher<E> &b) {
        // Specificity ranking: Predicate > Equals > InSet (larger set considered more specific by size) > NotEquals/NotInSet > Any
        auto rank = [](typename SubMatcher<E>::Kind k) {
            switch (k) {
                case SubMatcher<E>::Kind::Predicate: return 5;
                case SubMatcher<E>::Kind::Equals: return 4;
                case SubMatcher<E>::Kind::InSet: return 3;
                case SubMatcher<E>::Kind::NotEquals: return 2;
                case SubMatcher<E>::Kind::NotInSet: return 1;
                case SubMatcher<E>::Kind::Any: return 0;
            }
            return 0;
        };
        int ra = rank(a.kind), rb = rank(b.kind);
        if (ra != rb) return ra > rb ? 1 : -1;
        // same kind -> tiebreaker by underlying values (if available)
        if (a.kind == SubMatcher<E>::Kind::Equals || a.kind == SubMatcher<E>::Kind::NotEquals) {
            if (!a.values.empty() && !b.values.empty()) {
                auto ua = to_underlying(a.values[0]);
                auto ub = to_underlying(b.values[0]);
                if (ua == ub) return 0; return ua > ub ? 1 : -1;
            }
            return 0;
        }
        if (a.kind == SubMatcher<E>::Kind::InSet || a.kind == SubMatcher<E>::Kind::NotInSet) {
            size_t sa = a.values.size();
            size_t sb = b.values.size();
            if (sa != sb) return sa > sb ? 1 : -1; // larger set considered more specific
            // otherwise lexicographic by underlying
            for (size_t i = 0; i < sa; ++i) {
                auto ua = to_underlying(a.values[i]);
                auto ub = to_underlying(b.values[i]);
                if (ua != ub) return ua > ub ? 1 : -1;
            }
            return 0;
        }
        // Predicate or Any -> equal
        return 0;
    }
};

// ------------------------------------------------------
// Example enums using X-macro lists and automatic to_string
// ------------------------------------------------------
#define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
#define NETWORK_LIST(M) M(Disconnected) M(Connecting) M(Connected)
#define POWER_LIST(M) M(Off) M(On)
#define SENSOR_LIST(M) M(OK) M(Warn) M(Fail)

DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
DECLARE_ENUM_WITH_STRINGS(NetworkState, NETWORK_LIST)
DECLARE_ENUM_WITH_STRINGS(PowerState, POWER_LIST)
DECLARE_ENUM_WITH_STRINGS(SensorState, SENSOR_LIST)

// For convenient printing of enum values when used in CombinedState::to_string, we rely on to_string(enum) overloads above.

// ------------------------------------------------------
// Demo usage
// ------------------------------------------------------
int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals with various per-subsystem multi-value matchers and custom predicate
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        SubMatcher<EngineState>::InSet({EngineState::Running}),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Equals(PowerState::On),
        SubMatcher<SensorState>::Any()
    ), 10));

    sm.register_final(FS("NetworkConnected", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Equals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 30));

    sm.register_final(FS("SensorFailOrWarn", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::InSet({SensorState::Fail, SensorState::Warn})
    ), 20));

    // final with custom predicate: engine underlying value >= Running (example predicate)
    sm.register_final(FS("EngineAtLeastRunning", std::make_tuple(
        SubMatcher<EngineState>::Predicate([](EngineState e){ return to_underlying(e) >= to_underlying(EngineState::Running); }),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 15));

    // Complex final: Engine Error but network not connected
    sm.register_final(FS("EngineError_NetNotConnected", std::make_tuple(
        SubMatcher<EngineState>::Equals(EngineState::Error),
        SubMatcher<NetworkState>::NotEquals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 25));

    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);

    std::cout << "Current: " << cur.to_string() << "
";

    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // Demonstrate unregister
    sm.unregister_final("NetworkConnected");
    std::cout << "After unregistering NetworkConnected, any-subsystem matches:
";
    any = sm.match_by_any_subsystem_all(cur);
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    return 0;
}

```

已完成 —— 我把你的要求全部实现并将完整源码更新到画布（Mask State Machine）。新版本具备：

* 每个 FinalState 在每个子系统上支持**多个可接受枚举值**（`InSet`），也支持 `Equals`、`NotEquals`、`NotInSet`。
* 支持**自定义 predicate**（`Predicate`）用于任意复杂判断。
* 使用 `SubMatcher<E>` 封装每个子系统的匹配策略（易于扩展）。
* 对 `finals_` 的注册/注销和匹配操作使用 `std::shared_mutex` 保护（读多写少友好）。
* 枚举与字符串映射通过 X-macro + `DECLARE_ENUM_WITH_STRINGS` 自动生成 `to_string(enum)`，用于更友好的输出。
* 示例 `main()` 展示如何注册各种 FinalState、匹配、以及运行时注销。

如果你想要我做下一步改进，我可以直接在画布里改动代码（例如：把 `SubMatcher::values` 内部使用有序 set 以便比较稳定、把排序策略改为按“命中更多子系统优先”、或将最终态从内存导出为 JSON）。你想我先做哪一项？


已按你的要求移除 X-macro，并把枚举与字符串映射改为显式定义（每个 `enum` 对应一个 `to_string(enum)` 函数）。我已把修改后的完整源码更新到画布。

改动摘要：

* 删除了 X-macro 宏方式，改为每个枚举显式定义 `to_string()`。
* 保留了所有功能：多值匹配（`InSet`）、自定义 predicate、Per-Final 子系统匹配策略（`SubMatcher`）、线程安全注册/注销（`std::shared_mutex`）以及排序/优先级逻辑。
* `CombinedState::to_string()` 现在调用全局 `to_string(enum)` 函数（请确保新加入的 enum 类型都实现相应 `to_string()`）。

接下来我可以：

* 把 `to_string(enum)` 的实现改为返回 `std::string`（目前返回 `const char*`），如果你需要 Unicode 或本地化支持也可以扩展；
* 把 `SubMatcher::values` 存储为 `std::unordered_set`（用于快速 membership 测试）并调整比较逻辑；
* 增加序列化（JSON）接口以导出/导入 FinalState（方便 UI 编辑）；
* 添加单元测试或更详细示例（包括一些边界测试）。

你想我先做哪一项？

```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>
#include <functional>
#include <shared_mutex>
#include <unordered_set>

// Enum-based Mask State Machine (macro-assisted)
// - Uses X-style LIST macros to declare enums + automatic to_string mapping
// - FinalState supports per-subsystem multi-value matching (InSet) and custom predicates
// - Per-Final per-subsystem matching policies via SubMatcher
// - Thread-safe register/unregister using std::shared_mutex
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// X-macro enum helper
// LIST must be a macro that accepts another macro M and expands M(x) for each enumerator x.
// Example:
// #define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
// DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
// ------------------------------------------------------
#define ENUM_DECLARE_ELEM(x) x,
#define ENUM_STRING_ELEM(x) #x,

#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST)                                 \
    enum class NAME { LIST(ENUM_DECLARE_ELEM) };                              \
    inline const char* to_string(NAME v) {                                    \
        static const char* _names[] = { LIST(ENUM_STRING_ELEM) };              \
        auto idx = static_cast<size_t>(to_underlying(v));                     \
        return (idx < sizeof(_names)/sizeof(_names[0])) ? _names[idx] : "Unknown"; \
    }

// ------------------------------------------------------
// SubMatcher: per-subsystem matching policy and accepted values (optimized)
// - values are stored in both vector (deterministic order) and unordered_set (O(1) match)
// ------------------------------------------------------
template <typename E>
struct SubMatcher {
    enum class Kind { Any, Equals, InSet, NotEquals, NotInSet, Predicate };

    Kind kind = Kind::Any;
    std::vector<E> values; // deterministic order for comparison
    std::unordered_set<std::underlying_type_t<E>> setvals; // for fast membership (store underlying)
    std::function<bool(E)> pred; // used for Predicate

    SubMatcher() = default;
    static SubMatcher Any() { return SubMatcher(); }
    static SubMatcher Equals(E v) { SubMatcher m; m.kind = Kind::Equals; m.values = {v}; m.setvals.insert(to_underlying(v)); return m; }
    static SubMatcher InSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::InSet; m.values = vs; for (auto &x: m.values) m.setvals.insert(to_underlying(x)); std::sort(m.values.begin(), m.values.end(), [](E a,E b){return to_underlying(a)<to_underlying(b);}); return m; }
    static SubMatcher NotEquals(E v) { SubMatcher m; m.kind = Kind::NotEquals; m.values = {v}; m.setvals.insert(to_underlying(v)); return m; }
    static SubMatcher NotInSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::NotInSet; m.values = vs; for (auto &x: m.values) m.setvals.insert(to_underlying(x)); std::sort(m.values.begin(), m.values.end(), [](E a,E b){return to_underlying(a)<to_underlying(b);}); return m; }
    static SubMatcher Predicate(std::function<bool(E)> p) { SubMatcher m; m.kind = Kind::Predicate; m.pred = std::move(p); return m; }

    bool matches(E cur) const {
        switch (kind) {
            case Kind::Any: return true;
            case Kind::Equals: return !values.empty() && cur == values[0];
            case Kind::InSet: return setvals.find(to_underlying(cur)) != setvals.end();
            case Kind::NotEquals: return !values.empty() && cur != values[0];
            case Kind::NotInSet: return setvals.find(to_underlying(cur)) == setvals.end();
            case Kind::Predicate: return pred ? pred(cur) : false;
            default: return false;
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        switch (kind) {
            case Kind::Any: oss << "Any"; break;
            case Kind::Equals: oss << "= " << to_underlying(values[0]); break;
            case Kind::InSet: {
                oss << "in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::NotEquals: oss << "!= " << to_underlying(values[0]); break;
            case Kind::NotInSet: {
                oss << "not_in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::Predicate: oss << "pred(...)"; break;
        }
        return oss.str();
    }
};

// ------------------------------------------------------
// CombinedState and FinalState (same structure as before)
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << ::to_string(std::get<I>(subs)) ) ) );
    }
};

template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<SubMatcher<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // per-subsystem matcher
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, MaskTuple m, int p = 0) : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub"<<I<<":"<< std::get<I>(mask).to_string() ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic with thread-safety
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // Register final state (thread-safe)
    void register_final(const FS& f) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        finals_.push_back(f);
    }

    // Unregister final state by name (thread-safe)
    bool unregister_final(const std::string& name) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        auto it = std::remove_if(finals_.begin(), finals_.end(), [&](const FS &f){ return f.name == name; });
        if (it == finals_.end()) return false;
        finals_.erase(it, finals_.end());
        return true;
    }

    // match all finals that fully match the current CombinedState (every subsystem matcher returns true)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS> snapshot_finals() const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        return finals_;
    }

private:
    mutable std::shared_mutex mu_;
    std::vector<FS> finals_;

    // full-match: for all indexes: matcher.matches(cur.subs[index]) must be true
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void) ( ok = ok && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where matcher.matches(cur.subs[index]) is true and matcher is not Any
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).kind != SubMatcher<typename std::tuple_element<I, std::tuple<Subsystems...>>::type>::Kind::Any && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ) ));
        return triggered;
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    // sort finals by priority desc, then by mask specificity/lexicographic desc
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_submatcher(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }

    // compare two SubMatcher<E>
    template <typename E>
    static int compare_submatcher(const SubMatcher<E> &a, const SubMatcher<E> &b) {
        // Specificity ranking: Predicate > Equals > InSet (larger set considered more specific by size) > NotEquals/NotInSet > Any
        auto rank = [](typename SubMatcher<E>::Kind k) {
            switch (k) {
                case SubMatcher<E>::Kind::Predicate: return 5;
                case SubMatcher<E>::Kind::Equals: return 4;
                case SubMatcher<E>::Kind::InSet: return 3;
                case SubMatcher<E>::Kind::NotEquals: return 2;
                case SubMatcher<E>::Kind::NotInSet: return 1;
                case SubMatcher<E>::Kind::Any: return 0;
            }
            return 0;
        };
        int ra = rank(a.kind), rb = rank(b.kind);
        if (ra != rb) return ra > rb ? 1 : -1;
        // same kind -> tiebreaker by underlying values (if available)
        if (a.kind == SubMatcher<E>::Kind::Equals || a.kind == SubMatcher<E>::Kind::NotEquals) {
            if (!a.values.empty() && !b.values.empty()) {
                auto ua = to_underlying(a.values[0]);
                auto ub = to_underlying(b.values[0]);
                if (ua == ub) return 0; return ua > ub ? 1 : -1;
            }
            return 0;
        }
        if (a.kind == SubMatcher<E>::Kind::InSet || a.kind == SubMatcher<E>::Kind::NotInSet) {
            size_t sa = a.values.size();
            size_t sb = b.values.size();
            if (sa != sb) return sa > sb ? 1 : -1; // larger set considered more specific
            // otherwise lexicographic by underlying
            for (size_t i = 0; i < sa; ++i) {
                auto ua = to_underlying(a.values[i]);
                auto ub = to_underlying(b.values[i]);
                if (ua != ub) return ua > ub ? 1 : -1;
            }
            return 0;
        }
        // Predicate or Any -> equal
        return 0;
    }
};

// ------------------------------------------------------
// Example enums using X-macro lists and automatic to_string
// ------------------------------------------------------
#define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
#define NETWORK_LIST(M) M(Disconnected) M(Connecting) M(Connected)
#define POWER_LIST(M) M(Off) M(On)
#define SENSOR_LIST(M) M(OK) M(Warn) M(Fail)

DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
DECLARE_ENUM_WITH_STRINGS(NetworkState, NETWORK_LIST)
DECLARE_ENUM_WITH_STRINGS(PowerState, POWER_LIST)
DECLARE_ENUM_WITH_STRINGS(SensorState, SENSOR_LIST)

// ------------------------------------------------------
// Demo usage
// ------------------------------------------------------
int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals with various per-subsystem multi-value matchers and custom predicate
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        SubMatcher<EngineState>::InSet({EngineState::Running}),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Equals(PowerState::On),
        SubMatcher<SensorState>::Any()
    ), 10));

    sm.register_final(FS("NetworkConnected", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Equals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 30));

    sm.register_final(FS("SensorFailOrWarn", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::InSet({SensorState::Fail, SensorState::Warn})
    ), 20));

    // final with custom predicate: engine underlying value >= Running (example predicate)
    sm.register_final(FS("EngineAtLeastRunning", std::make_tuple(
        SubMatcher<EngineState>::Predicate([](EngineState e){ return to_underlying(e) >= to_underlying(EngineState::Running); }),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 15));

    // Complex final: Engine Error but network not connected
    sm.register_final(FS("EngineError_NetNotConnected", std::make_tuple(
        SubMatcher<EngineState>::Equals(EngineState::Error),
        SubMatcher<NetworkState>::NotEquals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 25));

    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);

    std::cout << "Current: " << cur.to_string() << "
";

    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // Demonstrate unregister
    sm.unregister_final("NetworkConnected");
    std::cout << "After unregistering NetworkConnected, any-subsystem matches:
";
    any = sm.match_by_any_subsystem_all(cur);
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    return 0;
}


```

已根据你的意见把代码改为\*\*结合宏（X-macro 列表）\*\*的更优实现，并把完整源码更新到画布。主要变化与优势：

* 使用 `DECLARE_ENUM_WITH_STRINGS(NAME, LIST)` + `LIST(M)` 形式的 X-macro 列表自动生成 `enum class` 和 `to_string(enum)`，极大减少人为抄写 enum → 字符串映射的样板代码。
* `SubMatcher` 内部同时维护 `std::vector<E>`（用于可预测的比较）和 `std::unordered_set<underlying>`（用于快速 membership 测试），兼顾性能与确定性。
* 保持并完善了之前的特性：多值匹配（InSet）、自定义 predicate、per-final 子系统匹配策略、线程安全注册/注销（`std::shared_mutex`）、优先级排序逻辑。
* 示例展示如何用 LIST 宏定义 enums（Engine/Network/Power/Sensor）并注册多种 FinalState。

如果你想，我可以再做：

* 生成 `from_string()` 或 `parse_enum()`（方便从配置加载字符串）；
* 将 FinalState 列表导出/导入为 JSON（便于 UI 编辑），并示例如何从 JSON 构造 `SubMatcher`（需要选 JSON 库，例如 nlohmann::json）；
* 把 `SubMatcher` 的比较逻辑改为“命中子系统数量”优先（如果你更关心匹配的覆盖度而不是掩码具体值）；
* 提供单元测试或更详尽示例（边界条件、并发注册/匹配演示）。

要我继续做哪一项，我会直接把代码在画布上改好并说明改动细节。



下面给出一个重新设计的方案，适合你后续扩展和精细控制的需求，重点特性：

### 设计目标

1. **子系统数量可扩展**：目前4个子系统，将来容易增加。
2. **每个子系统有两类状态**：

   * **Stable state**：可持久存在。
   * **Temporary state**：瞬时/临时状态。
3. **组合映射**：不同子系统的不同状态组合映射到一个最终稳定状态（Final Stable State）。
4. **允许一个子系统在组合中出现多个状态**（即同一子系统在一个组合里可以同时存在 stable 和 temporary 状态）。
5. **不能简单用掩码**：有些组合不允许，需要有 **例外集合 (except)**，在匹配时剔除这些组合。
6. **线程安全**：后续可加上 `std::shared_mutex` 做并发安全。
7. **可读性**：使用 X-macro 生成 enum 和字符串映射，方便扩展。

---

### 设计思路

1. **状态表示**：

   * 每个子系统的 stable/temporary 状态用 `enum class` 表示。
   * X-macro 生成枚举及字符串映射。
   * 通过 `std::set` 来支持一个子系统多个状态共存。
2. **组合状态**：

   * 用 `struct SubsystemState { std::set<Stable>, std::set<Temp> };` 表示一个子系统当前状态。
   * 用 `CombinedState` (tuple) 表示所有子系统的组合。
3. **最终状态映射**：

   * `FinalMapping` 包含：

     * `std::tuple<Matcher...>`，每个子系统一个 Matcher，内部是 stable/temporary 状态集合。
     * 可选自定义匹配策略（lambda）。
   * `except`：一个全局或 per-Final 的“禁止组合集合”，用于排除不合法组合。
4. **匹配逻辑**：

   * 对于每个 final stable state，判断当前组合是否满足所有子系统的 stable/temporary 要求。
   * 在匹配时检查 `except` 集合，若组合包含被禁止的子集则匹配失败。

---

### 代码示例（基础框架）

```cpp
#include <iostream>
#include <tuple>
#include <set>
#include <string>
#include <vector>
#include <functional>
#include <sstream>
#include <shared_mutex>

// ---- 通用宏 ----
#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST) \
    enum class NAME { LIST(ENUM_ITEM, NAME) }; \
    inline const char* to_string(NAME v) { \
        switch(v) { LIST(ENUM_CASE, NAME) } \
        return "Unknown"; \
    }

#define ENUM_ITEM(x, NAME) x,
#define ENUM_CASE(x, NAME) case NAME::x: return #x;

// ---- 示例子系统状态 ----
#define ENGINE_STABLE(M, N) M(Idle, N) M(Running, N) M(Failed, N)
#define ENGINE_TEMP(M, N)   M(HeatingUp, N) M(CoolingDown, N)

#define NETWORK_STABLE(M, N) M(Disconnected, N) M(Connected, N)
#define NETWORK_TEMP(M, N)   M(Reconnecting, N)

#define POWER_STABLE(M, N)   M(Off, N) M(On, N)
#define POWER_TEMP(M, N)     M(Overload, N)

#define SENSOR_STABLE(M, N)  M(Normal, N) M(Warning, N) M(Critical, N)
#define SENSOR_TEMP(M, N)    M(Calibrating, N)

DECLARE_ENUM_WITH_STRINGS(EngineStable, ENGINE_STABLE)
DECLARE_ENUM_WITH_STRINGS(EngineTemp, ENGINE_TEMP)
DECLARE_ENUM_WITH_STRINGS(NetworkStable, NETWORK_STABLE)
DECLARE_ENUM_WITH_STRINGS(NetworkTemp, NETWORK_TEMP)
DECLARE_ENUM_WITH_STRINGS(PowerStable, POWER_STABLE)
DECLARE_ENUM_WITH_STRINGS(PowerTemp, POWER_TEMP)
DECLARE_ENUM_WITH_STRINGS(SensorStable, SENSOR_STABLE)
DECLARE_ENUM_WITH_STRINGS(SensorTemp, SENSOR_TEMP)

// ---- 工具函数 ----
template<typename T>
std::string set_to_string(const std::set<T>& s) {
    std::ostringstream oss;
    bool first = true;
    for (auto& e : s) {
        if (!first) oss << '|';
        oss << to_string(e);
        first = false;
    }
    return oss.str();
}

// ---- 每个子系统状态 ----
template<typename StableT, typename TempT>
struct SubsystemState {
    std::set<StableT> stable;
    std::set<TempT> temp;

    std::string to_string() const {
        return "{Stable:" + set_to_string(stable) + ", Temp:" + set_to_string(temp) + "}";
    }
};

// ---- 匹配器 ----
template<typename StableT, typename TempT>
struct SubsystemMatcher {
    std::set<StableT> stable;
    std::set<TempT> temp;
    std::function<bool(const SubsystemState<StableT, TempT>&)> custom_match;

    bool matches(const SubsystemState<StableT, TempT>& state) const {
        if (custom_match) return custom_match(state);
        for (auto& s : stable) if (!state.stable.count(s)) return false;
        for (auto& t : temp) if (!state.temp.count(t)) return false;
        return true;
    }

    std::string to_string() const {
        return "{S:" + set_to_string(stable) + ", T:" + set_to_string(temp) + "}";
    }
};

// ---- 组合状态 ----
using EngineState = SubsystemState<EngineStable, EngineTemp>;
using NetworkState = SubsystemState<NetworkStable, NetworkTemp>;
using PowerState = SubsystemState<PowerStable, PowerTemp>;
using SensorState = SubsystemState<SensorStable, SensorTemp>;

using CombinedState = std::tuple<EngineState, NetworkState, PowerState, SensorState>;

// ---- Final Stable State 描述 ----
struct FinalStableState {
    std::string name;
    std::tuple<
        SubsystemMatcher<EngineStable, EngineTemp>,
        SubsystemMatcher<NetworkStable, NetworkTemp>,
        SubsystemMatcher<PowerStable, PowerTemp>,
        SubsystemMatcher<SensorStable, SensorTemp>
    > matchers;

    // 例外组合：禁止匹配的子集
    std::vector<CombinedState> except;

    bool matches(const CombinedState& cs) const {
        if (is_except(cs)) return false;
        return matches_impl(cs, std::index_sequence_for<
            EngineState, NetworkState, PowerState, SensorState>{});
    }

private:
    template<std::size_t... I>
    bool matches_impl(const CombinedState& cs, std::index_sequence<I...>) const {
        return (... && std::get<I>(matchers).matches(std::get<I>(cs)));
    }

    bool is_except(const CombinedState& cs) const {
        for (auto& e : except) {
            if (compare_combined(e, cs)) return true;
        }
        return false;
    }

    bool compare_combined(const CombinedState& a, const CombinedState& b) const {
        return compare_tuple(a, b, std::index_sequence_for<
            EngineState, NetworkState, PowerState, SensorState>{});
    }

    template<std::size_t... I>
    bool compare_tuple(const CombinedState& a, const CombinedState& b,
                       std::index_sequence<I...>) const {
        return (... && compare_sub(std::get<I>(a), std::get<I>(b)));
    }

    template<typename S>
    bool compare_sub(const S& a, const S& b) const {
        // 简单比较：a 的 stable/temp 都是 b 的子集则判为等价
        return std::includes(b.stable.begin(), b.stable.end(),
                             a.stable.begin(), a.stable.end()) &&
               std::includes(b.temp.begin(), b.temp.end(),
                             a.temp.begin(), a.temp.end());
    }
};
```

**特点**：

* 每个子系统单独表示 stable/temp。
* 允许一个子系统多个状态共存。
* `except` 列表允许剔除某些特定组合。
* 可轻松扩展更多子系统（增加 enum 和 tuple 元素）。
* 可在匹配器中加入 lambda 自定义逻辑。

---

要不要我**直接补充完整 main 示例**，包括注册多个 FinalStableState、添加 except 例子、并演示匹配结果？


下面我给出一个**新的设计版本**，在前一个框架的基础上补充**掩码快速查找**和**最高状态搜索**，并适应**子系统状态变化时快速重计算**。

---

## 设计核心

1. **掩码加速**：

   * 对每个 `enum class` 的状态定义固定比特位。
   * 一个子系统的稳定/临时状态用一个或两个 `uint64_t` 的位掩码表示。
   * 整个系统的组合用 `std::array<uint64_t, N>` 表示。
   * FinalState 注册时，将所有匹配条件转为**掩码和匹配策略**。
   * 查找时直接按掩码比对（或带例外剔除）。
2. **支持 except（不允许组合）**：

   * 每个 FinalState 有一个“禁止组合”的掩码集合。
   * 匹配时快速跳过这些。
3. **最高状态搜索**：

   * FinalState 可有优先级或等级。
   * 提供接口：基于当前状态掩码，遍历所有 FinalState，找到**匹配条件满足、优先级最高**的 FinalState。
4. **子系统状态变化时快速更新**：

   * 因为内部状态是掩码形式，只需更新一个 `uint64_t`，查找可重用同一接口。

---

## 完整示例代码（骨架）

> 这里重点演示**掩码表示**与**FinalState注册/匹配/最高状态查找**，你可以在此基础上扩展。

```cpp
#include <iostream>
#include <tuple>
#include <vector>
#include <string>
#include <bitset>
#include <shared_mutex>
#include <optional>
#include <algorithm>

// ========== X-Macro 定义与工具 ==========
#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST) \
    enum class NAME { LIST(ENUM_ITEM, NAME) }; \
    inline const char* to_string(NAME v) { \
        switch(v) { LIST(ENUM_CASE, NAME) } \
        return "Unknown"; \
    }

#define ENUM_ITEM(x, NAME) x,
#define ENUM_CASE(x, NAME) case NAME::x: return #x;

#define ENGINE_STABLE(M, N) M(Idle, N) M(Running, N) M(Failed, N)
#define ENGINE_TEMP(M, N)   M(HeatingUp, N) M(CoolingDown, N)

#define NETWORK_STABLE(M, N) M(Disconnected, N) M(Connected, N)
#define NETWORK_TEMP(M, N)   M(Reconnecting, N)

#define POWER_STABLE(M, N)   M(Off, N) M(On, N)
#define POWER_TEMP(M, N)     M(Overload, N)

#define SENSOR_STABLE(M, N)  M(Normal, N) M(Warning, N) M(Critical, N)
#define SENSOR_TEMP(M, N)    M(Calibrating, N)

DECLARE_ENUM_WITH_STRINGS(EngineStable, ENGINE_STABLE)
DECLARE_ENUM_WITH_STRINGS(EngineTemp, ENGINE_TEMP)
DECLARE_ENUM_WITH_STRINGS(NetworkStable, NETWORK_STABLE)
DECLARE_ENUM_WITH_STRINGS(NetworkTemp, NETWORK_TEMP)
DECLARE_ENUM_WITH_STRINGS(PowerStable, POWER_STABLE)
DECLARE_ENUM_WITH_STRINGS(PowerTemp, POWER_TEMP)
DECLARE_ENUM_WITH_STRINGS(SensorStable, SENSOR_STABLE)
DECLARE_ENUM_WITH_STRINGS(SensorTemp, SENSOR_TEMP)

// ========== 掩码定义 ==========
template<typename EnumT>
struct EnumMask {
    using underlying = uint64_t;
    static underlying bit(EnumT e) {
        return 1ULL << static_cast<int>(e);
    }
};

// 每个子系统用一个结构表示 stable/temp 掩码
template<typename StableT, typename TempT>
struct SubsystemMask {
    uint64_t stable_mask{0};
    uint64_t temp_mask{0};

    void set(StableT s) { stable_mask |= EnumMask<StableT>::bit(s); }
    void set(TempT t)   { temp_mask |= EnumMask<TempT>::bit(t); }
    void reset() { stable_mask = 0; temp_mask = 0; }
};

// 系统整体状态
struct CombinedMask {
    SubsystemMask<EngineStable, EngineTemp> engine;
    SubsystemMask<NetworkStable, NetworkTemp> network;
    SubsystemMask<PowerStable, PowerTemp> power;
    SubsystemMask<SensorStable, SensorTemp> sensor;
};

// FinalState 描述
struct FinalState {
    std::string name;
    CombinedMask required;   // 必须包含的掩码
    CombinedMask forbidden;  // 不能包含的掩码（除 except 用）
    int priority{0};

    // except 集合：一些特殊禁止组合
    std::vector<CombinedMask> except;

    bool matches(const CombinedMask& cur) const {
        // forbidden 检查
        if ((cur.engine.stable_mask & forbidden.engine.stable_mask) ||
            (cur.network.stable_mask & forbidden.network.stable_mask) ||
            (cur.power.stable_mask & forbidden.power.stable_mask) ||
            (cur.sensor.stable_mask & forbidden.sensor.stable_mask)) {
            return false;
        }

        // required 检查
        if ((cur.engine.stable_mask & required.engine.stable_mask) != required.engine.stable_mask) return false;
        if ((cur.network.stable_mask & required.network.stable_mask) != required.network.stable_mask) return false;
        if ((cur.power.stable_mask & required.power.stable_mask) != required.power.stable_mask) return false;
        if ((cur.sensor.stable_mask & required.sensor.stable_mask) != required.sensor.stable_mask) return false;

        // except 检查
        for (auto& e : except) {
            if ((cur.engine.stable_mask & e.engine.stable_mask) == e.engine.stable_mask &&
                (cur.network.stable_mask & e.network.stable_mask) == e.network.stable_mask &&
                (cur.power.stable_mask & e.power.stable_mask) == e.power.stable_mask &&
                (cur.sensor.stable_mask & e.sensor.stable_mask) == e.sensor.stable_mask) {
                return false;
            }
        }
        return true;
    }
};

// FinalState 注册与查询
class FinalStateRegistry {
    std::vector<FinalState> finals;
    mutable std::shared_mutex mutex;

public:
    void register_final(const FinalState& fs) {
        std::unique_lock lock(mutex);
        finals.push_back(fs);
    }

    void unregister_all() {
        std::unique_lock lock(mutex);
        finals.clear();
    }

    // 返回最高优先级的匹配状态
    std::optional<FinalState> best_match(const CombinedMask& cur) const {
        std::shared_lock lock(mutex);
        std::optional<FinalState> best;
        for (auto& f : finals) {
            if (f.matches(cur)) {
                if (!best || f.priority > best->priority) {
                    best = f;
                }
            }
        }
        return best;
    }
};

// ========== 使用示例 ==========
int main() {
    FinalStateRegistry registry;

    // 定义一个FinalState: Engine Running + Network Connected -> "OPERATIONAL"
    FinalState operational;
    operational.name = "OPERATIONAL";
    operational.priority = 10;
    operational.required.engine.set(EngineStable::Running);
    operational.required.network.set(NetworkStable::Connected);

    registry.register_final(operational);

    // 当前状态
    CombinedMask cur;
    cur.engine.set(EngineStable::Running);
    cur.network.set(NetworkStable::Connected);
    cur.power.set(PowerStable::On);
    cur.sensor.set(SensorStable::Normal);

    auto best = registry.best_match(cur);
    if (best) {
        std::cout << "Best match: " << best->name << "\n";
    } else {
        std::cout << "No match\n";
    }
    return 0;
}
```

---

## 能力说明

* **掩码操作快速**，匹配过程是位运算，适合实时场景。
* **FinalState 支持 except**，通过禁止组合列表剔除特殊情况。
* **最高优先级匹配**，通过 `priority` 字段实现。
* **子系统状态更新方便**，每次变化只需更新 `CombinedMask` 某个子系统的掩码。
* **线程安全**，读写分离（`shared_mutex`）。

---

## 下一步可扩展

* 为每个子系统 stable/temp 自动生成位分配（X-macro 已有）。
* 增加 **temporary state 的处理**（类似 stable，只是独立掩码）。
* except 可以更灵活（支持“子集禁止”而不是全匹配）。
* 提供更直观的**to\_string** 打印工具，用宏自动生成。
* 可加 **缓存** 提高多次查询性能。

---

要不要我**补充完整的 temporary state 支持**，并演示**一个子系统多个状态同时存在时的最高优先级匹配**示例？


下面我给出一个**扩展版本**，符合你提出的几点新需求：

* **每个子系统的状态是普通 `enum` 而非 `enum class`**，方便使用旧代码或与外部接口兼容。
* **状态单独在头文件定义**，这里我示例给出一个头文件 `subsystems.h`。
* **每个子系统有 10\~20 个状态**，X-macro 依然可以帮助维护字符串映射。
* **组合掩码加速查询**，同时支持 stable/temporary 状态并行存在。
* **提供最高优先级 FinalState 匹配**，支持 except 排除。

这个版本的重点是 **组织结构和宏模式**，你可以把 `subsystems.h` 拆成多个头文件，每个子系统一个 X-macro 定义。

---

### subsystems.h

```cpp
#pragma once

// X-Macro for Engine stable and temporary states
#define ENGINE_STABLE_LIST(M) \
    M(Idle) M(Running) M(Failed) M(Warming) M(Cooling) \
    M(Service) M(Maintenance) M(Overheat) M(Sleep) M(Shutdown)

#define ENGINE_TEMP_LIST(M) \
    M(HeatingUp) M(CoolingDown) M(Restarting) M(Testing) M(Resetting)

// Network
#define NETWORK_STABLE_LIST(M) \
    M(Disconnected) M(Connected) M(Offline) M(Online) M(Limited) \
    M(Fault) M(Secure) M(HighLoad) M(Idle) M(Transitioning)

#define NETWORK_TEMP_LIST(M) \
    M(Reconnecting) M(Switching) M(Pending) M(Failover)

// Power
#define POWER_STABLE_LIST(M) \
    M(Off) M(On) M(Standby) M(Charging) M(Discharging) \
    M(Fault) M(Emergency) M(Maintenance) M(Sleep) M(Wakeup)

#define POWER_TEMP_LIST(M) \
    M(Overload) M(Surge) M(Spike) M(Restore)

// Sensor
#define SENSOR_STABLE_LIST(M) \
    M(Normal) M(Warning) M(Critical) M(Fault) M(Calibrated) \
    M(Uncalibrated) M(Standby) M(Testing) M(Maintenance) M(Offline)

#define SENSOR_TEMP_LIST(M) \
    M(Calibrating) M(Resetting) M(Updating) M(Drifting)

// ---- Declare plain enums ----
#define DECLARE_ENUM(NAME, LIST) \
    enum NAME { LIST(ENUM_ITEM) }; \
    inline const char* to_string(NAME v) { \
        switch(v) { LIST(ENUM_CASE) default: return "Unknown"; } \
    }

#define ENUM_ITEM(x) x,
#define ENUM_CASE(x) case x: return #x;

DECLARE_ENUM(EngineStable, ENGINE_STABLE_LIST)
DECLARE_ENUM(EngineTemp,   ENGINE_TEMP_LIST)
DECLARE_ENUM(NetworkStable, NETWORK_STABLE_LIST)
DECLARE_ENUM(NetworkTemp,   NETWORK_TEMP_LIST)
DECLARE_ENUM(PowerStable, POWER_STABLE_LIST)
DECLARE_ENUM(PowerTemp,   POWER_TEMP_LIST)
DECLARE_ENUM(SensorStable, SENSOR_STABLE_LIST)
DECLARE_ENUM(SensorTemp,   SENSOR_TEMP_LIST)
```

---

### state\_machine.cpp

```cpp
#include "subsystems.h"
#include <vector>
#include <shared_mutex>
#include <optional>
#include <string>
#include <iostream>

// 掩码工具：普通 enum 也能用
template<typename EnumT>
struct EnumMask {
    using underlying = uint64_t;
    static underlying bit(EnumT e) {
        return 1ULL << static_cast<int>(e);
    }
};

// 每个子系统的掩码
template<typename StableT, typename TempT>
struct SubsystemMask {
    uint64_t stable_mask{0};
    uint64_t temp_mask{0};

    void set(StableT s) { stable_mask |= EnumMask<StableT>::bit(s); }
    void set(TempT t)   { temp_mask |= EnumMask<TempT>::bit(t); }
    void clear() { stable_mask = temp_mask = 0; }
};

// 系统整体掩码
struct CombinedMask {
    SubsystemMask<EngineStable, EngineTemp> engine;
    SubsystemMask<NetworkStable, NetworkTemp> network;
    SubsystemMask<PowerStable, PowerTemp> power;
    SubsystemMask<SensorStable, SensorTemp> sensor;
};

// FinalState 描述
struct FinalState {
    std::string name;
    CombinedMask required;
    CombinedMask forbidden;
    std::vector<CombinedMask> except;
    int priority{0};

    bool matches(const CombinedMask& cur) const {
        // 检查 forbidden
        if ((cur.engine.stable_mask & forbidden.engine.stable_mask) ||
            (cur.network.stable_mask & forbidden.network.stable_mask) ||
            (cur.power.stable_mask & forbidden.power.stable_mask) ||
            (cur.sensor.stable_mask & forbidden.sensor.stable_mask))
            return false;

        // 检查 required
        if ((cur.engine.stable_mask & required.engine.stable_mask) != required.engine.stable_mask) return false;
        if ((cur.network.stable_mask & required.network.stable_mask) != required.network.stable_mask) return false;
        if ((cur.power.stable_mask & required.power.stable_mask) != required.power.stable_mask) return false;
        if ((cur.sensor.stable_mask & required.sensor.stable_mask) != required.sensor.stable_mask) return false;

        // 检查 except
        for (auto& e : except) {
            bool blocked =
                ((cur.engine.stable_mask & e.engine.stable_mask) == e.engine.stable_mask) &&
                ((cur.network.stable_mask & e.network.stable_mask) == e.network.stable_mask) &&
                ((cur.power.stable_mask & e.power.stable_mask) == e.power.stable_mask) &&
                ((cur.sensor.stable_mask & e.sensor.stable_mask) == e.sensor.stable_mask);
            if (blocked) return false;
        }
        return true;
    }
};

// 注册器
class FinalStateRegistry {
    std::vector<FinalState> finals;
    mutable std::shared_mutex mutex;
public:
    void register_final(const FinalState& f) {
        std::unique_lock lock(mutex);
        finals.push_back(f);
    }
    void clear() {
        std::unique_lock lock(mutex);
        finals.clear();
    }
    std::optional<FinalState> best_match(const CombinedMask& cur) const {
        std::shared_lock lock(mutex);
        std::optional<FinalState> best;
        for (auto& f : finals) {
            if (f.matches(cur)) {
                if (!best || f.priority > best->priority) best = f;
            }
        }
        return best;
    }
};

// 示例
int main() {
    FinalStateRegistry registry;

    FinalState operational;
    operational.name = "OPERATIONAL";
    operational.priority = 100;
    operational.required.engine.set(Running);
    operational.required.network.set(Connected);
    operational.required.power.set(On);
    operational.required.sensor.set(Normal);

    registry.register_final(operational);

    CombinedMask cur;
    cur.engine.set(Running);
    cur.network.set(Connected);
    cur.power.set(On);
    cur.sensor.set(Normal);

    auto match = registry.best_match(cur);
    if (match) {
        std::cout << "Best: " << match->name << "\n";
    } else {
        std::cout << "No match\n";
    }
}
```

---

### 设计亮点

1. **enum** 而非 `enum class`：兼容旧代码，直接使用 `Running` 等标识符。
2. **X-Macro + inline to\_string**：避免手写冗长映射，状态打印可读。
3. **扩展性强**：头文件中只需增删宏列表，即可增加新状态。
4. **掩码表示**：每个状态用位表示，10\~20 个状态完全可覆盖在 64bit 内。
5. **FinalState 支持 except 与优先级**。
6. **线程安全注册与查询**。

---

要不要我在下一步**增加一个“临时状态会影响最终状态”的优先级处理逻辑**，比如：即使 stable 匹配，temporary 有“故障”时返回异常 FinalState？


明白，你的意思是：

* 每个子系统的状态都是独立定义的 `enum`（比如 `Subsystem1_stateX`, `Subsystem2_stateY` 等），没有公共基类或枚举类型。
* 并且每个子系统的部分状态是 **stable state**，其余可能是 temporary state，需要单独标记。

在这种情况下，我们可以设计如下方案：

---

## 设计方案

1. **子系统状态定义**

```cpp
// Subsystem1.h
enum Subsystem1State {
    S1_Off,
    S1_On,
    S1_Fault,
    S1_Initializing,
    S1_Shutdown
};

// 标记 stable state
constexpr Subsystem1State S1_STABLE_STATES[] = { S1_Off, S1_On, S1_Fault };

// Subsystem2.h
enum Subsystem2State {
    S2_Idle,
    S2_Running,
    S2_Error,
    S2_Maintenance
};

constexpr Subsystem2State S2_STABLE_STATES[] = { S2_Idle, S2_Running, S2_Error };
```

* **stable states** 用一个数组或者 `std::bitset` 表示。
* 临时状态不在 stable 数组中。

---

2. **子系统状态掩码结构**

```cpp
template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};   // 仅stable
    underlying temp_mask{0};     // 仅临时

    void set(StateEnum s) {
        // 检查是否 stable
        bool is_stable = false;
        for (size_t i = 0; i < STABLE_COUNT; ++i) {
            if (STABLES[i] == s) { is_stable = true; break; }
        }
        if (is_stable) stable_mask |= (1ULL << static_cast<int>(s));
        else temp_mask |= (1ULL << static_cast<int>(s));
    }

    void reset() { stable_mask = 0; temp_mask = 0; }
};
```

* **优势**：每个子系统独立，支持不同枚举类型。
* **stable state** 和 **temporary state** 自动区分。

---

3. **组合系统状态**

```cpp
struct CombinedMask {
    SubsystemMask<Subsystem1State, S1_STABLE_STATES, sizeof(S1_STABLE_STATES)/sizeof(S1_STABLE_STATES[0])> s1;
    SubsystemMask<Subsystem2State, S2_STABLE_STATES, sizeof(S2_STABLE_STATES)/sizeof(S2_STABLE_STATES[0])> s2;
    // 其他子系统...
};
```

* 方便扩展，增加子系统只需在 `CombinedMask` 中加入对应掩码。

---

4. **FinalState 定义**

```cpp
struct FinalState {
    std::string name;
    CombinedMask required;
    CombinedMask forbidden;
    int priority{0};
    std::vector<CombinedMask> except;

    bool matches(const CombinedMask& cur) const {
        // 检查 forbidden
        if ((cur.s1.stable_mask & forbidden.s1.stable_mask) != 0) return false;
        if ((cur.s2.stable_mask & forbidden.s2.stable_mask) != 0) return false;
        // 检查 required
        if ((cur.s1.stable_mask & required.s1.stable_mask) != required.s1.stable_mask) return false;
        if ((cur.s2.stable_mask & required.s2.stable_mask) != required.s2.stable_mask) return false;
        // 检查 except
        for (auto& e : except) {
            if ((cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask) return false;
        }
        return true;
    }
};
```

---

### ✅ 特点

1. **子系统完全独立**：不同枚举类型，不必共享基类。
2. **自动区分 stable / temporary**：通过 STABLES 数组。
3. **支持快速掩码匹配**：匹配 required/forbidden/except 都是位运算。
4. **可扩展多个子系统**：只需在 CombinedMask 和 FinalState 中加入对应字段。
5. **支持最高优先级匹配**：可在 FinalStateRegistry 中遍历 `priority` 选出最高的匹配。

---

如果你需要，我可以帮你**写一个完整示例**：

* 四个子系统，每个 10\~20 个状态，
* 支持 stable/temp 自动区分，
* 支持注册多个 FinalState，并演示 **基于当前状态找到最高优先级匹配**。

你希望我直接写这个完整示例吗？

好的，我来详细解释一下，并给出一个完整示例。

---

## 为什么 FinalState 需要 `matches` 方法？

1. **作用**：

   * `FinalState` 表示系统在多个子系统状态组合下对应的一个**稳态（Stable State）**。
   * 当系统运行时，每个子系统状态可能变化（包括 stable 和 temporary），需要**快速判断当前整体状态属于哪个最终稳态**。
   * `matches` 方法就是**判断当前组合状态是否符合该 FinalState 的定义**。

2. **包含内容**：

   * **required**：必须包含的 stable 状态组合。
   * **forbidden**：不允许出现的状态。
   * **except**：特例排除，即使满足 required 也不匹配。
   * **priority**：多个 FinalState 同时满足时，选择优先级最高的。

3. **好处**：

   * 状态机可以根据子系统状态的变化，快速找到当前的 FinalState。
   * 易扩展，可支持 4 个以上子系统，不同枚举类型，不同 stable/temp 划分。

---

## 完整示例

### 子系统状态定义（独立头文件中）

```cpp
// subsystem1.h
#pragma once
enum Subsystem1State {
    S1_Off, S1_On, S1_Fault, S1_Initializing, S1_Shutdown
};
constexpr Subsystem1State S1_STABLE[] = { S1_Off, S1_On, S1_Fault };

// subsystem2.h
#pragma once
enum Subsystem2State {
    S2_Idle, S2_Running, S2_Error, S2_Maintenance
};
constexpr Subsystem2State S2_STABLE[] = { S2_Idle, S2_Running, S2_Error };
```

---

### 通用子系统掩码类

```cpp
#include <cstdint>
#include <string>
#include <vector>
#include <iostream>

template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};
    underlying temp_mask{0};

    void set(StateEnum s) {
        bool is_stable = false;
        for (size_t i = 0; i < STABLE_COUNT; ++i)
            if (STABLES[i] == s) { is_stable = true; break; }
        if (is_stable)
            stable_mask |= (1ULL << static_cast<int>(s));
        else
            temp_mask |= (1ULL << static_cast<int>(s));
    }

    void reset() { stable_mask = 0; temp_mask = 0; }
};
```

---

### 组合状态与 FinalState

```cpp
#include "subsystem1.h"
#include "subsystem2.h"

struct CombinedMask {
    SubsystemMask<Subsystem1State, S1_STABLE, sizeof(S1_STABLE)/sizeof(S1_STABLE[0])> s1;
    SubsystemMask<Subsystem2State, S2_STABLE, sizeof(S2_STABLE)/sizeof(S2_STABLE[0])> s2;
};

// 定义 FinalState
struct FinalState {
    std::string name;
    CombinedMask required;
    CombinedMask forbidden;
    std::vector<CombinedMask> except;
    int priority{0};

    bool matches(const CombinedMask& cur) const {
        // forbidden 检查
        if ((cur.s1.stable_mask & forbidden.s1.stable_mask) != 0) return false;
        if ((cur.s2.stable_mask & forbidden.s2.stable_mask) != 0) return false;

        // required 检查
        if ((cur.s1.stable_mask & required.s1.stable_mask) != required.s1.stable_mask) return false;
        if ((cur.s2.stable_mask & required.s2.stable_mask) != required.s2.stable_mask) return false;

        // except 检查
        for (auto& e : except) {
            if ((cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask) return false;
        }
        return true;
    }
};
```

---

### FinalState 管理与示例

```cpp
#include <algorithm>

struct FinalStateRegistry {
    std::vector<FinalState> states;

    void add(FinalState fs) { states.push_back(std::move(fs)); }

    const FinalState* match_highest(const CombinedMask& cur) const {
        const FinalState* best = nullptr;
        for (auto& fs : states) {
            if (fs.matches(cur)) {
                if (!best || fs.priority > best->priority) best = &fs;
            }
        }
        return best;
    }
};

// 示例主函数
int main() {
    FinalStateRegistry registry;

    // 定义一个FinalState：S1_On 且 S2_Running -> "Operational"
    FinalState op;
    op.name = "Operational";
    op.priority = 10;
    op.required.s1.set(S1_On);
    op.required.s2.set(S2_Running);

    registry.add(op);

    // 当前状态
    CombinedMask cur;
    cur.s1.set(S1_On);
    cur.s2.set(S2_Running);

    // 匹配
    const FinalState* matched = registry.match_highest(cur);
    if (matched) {
        std::cout << "Matched Final State: " << matched->name << "\n";
    } else {
        std::cout << "No match.\n";
    }
    return 0;
}
```

---

### 运行结果

```
Matched Final State: Operational
```

---

## 特点总结

* **matches 方法**封装了 required/forbidden/except 的逻辑判断，清晰且可扩展。
* 使用 **位掩码** 可以快速检查状态组合，适合 10\~20 个状态的子系统。
* 每个子系统状态枚举独立，可以单独维护 stable 列表。
* 可以扩展更多子系统，只需在 `CombinedMask` 和 `FinalState` 中添加对应成员。

---

是否需要我**进一步扩展**：

1. 支持 4 个子系统；
2. 子系统状态通过头文件自动引入；
3. `FinalState` 注册/注销线程安全；
4. 提供一个完整 C++ 工程目录示例？


好的，你这个补充非常关键。你希望：

* **forbidden** 表达的是：某些临时态和稳态**混合出现**时，这个组合不允许出现。
* 单独的**纯稳态组合**不受 forbidden 影响。
* 这样就允许在 FinalState 中预设“例外”或“危险组合”，但不会误伤正常的 stable-only 状态。

---

## 设计调整思路

在前面示例的 `matches` 方法中，我们直接对 `cur.s1.stable_mask` 等与 forbidden 进行按位与，这样会影响所有状态。
改造方式：

1. **禁止条件仅在临时态存在时检查**：

   * forbidden 中的稳定态条件只在对应子系统有临时态时生效。
   * 如果该子系统当前**只有 stable**，即 `temp_mask == 0`，则不触发 forbidden。
2. **forbidden 结构中可以同时指定 stable\_mask 和 temp\_mask**：

   * 例如：forbidden.s1.stable\_mask = S1\_On; forbidden.s1.temp\_mask = S1\_Initializing; 表示“On+Initializing”禁止。
3. `matches` 检查逻辑：

   * 对每个子系统，如果它的 `temp_mask != 0`，才去比对 forbidden 的 stable\_mask 和 temp\_mask。
   * 若 forbidden 的 stable 和 temp 条件都被满足（即 `(cur.stable & forb.stable)==forb.stable && (cur.temp & forb.temp)==forb.temp`），则排除。

---

## 代码修改示例

调整 `matches` 方法核心逻辑：

```cpp
bool matches(const CombinedMask& cur) const {
    // 1. required 检查
    if ((cur.s1.stable_mask & required.s1.stable_mask) != required.s1.stable_mask) return false;
    if ((cur.s2.stable_mask & required.s2.stable_mask) != required.s2.stable_mask) return false;

    // 2. forbidden 检查 - 仅在 temp_mask 非零时
    auto check_forbidden = [](auto& current, auto& forb) {
        if (current.temp_mask != 0) {
            bool stable_ok = (current.stable_mask & forb.stable_mask) == forb.stable_mask;
            bool temp_ok   = (current.temp_mask & forb.temp_mask) == forb.temp_mask;
            return stable_ok && temp_ok;
        }
        return false;
    };
    if (check_forbidden(cur.s1, forbidden.s1)) return false;
    if (check_forbidden(cur.s2, forbidden.s2)) return false;

    // 3. except 检查
    for (auto& e : except) {
        if ((cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
            (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask) return false;
    }
    return true;
}
```

---

## 示例场景

假设有这样一个 forbidden 规则：

* S1\_On（稳态）+ S1\_Initializing（临时态）不允许。

定义：

```cpp
FinalState fs;
fs.name = "Dangerous";
fs.forbidden.s1.stable_mask |= (1ULL << S1_On);
fs.forbidden.s1.temp_mask   |= (1ULL << S1_Initializing);
```

测试：

* 当前状态只有 `S1_On`：匹配时 `temp_mask == 0`，forbidden 不触发。
* 当前状态 `S1_On` + `S1_Initializing`：`temp_mask != 0`，匹配 forbidden，被排除。

---

## 下一步

这个逻辑可以平滑扩展到 4 个甚至更多子系统，每个子系统单独用枚举、stable 列表，并使用位掩码存储。
要不要我把这一改法融入**完整的多子系统状态机示例**里，更新代码让你可以直接用（包括 4 子系统）？


下面给出一个完整的示例代码，结合你的需求：

* **4 个子系统**，每个子系统在独立头文件中定义自己的枚举（普通 `enum`）。
* 每个子系统有 stable 和 temporary 状态，通过 stable 列表区分。
* 使用位掩码快速表示和匹配状态。
* **FinalState** 中支持 required / forbidden / except：

  * **forbidden** 只在当前有临时态时触发，可以描述“稳态 + 临时态”的不允许组合。
* 支持优先级，能够从当前系统状态得到匹配的最高 FinalState。

你可以将这段代码作为 ver2.cpp 测试。

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <cstdint>
#include <algorithm>

//================= 子系统枚举定义 =================

// Subsystem1.h
enum Subsystem1State {
    S1_Off,
    S1_On,
    S1_Fault,
    S1_Initializing,
    S1_Shutdown
};
constexpr Subsystem1State S1_STABLE_STATES[] = { S1_Off, S1_On, S1_Fault };

// Subsystem2.h
enum Subsystem2State {
    S2_Idle,
    S2_Running,
    S2_Error,
    S2_Maintenance
};
constexpr Subsystem2State S2_STABLE_STATES[] = { S2_Idle, S2_Running, S2_Error };

// Subsystem3.h
enum Subsystem3State {
    S3_Disabled,
    S3_Active,
    S3_Busy,
    S3_Recovery
};
constexpr Subsystem3State S3_STABLE_STATES[] = { S3_Disabled, S3_Active };

// Subsystem4.h
enum Subsystem4State {
    S4_Standby,
    S4_Working,
    S4_Fail,
    S4_Resetting
};
constexpr Subsystem4State S4_STABLE_STATES[] = { S4_Standby, S4_Working, S4_Fail };

//================= 子系统掩码模板 =================

template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};
    underlying temp_mask{0};

    void set(StateEnum s) {
        bool is_stable = false;
        for (size_t i = 0; i < STABLE_COUNT; ++i) {
            if (STABLES[i] == s) { is_stable = true; break; }
        }
        if (is_stable) stable_mask |= (1ULL << static_cast<int>(s));
        else temp_mask |= (1ULL << static_cast<int>(s));
    }

    void reset() { stable_mask = 0; temp_mask = 0; }
};

//================= 系统组合状态 =================

struct CombinedMask {
    SubsystemMask<Subsystem1State, S1_STABLE_STATES, sizeof(S1_STABLE_STATES)/sizeof(S1_STABLE_STATES[0])> s1;
    SubsystemMask<Subsystem2State, S2_STABLE_STATES, sizeof(S2_STABLE_STATES)/sizeof(S2_STABLE_STATES[0])> s2;
    SubsystemMask<Subsystem3State, S3_STABLE_STATES, sizeof(S3_STABLE_STATES)/sizeof(S3_STABLE_STATES[0])> s3;
    SubsystemMask<Subsystem4State, S4_STABLE_STATES, sizeof(S4_STABLE_STATES)/sizeof(S4_STABLE_STATES[0])> s4;
};

//================= FinalState 定义 =================

struct FinalState {
    std::string name;
    int priority{0};
    CombinedMask required;
    CombinedMask forbidden;
    std::vector<CombinedMask> except;

    bool matches(const CombinedMask& cur) const {
        // 检查 required
        auto check_required = [](auto& current, auto& req) {
            return (current.stable_mask & req.stable_mask) == req.stable_mask;
        };
        if (!check_required(cur.s1, required.s1)) return false;
        if (!check_required(cur.s2, required.s2)) return false;
        if (!check_required(cur.s3, required.s3)) return false;
        if (!check_required(cur.s4, required.s4)) return false;

        // 检查 forbidden - 仅在临时态存在时触发
        auto check_forbidden = [](auto& current, auto& forb) {
            if (current.temp_mask == 0) return false;
            bool stable_ok = (current.stable_mask & forb.stable_mask) == forb.stable_mask;
            bool temp_ok   = (current.temp_mask & forb.temp_mask) == forb.temp_mask;
            return stable_ok && temp_ok;
        };
        if (check_forbidden(cur.s1, forbidden.s1)) return false;
        if (check_forbidden(cur.s2, forbidden.s2)) return false;
        if (check_forbidden(cur.s3, forbidden.s3)) return false;
        if (check_forbidden(cur.s4, forbidden.s4)) return false;

        // except 检查
        for (auto& e : except) {
            bool hit =
                (cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask &&
                (cur.s3.stable_mask & e.s3.stable_mask) == e.s3.stable_mask &&
                (cur.s4.stable_mask & e.s4.stable_mask) == e.s4.stable_mask;
            if (hit) return false;
        }

        return true;
    }
};

//================= FinalState 注册器 =================

struct FinalStateRegistry {
    std::vector<FinalState> finals;

    void register_state(const FinalState& fs) {
        finals.push_back(fs);
        std::sort(finals.begin(), finals.end(),
                  [](auto& a, auto& b) { return a.priority > b.priority; });
    }

    const FinalState* find_highest_match(const CombinedMask& cur) const {
        for (auto& fs : finals) {
            if (fs.matches(cur)) return &fs;
        }
        return nullptr;
    }
};

//================= 示例使用 =================

int main() {
    FinalStateRegistry registry;

    // 定义一个FinalState
    FinalState normal;
    normal.name = "NormalRun";
    normal.priority = 10;
    normal.required.s1.set(S1_On);
    normal.required.s2.set(S2_Running);

    registry.register_state(normal);

    FinalState danger;
    danger.name = "Danger";
    danger.priority = 100;
    danger.required.s1.set(S1_On);
    // forbidden: On + Initializing
    danger.forbidden.s1.stable_mask |= (1ULL << S1_On);
    danger.forbidden.s1.temp_mask   |= (1ULL << S1_Initializing);
    registry.register_state(danger);

    // 构造当前状态
    CombinedMask current;
    current.s1.set(S1_On);
    current.s1.set(S1_Initializing); // temp
    current.s2.set(S2_Running);

    auto fs = registry.find_highest_match(current);
    if (fs) {
        std::cout << "Matched FinalState: " << fs->name << "\n";
    } else {
        std::cout << "No match.\n";
    }
    return 0;
}
```

---

### 代码能力说明

1. **每个子系统独立定义 enum**，扩展时只需增加头文件和在 CombinedMask 中增加成员。
2. **稳定态列表区分 stable/temp**，无需额外标签。
3. **掩码快速匹配** required / forbidden / except。
4. **forbidden 仅对有临时态的组合有效**，不会干扰纯稳定组合。
5. **支持优先级**，`find_highest_match` 按 priority 返回最高匹配。

---

要继续增强吗？比如：

* 将 stable/temp 列表的查找改为编译期 constexpr 表达式，效率更高；
* 增加线程安全的注册/注销；
* 增加打印、调试辅助。

是否要我在下个版本加入**编译期 constexpr 优化和线程安全**？


好的，下面我把你的要求整合起来：

1. **提供一个状态机基类**：

   * 负责维护子系统状态、注册 FinalState（线程安全）、查找最高匹配。
   * 提供接口：更新子系统状态、获取当前 FinalState。

2. **支持多个子系统（可扩展）**：

   * 每个子系统在独立头文件中用普通 `enum` 定义。
   * 通过模板参数和组合结构管理。

3. **Stable/Temporary 区分**：

   * 在枚举头文件中声明哪些是 Stable。
   * 状态机基类自动区分。

4. **掩码快速匹配**：

   * FinalState 提供 `matches` 接口，支持 required / forbidden / except。
   * forbidden 仅在临时态存在时触发，不影响纯稳态。

5. **线程安全**：

   * FinalState 注册和查找使用 `std::shared_mutex`。

6. **constexpr 优化**：

   * Stable 集合通过 `constexpr` 声明，查找时为编译期常量，效率更高。

下面给出一个示例（伪完整工程结构）。

### 子系统头文件示例（Subsystem1.h）

```cpp
#pragma once
enum Subsystem1State {
    S1_Off, S1_On, S1_Fault, S1_Initializing, S1_Shutdown
};
constexpr Subsystem1State S1_STABLE_STATES[] = { S1_Off, S1_On, S1_Fault };
```

其余子系统类似。

---

### 状态机基类（StateMachine.h）

```cpp
#pragma once
#include <shared_mutex>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>

// 通用模板，用于存储子系统掩码
template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};
    underlying temp_mask{0};

    constexpr bool is_stable(StateEnum s) const {
        for (size_t i = 0; i < STABLE_COUNT; ++i)
            if (STABLES[i] == s) return true;
        return false;
    }
    void set(StateEnum s) {
        if (is_stable(s)) stable_mask |= (1ULL << static_cast<int>(s));
        else temp_mask |= (1ULL << static_cast<int>(s));
    }
    void reset() { stable_mask = 0; temp_mask = 0; }
};

// 状态组合
template<typename S1, typename S2, typename S3, typename S4>
struct CombinedMask {
    S1 s1;
    S2 s2;
    S3 s3;
    S4 s4;
};

// FinalState
template<typename CM>
struct FinalState {
    std::string name;
    int priority{0};
    CM required{};
    CM forbidden{};
    std::vector<CM> except;

    bool matches(const CM& cur) const {
        auto check_req = [](auto& cur, auto& req){
            return (cur.stable_mask & req.stable_mask) == req.stable_mask;
        };
        if (!check_req(cur.s1, required.s1)) return false;
        if (!check_req(cur.s2, required.s2)) return false;
        if (!check_req(cur.s3, required.s3)) return false;
        if (!check_req(cur.s4, required.s4)) return false;

        auto check_forb = [](auto& cur, auto& forb){
            if (cur.temp_mask == 0) return false;
            return ((cur.stable_mask & forb.stable_mask) == forb.stable_mask) &&
                   ((cur.temp_mask & forb.temp_mask) == forb.temp_mask);
        };
        if (check_forb(cur.s1, forbidden.s1)) return false;
        if (check_forb(cur.s2, forbidden.s2)) return false;
        if (check_forb(cur.s3, forbidden.s3)) return false;
        if (check_forb(cur.s4, forbidden.s4)) return false;

        for (auto& e : except) {
            bool hit = 
                (cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask &&
                (cur.s3.stable_mask & e.s3.stable_mask) == e.s3.stable_mask &&
                (cur.s4.stable_mask & e.s4.stable_mask) == e.s4.stable_mask;
            if (hit) return false;
        }
        return true;
    }
};

// 状态机基类
template<typename CM>
class StateMachine {
public:
    using FS = FinalState<CM>;

    void register_final(const FS& fs) {
        std::unique_lock lock(mutex_);
        finals_.push_back(fs);
        std::sort(finals_.begin(), finals_.end(),
                  [](auto& a, auto& b){ return a.priority > b.priority; });
    }

    void update_state(const CM& cm) {
        std::unique_lock lock(state_mutex_);
        current_ = cm;
    }

    FS get_highest() const {
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        for (auto& fs : finals_) {
            if (fs.matches(current_)) return fs;
        }
        return {};
    }

private:
    mutable std::shared_mutex mutex_;
    mutable std::shared_mutex state_mutex_;
    std::vector<FS> finals_;
    CM current_{};
};
```

---

### 使用示例

```cpp
#include "Subsystem1.h"
#include "Subsystem2.h" // 自行定义
#include "Subsystem3.h"
#include "Subsystem4.h"
#include "StateMachine.h"

int main() {
    using Mask1 = SubsystemMask<Subsystem1State, S1_STABLE_STATES, sizeof(S1_STABLE_STATES)/sizeof(S1_STABLE_STATES[0])>;
    using Mask2 = SubsystemMask<Subsystem2State, S2_STABLE_STATES, sizeof(S2_STABLE_STATES)/sizeof(S2_STABLE_STATES[0])>;
    using Mask3 = SubsystemMask<Subsystem3State, S3_STABLE_STATES, sizeof(S3_STABLE_STATES)/sizeof(S3_STABLE_STATES[0])>;
    using Mask4 = SubsystemMask<Subsystem4State, S4_STABLE_STATES, sizeof(S4_STABLE_STATES)/sizeof(S4_STABLE_STATES[0])>;

    using CM = CombinedMask<Mask1,Mask2,Mask3,Mask4>;
    StateMachine<CM> sm;

    CM cm;
    cm.s1.set(S1_On);
    cm.s2.set(S2_Running);

    typename StateMachine<CM>::FS normal;
    normal.name = "Normal";
    normal.priority = 10;
    normal.required.s1.set(S1_On);
    normal.required.s2.set(S2_Running);

    sm.register_final(normal);
    sm.update_state(cm);

    auto fs = sm.get_highest();
    if (!fs.name.empty()) {
        std::cout << "Highest: " << fs.name << "\n";
    }
}
```

---

### **为什么要提供 `matches` 方法**

* 每个 FinalState 描述一个“目标稳态”条件：

  * 要求哪些稳定状态必须满足；
  * 哪些组合在有临时态时禁止；
  * 有些组合需要被排除（except）。
* `matches` 就是判断**当前子系统组合状态**是否满足该 FinalState 的条件。
* 当我们想快速从当前系统状态找到一个**最合适的稳态描述**时，`matches` 是核心接口。

---

### 下一步可扩展

* **新增子系统**：只需增加头文件和在 `CombinedMask` 中加成员。
* **优化查找**：可以用哈希/树提升效率。
* **增加调试功能**：自动输出每个掩码的字符串。

---

要不要我**将完整代码做成单文件 ver3.cpp**（可直接编译运行），还是**拆分成多头文件示例工程**？


下面是一个完整的**多头文件示例工程**的结构，便于扩展和后续维护。代码示例涵盖你要求的特性：

* **4个子系统**，每个子系统状态单独定义为普通`enum`，并在头文件中标记稳定状态。
* **FinalState** 提供 `matches` 方法，支持 required/forbidden/except。
* **StateMachine 基类** 管理 FinalState 的注册/注销、线程安全查找、获取最高优先级匹配状态。
* 代码中用 `constexpr` 稳定状态集合支持快速掩码匹配。

---

## 目录结构

```
/project
  |-- main.cpp
  |-- StateMachine.h
  |-- FinalState.h
  |-- CombinedMask.h
  |-- Subsystem1.h
  |-- Subsystem2.h
  |-- Subsystem3.h
  |-- Subsystem4.h
```

---

### **Subsystem1.h**（其他子系统类似，换成自己的状态）

```cpp
#pragma once

enum Subsystem1State {
    S1_Off,
    S1_On,
    S1_Fault,
    S1_Init,
    S1_Shutdown
};

constexpr Subsystem1State S1_STABLE_STATES[] = {
    S1_Off,
    S1_On,
    S1_Fault
};
```

---

### **CombinedMask.h**

```cpp
#pragma once
#include <cstdint>

// 通用模板，用于区分 stable / temporary 状态
template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};
    underlying temp_mask{0};

    constexpr bool is_stable(StateEnum s) const {
        for (size_t i = 0; i < STABLE_COUNT; ++i) {
            if (STABLES[i] == s) return true;
        }
        return false;
    }

    void set(StateEnum s) {
        if (is_stable(s))
            stable_mask |= (1ULL << static_cast<int>(s));
        else
            temp_mask |= (1ULL << static_cast<int>(s));
    }

    void reset() { stable_mask = 0; temp_mask = 0; }
};

// 组合多个子系统的状态
template<typename S1, typename S2, typename S3, typename S4>
struct CombinedMask {
    S1 s1;
    S2 s2;
    S3 s3;
    S4 s4;
};
```

---

### **FinalState.h**

```cpp
#pragma once
#include <string>
#include <vector>
#include "CombinedMask.h"

template<typename CM>
struct FinalState {
    std::string name;
    int priority{0};
    CM required{};
    CM forbidden{};
    std::vector<CM> except;

    bool matches(const CM& cur) const {
        auto check_req = [](auto& cur, auto& req) {
            return (cur.stable_mask & req.stable_mask) == req.stable_mask;
        };

        if (!check_req(cur.s1, required.s1)) return false;
        if (!check_req(cur.s2, required.s2)) return false;
        if (!check_req(cur.s3, required.s3)) return false;
        if (!check_req(cur.s4, required.s4)) return false;

        auto check_forb = [](auto& cur, auto& forb) {
            if (cur.temp_mask == 0) return false;
            return ((cur.stable_mask & forb.stable_mask) == forb.stable_mask) &&
                   ((cur.temp_mask & forb.temp_mask) == forb.temp_mask);
        };

        if (check_forb(cur.s1, forbidden.s1)) return false;
        if (check_forb(cur.s2, forbidden.s2)) return false;
        if (check_forb(cur.s3, forbidden.s3)) return false;
        if (check_forb(cur.s4, forbidden.s4)) return false;

        for (auto& e : except) {
            bool hit =
                (cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask &&
                (cur.s3.stable_mask & e.s3.stable_mask) == e.s3.stable_mask &&
                (cur.s4.stable_mask & e.s4.stable_mask) == e.s4.stable_mask;
            if (hit) return false;
        }

        return true;
    }
};
```

---

### **StateMachine.h**

```cpp
#pragma once
#include <vector>
#include <shared_mutex>
#include <algorithm>
#include "FinalState.h"

template<typename CM>
class StateMachine {
public:
    using FS = FinalState<CM>;

    void register_final(const FS& fs) {
        std::unique_lock lock(mutex_);
        finals_.push_back(fs);
        std::sort(finals_.begin(), finals_.end(),
                  [](auto& a, auto& b) { return a.priority > b.priority; });
    }

    void clear() {
        std::unique_lock lock(mutex_);
        finals_.clear();
    }

    void update_state(const CM& cm) {
        std::unique_lock lock(state_mutex_);
        current_ = cm;
    }

    FS get_highest() const {
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        for (auto& fs : finals_) {
            if (fs.matches(current_)) return fs;
        }
        return {};
    }

private:
    mutable std::shared_mutex mutex_;
    mutable std::shared_mutex state_mutex_;
    std::vector<FS> finals_;
    CM current_{};
};
```

---

### **main.cpp**

```cpp
#include <iostream>
#include "Subsystem1.h"
#include "Subsystem2.h" // 自行创建
#include "Subsystem3.h"
#include "Subsystem4.h"
#include "CombinedMask.h"
#include "FinalState.h"
#include "StateMachine.h"

int main() {
    using Mask1 = SubsystemMask<Subsystem1State, S1_STABLE_STATES, sizeof(S1_STABLE_STATES)/sizeof(S1_STABLE_STATES[0])>;
    using Mask2 = SubsystemMask<Subsystem2State, S2_STABLE_STATES, sizeof(S2_STABLE_STATES)/sizeof(S2_STABLE_STATES[0])>;
    using Mask3 = SubsystemMask<Subsystem3State, S3_STABLE_STATES, sizeof(S3_STABLE_STATES)/sizeof(S3_STABLE_STATES[0])>;
    using Mask4 = SubsystemMask<Subsystem4State, S4_STABLE_STATES, sizeof(S4_STABLE_STATES)/sizeof(S4_STABLE_STATES[0])>;

    using CM = CombinedMask<Mask1, Mask2, Mask3, Mask4>;
    StateMachine<CM> sm;

    // 构造一个 FinalState
    typename StateMachine<CM>::FS normal;
    normal.name = "Normal";
    normal.priority = 10;
    normal.required.s1.set(S1_On);

    // 注册
    sm.register_final(normal);

    // 更新当前状态
    CM cm;
    cm.s1.set(S1_On);
    sm.update_state(cm);

    // 查找最高优先级匹配
    auto fs = sm.get_highest();
    if (!fs.name.empty()) {
        std::cout << "Highest FinalState: " << fs.name << "\n";
    } else {
        std::cout << "No matching FinalState.\n";
    }

    return 0;
}
```

---

### 为什么有 `matches` 方法？

* **核心用途**：判断**当前系统状态**是否满足某个目标 FinalState。
* **细节**：

  * 检查每个子系统所需稳定状态是否都满足；
  * 检查是否包含禁止的临时态组合（forbidden）；
  * 检查是否有排除的特殊组合（except）。
* **优点**：

  * 可以动态添加或删除 FinalState；
  * 可以快速在不同状态组合间查找匹配的最高优先级稳态；
  * 扩展子系统时无需重写状态机逻辑，只需调整模板参数和状态头文件。

---

是否需要我**补充子系统2/3/4的头文件示例**（包含10\~20个状态）和**完整编译脚本**？还是**直接将上述多头文件示例打包为一个可编译的单文件 demo**？


明白了，你希望**组合状态类型（CM）和子系统掩码类型**在**状态机基类和派生类内部隐藏**，不直接暴露到 `main()`。这样用户只关心**子系统状态的设置和状态机接口**，而无需了解内部模板细节。

下面我给出一个**重构后的多文件示例**，体现这种**封装性**：

---

## **目录结构**

```
/project
  |-- main.cpp
  |-- Subsystem1.h
  |-- Subsystem2.h
  |-- Subsystem3.h
  |-- Subsystem4.h
  |-- StateMachineBase.h
  |-- MyStateMachine.h
```

---

### **Subsystem1.h**（其他子系统类似）

```cpp
#pragma once

enum Subsystem1State {
    S1_Off,
    S1_On,
    S1_Fault,
    S1_Init,
    S1_Shutdown
};

constexpr Subsystem1State S1_STABLE_STATES[] = {
    S1_Off,
    S1_On,
    S1_Fault
};
```

---

### **StateMachineBase.h**

```cpp
#pragma once
#include <shared_mutex>
#include <vector>
#include <algorithm>
#include <string>

template<typename StateEnum, const StateEnum* STABLES, size_t STABLE_COUNT>
struct SubsystemMask {
    using underlying = uint64_t;
    underlying stable_mask{0};
    underlying temp_mask{0};

    constexpr bool is_stable(StateEnum s) const {
        for (size_t i = 0; i < STABLE_COUNT; ++i)
            if (STABLES[i] == s) return true;
        return false;
    }

    void set(StateEnum s) {
        if (is_stable(s)) stable_mask |= (1ULL << s);
        else temp_mask |= (1ULL << s);
    }

    void reset() { stable_mask = temp_mask = 0; }
};

template<typename CM>
struct FinalState {
    std::string name;
    int priority{0};
    CM required{};
    CM forbidden{};
    std::vector<CM> except;

    bool matches(const CM& cur) const {
        auto check_req = [](auto& cur, auto& req) {
            return (cur.stable_mask & req.stable_mask) == req.stable_mask;
        };
        if (!check_req(cur.s1, required.s1)) return false;
        if (!check_req(cur.s2, required.s2)) return false;
        if (!check_req(cur.s3, required.s3)) return false;
        if (!check_req(cur.s4, required.s4)) return false;

        auto check_forb = [](auto& cur, auto& forb) {
            return ((cur.temp_mask & forb.temp_mask) != 0);
        };
        if (check_forb(cur.s1, forbidden.s1)) return false;
        if (check_forb(cur.s2, forbidden.s2)) return false;
        if (check_forb(cur.s3, forbidden.s3)) return false;
        if (check_forb(cur.s4, forbidden.s4)) return false;

        for (auto& e : except) {
            bool hit =
                (cur.s1.stable_mask & e.s1.stable_mask) == e.s1.stable_mask &&
                (cur.s2.stable_mask & e.s2.stable_mask) == e.s2.stable_mask &&
                (cur.s3.stable_mask & e.s3.stable_mask) == e.s3.stable_mask &&
                (cur.s4.stable_mask & e.s4.stable_mask) == e.s4.stable_mask;
            if (hit) return false;
        }
        return true;
    }
};

template<typename CM>
class StateMachineBase {
protected:
    using FS = FinalState<CM>;
    mutable std::shared_mutex mutex_;
    mutable std::shared_mutex state_mutex_;
    std::vector<FS> finals_;
    CM current_{};

public:
    void register_final(const FS& fs) {
        std::unique_lock lock(mutex_);
        finals_.push_back(fs);
        std::sort(finals_.begin(), finals_.end(),
                  [](auto& a, auto& b){ return a.priority > b.priority; });
    }

    void clear() {
        std::unique_lock lock(mutex_);
        finals_.clear();
    }

    FS get_highest() const {
        std::shared_lock lock(mutex_);
        std::shared_lock slock(state_mutex_);
        for (auto& fs : finals_) {
            if (fs.matches(current_)) return fs;
        }
        return {};
    }
};
```

---

### **MyStateMachine.h**

**派生类内部定义组合状态类型和掩码类型，只暴露简单接口。**

```cpp
#pragma once
#include "StateMachineBase.h"
#include "Subsystem1.h"
#include "Subsystem2.h"
#include "Subsystem3.h"
#include "Subsystem4.h"

class MyStateMachine : public StateMachineBase<
    struct Combined {
        using Mask1 = SubsystemMask<Subsystem1State, S1_STABLE_STATES, sizeof(S1_STABLE_STATES)/sizeof(S1_STABLE_STATES[0])>;
        using Mask2 = SubsystemMask<Subsystem2State, S2_STABLE_STATES, sizeof(S2_STABLE_STATES)/sizeof(S2_STABLE_STATES[0])>;
        using Mask3 = SubsystemMask<Subsystem3State, S3_STABLE_STATES, sizeof(S3_STABLE_STATES)/sizeof(S3_STABLE_STATES[0])>;
        using Mask4 = SubsystemMask<Subsystem4State, S4_STABLE_STATES, sizeof(S4_STABLE_STATES)/sizeof(S4_STABLE_STATES[0])>;
        Mask1 s1; Mask2 s2; Mask3 s3; Mask4 s4;
    }
> {
    using Base = StateMachineBase<Combined>;
    using FS = typename Base::FS;

public:
    void setSubsystem1(Subsystem1State s) {
        std::unique_lock lock(Base::state_mutex_);
        Base::current_.s1.set(s);
    }
    // 类似添加setSubsystem2/3/4...

    void reset() {
        std::unique_lock lock(Base::state_mutex_);
        Base::current_ = {};
    }

    void addFinalState(const FS& fs) {
        Base::register_final(fs);
    }
};
```

---

### **main.cpp**

```cpp
#include <iostream>
#include "MyStateMachine.h"

int main() {
    MyStateMachine sm;

    // 构造并注册FinalState
    MyStateMachine::FS normal;
    normal.name = "Normal";
    normal.priority = 10;
    normal.required.s1.set(S1_On);
    sm.addFinalState(normal);

    // 设置子系统状态
    sm.setSubsystem1(S1_On);

    // 获取最高匹配状态
    auto fs = sm.get_highest();
    if (!fs.name.empty()) {
        std::cout << "Highest FinalState: " << fs.name << "\n";
    }
    else {
        std::cout << "No matching FinalState\n";
    }

    return 0;
}
```

---

### **关键点说明**

1. **CM和掩码隐藏**：

   * 在 `MyStateMachine` 内部声明 `Combined` 结构体，继承时作为模板参数传入基类。
   * `main` 用户只调用 `setSubsystemX`，无需知道 `Combined`、`Mask`。

2. **matches 方法作用**：

   * 封装状态匹配逻辑，包括 required、forbidden、except。
   * `get_highest()` 通过此方法选择优先级最高的稳定态。

3. **扩展子系统**：

   * 新增子系统只需在派生类里修改 `Combined` 结构体和接口。

---

是否需要我**把完整代码打包为单文件 demo（方便快速编译测试）**，还是**继续保持多头文件示例并补充子系统2/3/4头文件示例**？


太好了 — 我把你当前实现**升级与工程化**，给出一个更接近实际生产的多文件工程样例（可直接拷入项目并编译），并说明每个文件的职责与关键优化点。

改进要点（概览）

* 明确分离头/实现（多头文件工程），方便维护与单元测试。
* **封装 CombinedMask 类型**：只在状态机与派生类内部可见，外部 API 只暴露 `setSubsystemX(...)`、`clearTemporaryX()`、`registerFinal(...)`、`unregisterFinal(...)`、`getCurrentFinal()` 等高层方法。
* 使用 **位掩码数组**（`std::array<uint64_t, N_SUBSYSTEMS>`）作为内部表示，便于扩展子系统数量并做并行/矢量化优化。
* `FinalState` 在注册时 **预计算/规范化掩码**，支持 `required`、`forbidden`（仅在有临时态时生效）与 `except`（禁止纯稳态子集或特殊组合）。
* 使用 `std::shared_mutex` 实现并发安全（读多写少）。
* 提供一些实用方法：`match_all`（返回所有符合的 final），`best_match`（按 priority 返回最佳)，`best_by_any_subsystem`（如果任意单个子系统符合某 final，则返回优先级最高的 final），并在内部做轻量优化。
* 提供 `CMakeLists.txt` 与 `main.cpp` 示例，方便直接构建/试验。

下面是工程文件内容（把每个代码块写入对应文件）。我用 4 个子系统做示例，便于你 later 扩展到更多子系统：若需我也可以把“任意子系统数量”的模板化版本做成库接口。

---

## 文件：`include/subsystems.h`

（各子系统的 `enum`、stable 列表、`to_string`；放在一个头里方便示例，真实工程可拆分为多个头）

```cpp
#pragma once
#include <cstddef>

// ---------------- Subsystem 1 ----------------
enum Subsystem1State {
    S1_Off = 0,
    S1_On,
    S1_Fault,
    S1_Initializing,
    S1_Shutdown,
    S1_COUNT
};
inline const Subsystem1State S1_STABLE[] = { S1_Off, S1_On, S1_Fault };
inline const size_t S1_STABLE_COUNT = sizeof(S1_STABLE) / sizeof(S1_STABLE[0]);
inline const char* to_string(Subsystem1State s) {
    switch (s) {
        case S1_Off: return "S1_Off";
        case S1_On: return "S1_On";
        case S1_Fault: return "S1_Fault";
        case S1_Initializing: return "S1_Initializing";
        case S1_Shutdown: return "S1_Shutdown";
        default: return "S1_Unknown";
    }
}

// ---------------- Subsystem 2 ----------------
enum Subsystem2State {
    S2_Idle = 0,
    S2_Running,
    S2_Error,
    S2_Maintenance,
    S2_COUNT
};
inline const Subsystem2State S2_STABLE[] = { S2_Idle, S2_Running, S2_Error };
inline const size_t S2_STABLE_COUNT = sizeof(S2_STABLE) / sizeof(S2_STABLE[0]);
inline const char* to_string(Subsystem2State s) {
    switch (s) {
        case S2_Idle: return "S2_Idle";
        case S2_Running: return "S2_Running";
        case S2_Error: return "S2_Error";
        case S2_Maintenance: return "S2_Maintenance";
        default: return "S2_Unknown";
    }
}

// ---------------- Subsystem 3 ----------------
enum Subsystem3State {
    S3_Disabled = 0,
    S3_Active,
    S3_Busy,
    S3_Recovery,
    S3_COUNT
};
inline const Subsystem3State S3_STABLE[] = { S3_Disabled, S3_Active };
inline const size_t S3_STABLE_COUNT = sizeof(S3_STABLE) / sizeof(S3_STABLE[0]);
inline const char* to_string(Subsystem3State s) {
    switch (s) {
        case S3_Disabled: return "S3_Disabled";
        case S3_Active: return "S3_Active";
        case S3_Busy: return "S3_Busy";
        case S3_Recovery: return "S3_Recovery";
        default: return "S3_Unknown";
    }
}

// ---------------- Subsystem 4 ----------------
enum Subsystem4State {
    S4_Standby = 0,
    S4_Working,
    S4_Fail,
    S4_Resetting,
    S4_COUNT
};
inline const Subsystem4State S4_STABLE[] = { S4_Standby, S4_Working, S4_Fail };
inline const size_t S4_STABLE_COUNT = sizeof(S4_STABLE) / sizeof(S4_STABLE[0]);
inline const char* to_string(Subsystem4State s) {
    switch (s) {
        case S4_Standby: return "S4_Standby";
        case S4_Working: return "S4_Working";
        case S4_Fail: return "S4_Fail";
        case S4_Resetting: return "S4_Resetting";
        default: return "S4_Unknown";
    }
}

```

---

## 文件：`include/combined_mask.h`

（内部位掩码表示；对 4 个子系统做固定字段。设计为易扩展）

```cpp
#pragma once
#include <array>
#include <cstdint>
#include <cassert>
#include <string>
#include <sstream>
#include "subsystems.h"

// number of subsystems in this example
static constexpr size_t N_SUBSYSTEMS = 4;

// CombinedMask: flat representation for fast bitwise ops
struct CombinedMask {
    // layout: index 0..N_SUBSYSTEMS-1 corresponds to subsystems
    // each index holds stable_mask in bit 0..63 and temp_mask in bit 64..127? we will use two arrays for clarity
    std::array<uint64_t, N_SUBSYSTEMS> stable{};
    std::array<uint64_t, N_SUBSYSTEMS> temp{};

    void reset() {
        stable.fill(0);
        temp.fill(0);
    }

    // set bit for subsystem index (sub_i), value bitpos
    void set_bit(size_t sub_i, unsigned bitpos, bool is_stable) {
        assert(sub_i < N_SUBSYSTEMS);
        if (bitpos >= 64) return; // guard
        if (is_stable) stable[sub_i] |= (1ULL << bitpos);
        else temp[sub_i] |= (1ULL << bitpos);
    }

    // convenience: check a required stable mask fits (all bits in req must be present in cur)
    static bool stable_contains(uint64_t cur, uint64_t req) {
        return (cur & req) == req;
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "CombinedMask{\n";
        for (size_t i = 0; i < N_SUBSYSTEMS; ++i) {
            oss << " sub" << i << " stable=0x" << std::hex << stable[i]
                << " temp=0x" << temp[i] << std::dec << "\n";
        }
        oss << "}";
        return oss.str();
    }
};
```

---

## 文件：`include/final_state.h`

（FinalState 类型：store required/forbidden/except, precompute nothing complex but normalized; matches implements the forbidden-only-if-temp logic）

```cpp
#pragma once
#include <string>
#include <vector>
#include <algorithm>
#include "combined_mask.h"

// FinalState describes a target stable state
struct FinalState {
    std::string name;
    int priority = 0;

    // required and forbidden masks: same shape as CombinedMask (stable & temp arrays)
    CombinedMask required;
    CombinedMask forbidden;
    std::vector<CombinedMask> except; // optional special-case excludes

    // matches: return true if cur satisfies required AND is not excluded by forbidden/except
    bool matches(const CombinedMask& cur) const {
        // 1) required: all required stable bits must be present
        for (size_t i = 0; i < N_SUBSYSTEMS; ++i) {
            if (!CombinedMask::stable_contains(cur.stable[i], required.stable[i]))
                return false;
        }

        // 2) forbidden: only relevant when current has temporary bits on that subsystem.
        for (size_t i = 0; i < N_SUBSYSTEMS; ++i) {
            if (cur.temp[i] == 0) continue; // pure-stable -> don't check forbidden for this subsystem
            // forbidden condition is "both stable and temp mask match"
            bool stab_ok = (required.stable[i] == 0) ? true // if required doesn't request stable here, still forbidden may specify
                                  : ((cur.stable[i] & forbidden.stable[i]) == forbidden.stable[i]);
            // More direct: forbidden must be matched both stable and temp bits as specified
            bool forb_stab = (forbidden.stable[i] == 0) ? true : ((cur.stable[i] & forbidden.stable[i]) == forbidden.stable[i]);
            bool forb_temp = (forbidden.temp[i] == 0) ? true : ((cur.temp[i] & forbidden.temp[i]) == forbidden.temp[i]);
            // We consider forbidden hit only if both specified parts matched (if one part is zero, treat as matched)
            if (forb_stab && forb_temp) {
                // But ensure that forbidden actually specifies something (avoid false positives)
                if (forbidden.stable[i] != 0 || forbidden.temp[i] != 0) return false;
            }
        }

        // 3) except: a set of forbidden stable-only combinations (or special patterns)
        for (const auto &e : except) {
            bool hit = true;
            for (size_t i = 0; i < N_SUBSYSTEMS; ++i) {
                if (!CombinedMask::stable_contains(cur.stable[i], e.stable[i])) { hit = false; break; }
            }
            if (hit) return false;
        }

        return true;
    }
};
```

> 说明：上面 `forbidden` 判定：我们仅在该子系统存在任何临时位（`cur.temp[i] != 0`）时考虑该子系统的 forbidden 条件；若 `forbidden` 在某子系统指定了 stable 与/或 temp 位，只有同时满足（或该部分为 0）才命中 forbidden；这样纯稳态（temp==0）不会被 forbidden 误杀。

---

## 文件：`include/state_machine.h`

（StateMachine 基类 — 封装 FinalState 列表、注册/注销、线程安全查找、以及导出当前 CombinedMask 的接口）

```cpp
#pragma once
#include <vector>
#include <shared_mutex>
#include <optional>
#include <algorithm>
#include "final_state.h"

// Generic state machine base: hides CombinedMask type by template param.
// Note: CM type is CombinedMask in our example, but this is template for extensibility.
template<typename CMType>
class StateMachine {
public:
    using CombinedType = CMType;
    using FinalType = FinalState;

    StateMachine() = default;

    // register a final; thread-safe
    void register_final(FinalType fs) {
        std::unique_lock lock(mutex_);
        finals_.push_back(std::move(fs));
        // maintain sorted by priority desc
        std::sort(finals_.begin(), finals_.end(), [](auto &a, auto &b){
            return a.priority > b.priority;
        });
    }

    bool unregister_final_by_name(const std::string& name) {
        std::unique_lock lock(mutex_);
        auto it = std::remove_if(finals_.begin(), finals_.end(), [&](auto &f){ return f.name == name; });
        if (it == finals_.end()) return false;
        finals_.erase(it, finals_.end());
        return true;
    }

    void clear_finals() {
        std::unique_lock lock(mutex_);
        finals_.clear();
    }

    // update current mask (thread-safe)
    void update_current(const CombinedType &cm) {
        std::unique_lock lock(state_mutex_);
        current_ = cm;
    }

    // read-only snapshot of current
    CombinedType get_current() const {
        std::shared_lock lock(state_mutex_);
        return current_;
    }

    // find best match by priority
    std::optional<FinalType> best_match() const {
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        for (const auto &f : finals_) {
            if (f.matches(current_)) return f;
        }
        return std::nullopt;
    }

    // return all matches (sorted by priority)
    std::vector<FinalType> match_all() const {
        std::vector<FinalType> out;
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        for (const auto &f : finals_) if (f.matches(current_)) out.push_back(f);
        return out;
    }

    // find best final that can be triggered by ANY single subsystem match:
    // if a final has a requirement that is satisfied on at least one subsystem (stable equality)
    // we consider it candidate; return highest priority.
    std::optional<FinalType> best_by_any_subsystem() const {
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        for (const auto &f : finals_) {
            if (matches_by_any_subsystem_locked(f, current_)) return f;
        }
        return std::nullopt;
    }

protected:
    // protected helper: check "any-subsystem" match for a final (requires locked state)
    static bool matches_by_any_subsystem_locked(const FinalType &f, const CombinedType &cur) {
        for (size_t i = 0; i < N_SUBSYSTEMS; ++i) {
            // if final required stable bits for this sub are non-zero and cur contains at least one of them -> candidate
            if (f.required.stable[i] != 0 && (cur.stable[i] & f.required.stable[i]) != 0) return true;
            // or if final required temp bits and cur has them
            if (f.required.temp[i] != 0 && (cur.temp[i] & f.required.temp[i]) != 0) return true;
        }
        return false;
    }

private:
    mutable std::shared_mutex mutex_;
    mutable std::shared_mutex state_mutex_;
    std::vector<FinalType> finals_;
    CombinedType current_;
};
```

---

## 文件：`src/my_state_machine.h`

（派生实现，隐藏具体 CombinedMask 类型，并暴露友好 API）

```cpp
#pragma once
#include "state_machine.h"
#include "combined_mask.h"
#include "subsystems.h"
#include <string>

// MyStateMachine: concrete class which hides CombinedMask details.
// Exposes high-level API: set subsystem state(s), clear temp, register final by builder helpers.
class MyStateMachine : public StateMachine<CombinedMask> {
public:
    MyStateMachine() = default;

    // API: set a single state in Subsystem1 (stable or temporary determined by S1_STABLE)
    void setSubsystem1(Subsystem1State s) {
        CombinedMask cm = get_current();
        bool is_stable = isStable1(s);
        cm.set_bit(0, static_cast<unsigned>(s), is_stable);
        update_current(cm);
    }
    void clearSubsystem1Temp() {
        CombinedMask cm = get_current();
        cm.temp[0] = 0;
        update_current(cm);
    }

    void setSubsystem2(Subsystem2State s) {
        CombinedMask cm = get_current();
        bool is_stable = isStable2(s);
        cm.set_bit(1, static_cast<unsigned>(s), is_stable);
        update_current(cm);
    }
    void clearSubsystem2Temp() {
        CombinedMask cm = get_current();
        cm.temp[1] = 0;
        update_current(cm);
    }

    void setSubsystem3(Subsystem3State s) {
        CombinedMask cm = get_current();
        bool is_stable = isStable3(s);
        cm.set_bit(2, static_cast<unsigned>(s), is_stable);
        update_current(cm);
    }
    void clearSubsystem3Temp() {
        CombinedMask cm = get_current();
        cm.temp[2] = 0;
        update_current(cm);
    }

    void setSubsystem4(Subsystem4State s) {
        CombinedMask cm = get_current();
        bool is_stable = isStable4(s);
        cm.set_bit(3, static_cast<unsigned>(s), is_stable);
        update_current(cm);
    }
    void clearSubsystem4Temp() {
        CombinedMask cm = get_current();
        cm.temp[3] = 0;
        update_current(cm);
    }

    // helper: register final by name and builder lambdas for required/forbidden/except
    template<typename ReqFn, typename ForbFn, typename ExceptFn>
    void register_final_builder(const std::string &name, int priority,
                                ReqFn req_fn, ForbFn forb_fn, ExceptFn except_fn) {
        FinalState fs;
        fs.name = name;
        fs.priority = priority;
        // user lambdas fill CombinedMask
        req_fn(fs.required);
        forb_fn(fs.forbidden);
        except_fn(fs.except);
        register_final(std::move(fs));
    }

private:
    // helper static checks (could be constexpr)
    static bool isStable1(Subsystem1State s) {
        for (size_t i = 0; i < S1_STABLE_COUNT; ++i) if (S1_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable2(Subsystem2State s) {
        for (size_t i = 0; i < S2_STABLE_COUNT; ++i) if (S2_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable3(Subsystem3State s) {
        for (size_t i = 0; i < S3_STABLE_COUNT; ++i) if (S3_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable4(Subsystem4State s) {
        for (size_t i = 0; i < S4_STABLE_COUNT; ++i) if (S4_STABLE[i] == s) return true;
        return false;
    }
};
```

---

## 文件：`src/main.cpp`

（示例：注册 finals、演示纯稳态匹配、含临时态被 forbidden 排除、any-subsystem 高阶查询）

```cpp
#include <iostream>
#include "my_state_machine.h"

int main() {
    MyStateMachine sm;

    // Register a Normal final: S1_On && S2_Running
    sm.register_final_builder("NormalRun", 10,
        [](CombinedMask &req){
            // required: sub0 stable S1_On, sub1 stable S2_Running
            req.stable[0] |= (1ULL << S1_On);
            req.stable[1] |= (1ULL << S2_Running);
        },
        [](CombinedMask &forb){
            // forbidden none
        },
        [](std::vector<CombinedMask> &excepts){
            // none
        }
    );

    // Register a Danger final: S1_On but forbidden when S1_Initializing exists (On + Initializing)
    sm.register_final_builder("Danger", 50,
        [](CombinedMask &req){
            req.stable[0] |= (1ULL << S1_On);
        },
        [](CombinedMask &forb){
            // forbid: sub0 stable S1_On + temp S1_Initializing
            forb.stable[0] |= (1ULL << S1_On);
            forb.temp[0] |= (1ULL << S1_Initializing);
        },
        [](std::vector<CombinedMask> &excepts){
        }
    );

    // Set current: pure stable S1_On + S2_Running -> should match NormalRun (not blocked)
    sm.setSubsystem1(S1_On);
    sm.setSubsystem2(S2_Running);

    auto best = sm.best_match();
    if (best) std::cout << "Best (pure stable): " << best->name << "\n";
    else std::cout << "No best (pure stable)\n";

    // Add temporary S1_Initializing (now On + Initializing) -> should be blocked from Danger/NormalRun?
    sm.setSubsystem1(S1_Initializing);

    auto best2 = sm.best_match();
    if (best2) std::cout << "Best after temp: " << best2->name << "\n";
    else std::cout << "No best after temp (forbidden hit)\n";

    // best_by_any_subsystem: e.g. some final might be triggered by single subsystem value
    auto anybest = sm.best_by_any_subsystem();
    if (anybest) std::cout << "Best by any subsystem: " << anybest->name << "\n";
    else std::cout << "No any-subsystem candidate\n";

    return 0;
}
```

---

## 文件：`CMakeLists.txt`

(方便你直接编译)

```cmake
cmake_minimum_required(VERSION 3.10)
project(StateMachineDemo LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)
add_executable(sm_demo
    src/main.cpp
    src/my_state_machine.h
    include/state_machine.h
    include/final_state.h
    include/combined_mask.h
    include/subsystems.h
)
```

> 注：`my_state_machine.h` 在示例中被直接包含到编译单元，为简单演示放在 `src/`。在实际工程中建议把所有 `.h` 放在 `include/`，实现放到 `.cpp`。

---

## 性能与工程改进建议（可选迭代）

* **预索引 FinalState**：按子系统建立倒排索引（比如按某个常见 stable 值建立 map->final list），以在大型 final 列表中加速匹配。
* **位宽缩减**：如果某子系统只有 10-20 状态，位掩码用 `uint32_t` 可节约内存并提高缓存命中。
* **序列化/配置**：把 FinalState 的定义导入 JSON/YAML（`nlohmann::json`），便于配置管理与 UI 配置。
* **单元测试**：加入 Catch2 或 GoogleTest 测试套件，针对 required/forbidden/except 的边界情况编写测试。
* **事件回调**：在 state 变化或 final 变化时，触发回调（观察者模式），用于系统级联处理。
* **模板化子系统数量**：如果你确实希望任意数量子系统，可将 `CombinedMask` 变成模板 `CombinedMask<N>` 并在派生类中分配索引常量与 helper `setSubsystem(i, bit)`。

---

如果你想，我可以：

* 把上面文件打包成一个 ZIP（演示工程）并包含示例输出（我目前无法直接创建文件，但我可以把完整代码再发一次供你粘贴）。
* 或者：把上述设计精简为单个可编译的 `ver3.cpp`（便于你快速试验），然后再拆回多头文件结构。

你希望我先把哪一种交付方式做成文本（ZIP / 单文件 / 继续扩展索引/JSON 支持 / 单元测试）？

下面给出一次**较大幅度的迭代** —— 把你之前的设计工程化并加入你要求的改进项：

* 模板化 `CombinedMask<N>`（任意子系统数量）。
* **预索引（倒排索引）FinalState**：按子系统 + stable 位建立索引，加速匹配候选集。
* **序列化/反序列化** FinalState（使用 `nlohmann::json`，可导入/导出 JSON 配置）。
* **事件回调**：当系统状态更新或最佳 FinalState 发生变化时触发回调（观察者模式）。
* **单元测试**：示例使用 Catch2（在 CMake 中用 FetchContent 引入）。
* 子系统状态枚举约定：**稳态放在前面**，后面为临时/转换态（便于稳定/临时自动识别）。

我把工程拆为多文件，下面按文件给出完整代码，方便你直接拷贝到工程里并编译（我也在下面给出 `CMakeLists.txt` 以便拉取 `nlohmann/json` 与 `Catch2` 做测试）。

---

> 说明：这里用 `N = 4` 作为示例（四个子系统）。你可以把 `N` 改为任意值并在派生类中约定每个子系统枚举的位位置（我们通过 `setSubsystemX` 抽象，调用者一般不操作位级API）。

---

## 文件：`include/subsystems.h`

（示例：每个子系统 `enum`，**稳态放前**，随后是临时态）

```cpp
#pragma once
#include <cstddef>

// Subsystem 1 (stable states first, then temporary)
enum Subsystem1State {
    S1_Off = 0,
    S1_On,
    S1_Fault,
    // temporary / transition states
    S1_Initializing,
    S1_ShuttingDown,
    S1_COUNT
};
inline constexpr Subsystem1State S1_STABLE[] = { S1_Off, S1_On, S1_Fault };
inline constexpr size_t S1_STABLE_COUNT = sizeof(S1_STABLE) / sizeof(S1_STABLE[0]);

// Subsystem 2
enum Subsystem2State {
    S2_Idle = 0,
    S2_Running,
    S2_Error,
    // temporary
    S2_Recovering,
    S2_Count
};
inline constexpr Subsystem2State S2_STABLE[] = { S2_Idle, S2_Running, S2_Error };
inline constexpr size_t S2_STABLE_COUNT = sizeof(S2_STABLE) / sizeof(S2_STABLE[0]);

// Subsystem 3
enum Subsystem3State {
    S3_Disabled = 0,
    S3_Active,
    S3_Busy,
    // temporary
    S3_Transition,
    S3_COUNT
};
inline constexpr Subsystem3State S3_STABLE[] = { S3_Disabled, S3_Active };
inline constexpr size_t S3_STABLE_COUNT = sizeof(S3_STABLE) / sizeof(S3_STABLE[0]);

// Subsystem 4
enum Subsystem4State {
    S4_Standby = 0,
    S4_Working,
    S4_Fail,
    // temporary
    S4_Resetting,
    S4_COUNT
};
inline constexpr Subsystem4State S4_STABLE[] = { S4_Standby, S4_Working, S4_Fail };
inline constexpr size_t S4_STABLE_COUNT = sizeof(S4_STABLE) / sizeof(S4_STABLE[0]);
```

---

## 文件：`include/combined_mask.h`

（模板化 `CombinedMask<N>`；提供位设置、序列化友好访问）

```cpp
#pragma once
#include <array>
#include <cstdint>
#include <sstream>
#include <string>
#include <vector>
#include <cassert>

template <size_t N>
struct CombinedMask {
    static_assert(N > 0, "N must be > 0");
    std::array<uint64_t, N> stable{};
    std::array<uint64_t, N> temp{};

    void reset() {
        stable.fill(0);
        temp.fill(0);
    }

    // set bitpos in sub_i; is_stable decides which array
    void set_bit(size_t sub_i, unsigned bitpos, bool is_stable) {
        assert(sub_i < N && bitpos < 64);
        if (is_stable) stable[sub_i] |= (1ULL << bitpos);
        else temp[sub_i] |= (1ULL << bitpos);
    }

    // helper: set entire stable mask at sub_i
    void set_stable_mask(size_t sub_i, uint64_t mask) {
        assert(sub_i < N);
        stable[sub_i] |= mask;
    }

    // check contains (all bits in req exist in cur)
    static bool stable_contains(uint64_t cur_mask, uint64_t req_mask) {
        return (cur_mask & req_mask) == req_mask;
    }

    // get list of set bit positions in stable[sub_i]
    std::vector<unsigned> stable_bits(size_t sub_i) const {
        std::vector<unsigned> out;
        uint64_t v = stable[sub_i];
        for (unsigned b = 0; b < 64 && v; ++b) {
            if (v & 1ULL) out.push_back(b);
            v >>= 1;
        }
        return out;
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "CombinedMask{";
        for (size_t i = 0; i < N; ++i) {
            oss << " sub" << i << " [s=0x" << std::hex << stable[i] << " t=0x" << temp[i] << std::dec << "]";
        }
        oss << " }";
        return oss.str();
    }
};
```

---

## 文件：`include/final_state.h`

（模板化 `FinalState<N>`；并提供 JSON (de)serialize helpers using `nlohmann::json`）

```cpp
#pragma once
#include <string>
#include <vector>
#include "combined_mask.h"
#include <nlohmann/json.hpp>

using nlohmann::json;

template <size_t N>
struct FinalState {
    std::string name;
    int priority = 0;
    CombinedMask<N> required;
    CombinedMask<N> forbidden;
    std::vector<CombinedMask<N>> except;

    // 判断：required 必须出现；forbidden 仅在该子系统有临时态时生效（见实现注释）
    bool matches(const CombinedMask<N>& cur) const {
        // required check
        for (size_t i = 0; i < N; ++i) {
            if (!CombinedMask<N>::stable_contains(cur.stable[i], required.stable[i])) return false;
        }
        // forbidden: only relevant when cur.temp[i] != 0
        for (size_t i = 0; i < N; ++i) {
            if (cur.temp[i] == 0) continue; // pure stable -> forbidden not considered for this sub
            // forbidden hit if forbidden specifies bits and both stable & temp parts are matched (if zero part considered wildcard)
            bool forb_stable_ok = (forbidden.stable[i] == 0) ? true
                                   : ((cur.stable[i] & forbidden.stable[i]) == forbidden.stable[i]);
            bool forb_temp_ok   = (forbidden.temp[i] == 0) ? true
                                   : ((cur.temp[i] & forbidden.temp[i]) == forbidden.temp[i]);
            if (forb_stable_ok && forb_temp_ok) {
                if (forbidden.stable[i] != 0 || forbidden.temp[i] != 0) return false;
            }
        }
        // except: if any except is subset of cur.stable => reject
        for (const auto &e : except) {
            bool hit = true;
            for (size_t i = 0; i < N; ++i) {
                if (!CombinedMask<N>::stable_contains(cur.stable[i], e.stable[i])) { hit = false; break; }
            }
            if (hit) return false;
        }
        return true;
    }

    // JSON helpers (simple representation: name, priority, required.stable as arrays per sub, required.temp optional etc.)
    json to_json() const {
        json j;
        j["name"] = name;
        j["priority"] = priority;
        auto arr_from_mask = [&](const CombinedMask<N>& m) {
            json a = json::array();
            for (size_t i = 0; i < N; ++i) {
                a.push_back(m.stable[i]);
            }
            return a;
        };
        j["required_stable"] = arr_from_mask(required);
        j["required_temp"]   = [&](){
            json a = json::array();
            for (size_t i = 0; i < N; ++i) a.push_back(required.temp[i]);
            return a;
        }();
        j["forbidden_stable"] = [&](){ json a = json::array(); for (size_t i=0;i<N;++i) a.push_back(forbidden.stable[i]); return a; }();
        j["forbidden_temp"]   = [&](){ json a = json::array(); for (size_t i=0;i<N;++i) a.push_back(forbidden.temp[i]); return a; }();
        // except: vector of stable masks array
        json ex = json::array();
        for (auto &e : except) {
            json ee = json::array();
            for (size_t i = 0; i < N; ++i) ee.push_back(e.stable[i]);
            ex.push_back(ee);
        }
        j["except"] = ex;
        return j;
    }

    static FinalState<N> from_json(const json &j) {
        FinalState<N> fs;
        fs.name = j.value("name", std::string());
        fs.priority = j.value("priority", 0);
        auto read_array_to_mask = [&](CombinedMask<N>& m, const json &arr_st, const json &arr_temp){
            for (size_t i = 0; i < N && i < arr_st.size(); ++i) m.stable[i] = arr_st[i].get<uint64_t>();
            for (size_t i = 0; i < N && i < arr_temp.size(); ++i) m.temp[i] = arr_temp[i].get<uint64_t>();
        };
        read_array_to_mask(fs.required, j.value("required_stable", json::array()), j.value("required_temp", json::array()));
        read_array_to_mask(fs.forbidden, j.value("forbidden_stable", json::array()), j.value("forbidden_temp", json::array()));
        auto ex = j.value("except", json::array());
        for (auto &ee : ex) {
            CombinedMask<N> cm; cm.reset();
            for (size_t i = 0; i < N && i < ee.size(); ++i) cm.stable[i] = ee[i].get<uint64_t>();
            fs.except.push_back(cm);
        }
        return fs;
    }
};
```

---

## 文件：`include/state_machine.h`

（模板化 StateMachine，包含倒排索引、事件回调、序列化注册/导入 FinalState）

```cpp
#pragma once
#include <vector>
#include <shared_mutex>
#include <unordered_map>
#include <functional>
#include <optional>
#include <algorithm>
#include <set>
#include "final_state.h"

// key for inverted index: combine subsystem index and bitpos into uint64
inline uint64_t make_index_key(uint32_t sub_i, uint32_t bitpos) {
    return ( (uint64_t)sub_i << 32 ) | (uint64_t)bitpos;
}

template <size_t N>
class StateMachine {
public:
    using CM = CombinedMask<N>;
    using FS = FinalState<N>;
    using StateChangeCb = std::function<void(const CM&)>;
    using FinalChangeCb = std::function<void(const std::optional<FS>& prev, const std::optional<FS>& next)>;

    StateMachine() = default;

    // register callback
    void on_state_change(StateChangeCb cb) {
        std::unique_lock lock(cb_mutex_);
        state_callbacks_.push_back(cb);
    }
    void on_final_change(FinalChangeCb cb) {
        std::unique_lock lock(cb_mutex_);
        final_callbacks_.push_back(cb);
    }

    // register a final; will update inverted index
    void register_final(const FS &fs) {
        std::unique_lock lock(mutex_);
        size_t id = finals_.size();
        finals_.push_back(fs);
        index_final(id, fs);
        // keep finals sorted by priority? we keep originals but when searching we use priority comparison
    }

    // unregister by name
    bool unregister_final_by_name(const std::string &name) {
        std::unique_lock lock(mutex_);
        for (size_t i = 0; i < finals_.size(); ++i) {
            if (finals_[i].name == name) {
                finals_.erase(finals_.begin() + i);
                rebuild_index_locked();
                return true;
            }
        }
        return false;
    }

    // load finals from json array
    void import_from_json(const nlohmann::json &arr) {
        std::unique_lock lock(mutex_);
        finals_.clear();
        index_.clear();
        for (auto &j : arr) {
            auto fs = FS::from_json(j);
            finals_.push_back(std::move(fs));
        }
        // build index
        rebuild_index_locked();
    }

    // export finals to json
    nlohmann::json export_to_json() const {
        std::shared_lock lock(mutex_);
        nlohmann::json arr = nlohmann::json::array();
        for (auto &f : finals_) arr.push_back(f.to_json());
        return arr;
    }

    // update current CM (thread-safe). triggers callbacks and final-change event.
    void update_current(const CM &cm) {
        std::optional<FS> prev_best;
        {
            std::unique_lock state_lock(state_mutex_);
            prev_best = best_match_locked_no_lockstate();
            current_ = cm;
            // notify state callbacks (copy callbacks under lock)
            StateChangeCbVec cbs;
            {
                std::shared_lock cb_lock(cb_mutex_);
                cbs = state_callbacks_;
            }
            // release state_lock to avoid deadlocks inside callbacks
            state_lock.unlock();
            for (auto &cb : cbs) cb(cm);
        }
        // compute new best and notify if changed
        std::optional<FS> new_best = best_match();
        if (!final_equal(prev_best, new_best)) {
            std::shared_lock cb_lock(cb_mutex_);
            for (auto &cb : final_callbacks_) cb(prev_best, new_best);
        }
    }

    CM get_current() const {
        std::shared_lock lock(state_mutex_);
        return current_;
    }

    // fast best match: uses inverted index to collect candidate ids
    std::optional<FS> best_match() const {
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        return best_match_locked();
    }

    // find all matches
    std::vector<FS> match_all() const {
        std::vector<FS> out;
        std::shared_lock lock(mutex_);
        std::shared_lock state_lock(state_mutex_);
        // use index to build candidate set
        auto cand = collect_candidates_locked();
        for (size_t id : cand) {
            if (finals_[id].matches(current_)) out.push_back(finals_[id]);
        }
        // sort by priority desc
        std::sort(out.begin(), out.end(), [](const FS &a, const FS &b){ return a.priority > b.priority; });
        return out;
    }

protected:
    // collect candidates by inverted index (locked: need mutex_ & state_mutex_ held)
    std::vector<size_t> collect_candidates_locked() const {
        std::set<size_t> cand_set;
        for (size_t sub = 0; sub < N; ++sub) {
            uint64_t v = current_.stable[sub];
            for (unsigned b = 0; b < 64 && v; ++b) {
                if (v & (1ULL << b)) {
                    uint64_t key = make_index_key(static_cast<uint32_t>(sub), b);
                    auto it = index_.find(key);
                    if (it != index_.end()) {
                        for (auto id : it->second) cand_set.insert(id);
                    }
                    v &= ~(1ULL << b);
                }
            }
        }
        // produce vector: if empty, fallback to all finals
        std::vector<size_t> out;
        if (cand_set.empty()) {
            out.resize(finals_.size());
            std::iota(out.begin(), out.end(), 0);
        } else {
            out.assign(cand_set.begin(), cand_set.end());
        }
        return out;
    }

    // locked should hold both mutex_ and state_mutex_ (we call with them held)
    std::optional<FS> best_match_locked() const {
        auto cand = collect_candidates_locked();
        std::optional<FS> best;
        for (auto id : cand) {
            const auto &f = finals_[id];
            if (f.matches(current_)) {
                if (!best || f.priority > best->priority) best = f;
            }
        }
        return best;
    }

    // used inside update_current to compute prev before updating
    std::optional<FS> best_match_locked_no_lockstate() const {
        // assumes mutex_ locked (unique) but state_mutex_ not locked: we need snapshot
        CM snapshot;
        {
            std::shared_lock sl(state_mutex_);
            snapshot = current_;
        }
        // collect candidates based on snapshot
        std::set<size_t> cand_set;
        for (size_t sub = 0; sub < N; ++sub) {
            uint64_t v = snapshot.stable[sub];
            for (unsigned b = 0; b < 64 && v; ++b) {
                if (v & (1ULL << b)) {
                    uint64_t key = make_index_key(static_cast<uint32_t>(sub), b);
                    auto it = index_.find(key);
                    if (it != index_.end()) {
                        for (auto id : it->second) cand_set.insert(id);
                    }
                    v &= ~(1ULL << b);
                }
            }
        }
        std::optional<FS> best;
        if (cand_set.empty()) { // fallback
            for (const auto &f : finals_) if (f.matches(snapshot)) if (!best || f.priority > best->priority) best = f;
        } else {
            for (auto id : cand_set) {
                const auto &f = finals_[id];
                if (f.matches(snapshot)) {
                    if (!best || f.priority > best->priority) best = f;
                }
            }
        }
        return best;
    }

    // index helper: index final on its required stable bits
    void index_final(size_t id, const FS &fs) {
        for (size_t sub = 0; sub < N; ++sub) {
            uint64_t mask = fs.required.stable[sub];
            for (unsigned b = 0; b < 64 && mask; ++b) {
                if (mask & (1ULL << b)) {
                    uint64_t key = make_index_key(static_cast<uint32_t>(sub), b);
                    index_[key].push_back(id);
                }
            }
        }
    }

    void rebuild_index_locked() {
        index_.clear();
        for (size_t i = 0; i < finals_.size(); ++i) index_final(i, finals_[i]);
    }

    static bool final_equal(const std::optional<FS> &a, const std::optional<FS> &b) {
        if (!a && !b) return true;
        if (!!a != !!b) return false;
        return a->name == b->name && a->priority == b->priority;
    }

private:
    mutable std::shared_mutex mutex_; // protects finals_ and index_
    mutable std::shared_mutex state_mutex_; // protects current_
    // callbacks
    mutable std::shared_mutex cb_mutex_;
    using StateChangeCbVec = std::vector<StateChangeCb>;
    StateChangeCbVec state_callbacks_;
    std::vector<FinalChangeCb> final_callbacks_;

    std::vector<FS> finals_;
    std::unordered_map<uint64_t, std::vector<size_t>> index_;
    CM current_;
};
```

---

## 文件：`src/my_state_machine.h`

（派生类：把 `N=4` 具体化，提供友好 API：`setSubsystemX`、`clearTempX`、`load_finals_from_json_file`）

```cpp
#pragma once
#include "state_machine.h"
#include "combined_mask.h"
#include "subsystems.h"
#include <fstream>

class MyStateMachine : public StateMachine<4> {
public:
    using Base = StateMachine<4>;
    using CM = CombinedMask<4>;
    using FS = FinalState<4>;

    // set subsystem i state (0..3) helpers: we expose per-subsystem typed API
    void setSubsystem1(Subsystem1State s) {
        CM cm = get_current();
        bool is_stable = isStable1(s);
        cm.set_bit(0, static_cast<unsigned>(s), is_stable);
        Base::update_current(cm);
    }
    void setSubsystem2(Subsystem2State s) {
        CM cm = get_current();
        bool is_stable = isStable2(s);
        cm.set_bit(1, static_cast<unsigned>(s), is_stable);
        Base::update_current(cm);
    }
    void setSubsystem3(Subsystem3State s) {
        CM cm = get_current();
        bool is_stable = isStable3(s);
        cm.set_bit(2, static_cast<unsigned>(s), is_stable);
        Base::update_current(cm);
    }
    void setSubsystem4(Subsystem4State s) {
        CM cm = get_current();
        bool is_stable = isStable4(s);
        cm.set_bit(3, static_cast<unsigned>(s), is_stable);
        Base::update_current(cm);
    }

    void clearTempSubsystem1() { CM cm = get_current(); cm.temp[0] = 0; Base::update_current(cm); }
    void clearTempSubsystem2() { CM cm = get_current(); cm.temp[1] = 0; Base::update_current(cm); }
    void clearTempSubsystem3() { CM cm = get_current(); cm.temp[2] = 0; Base::update_current(cm); }
    void clearTempSubsystem4() { CM cm = get_current(); cm.temp[3] = 0; Base::update_current(cm); }

    // load finals JSON file (array of finals)
    bool load_finals_json_file(const std::string &path) {
        std::ifstream ifs(path);
        if (!ifs.is_open()) return false;
        nlohmann::json j;
        ifs >> j;
        Base::import_from_json(j);
        return true;
    }

    // helper to build FinalState programmatically
    static FS build_final_from_lambda(const std::string &name, int prio,
                                      std::function<void(CM&)> req_fn,
                                      std::function<void(CM&)> forb_fn = [](CM&){},
                                      std::function<void(std::vector<CM>&)> except_fn = [](std::vector<CM>&){})
    {
        FS fs; fs.name = name; fs.priority = prio;
        req_fn(fs.required);
        forb_fn(fs.forbidden);
        except_fn(fs.except);
        return fs;
    }

private:
    static bool isStable1(Subsystem1State s) {
        for (size_t i = 0; i < S1_STABLE_COUNT; ++i) if (S1_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable2(Subsystem2State s) {
        for (size_t i = 0; i < S2_STABLE_COUNT; ++i) if (S2_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable3(Subsystem3State s) {
        for (size_t i = 0; i < S3_STABLE_COUNT; ++i) if (S3_STABLE[i] == s) return true;
        return false;
    }
    static bool isStable4(Subsystem4State s) {
        for (size_t i = 0; i < S4_STABLE_COUNT; ++i) if (S4_STABLE[i] == s) return true;
        return false;
    }
};
```

---

## 文件：`src/main.cpp`

（演示：注册 finals、JSON 导入、回调、匹配）

```cpp
#include <iostream>
#include "my_state_machine.h"
#include <nlohmann/json.hpp>

int main() {
    MyStateMachine sm;

    // register state-change callback
    sm.on_state_change([](const CombinedMask<4> &cm){
        std::cout << "[callback] state updated: " << cm.to_string() << "\n";
    });

    // register final-change callback
    sm.on_final_change([](const std::optional<FinalState<4>>& prev, const std::optional<FinalState<4>>& next){
        std::cout << "[final-change] from ";
        if (prev) std::cout << prev->name; else std::cout << "NONE";
        std::cout << " to ";
        if (next) std::cout << next->name; else std::cout << "NONE";
        std::cout << "\n";
    });

    // Register NormalRun programmatically
    using CM = CombinedMask<4>;
    auto normal = MyStateMachine::build_final_from_lambda("NormalRun", 10,
        [](CM &req){
            req.stable[0] |= (1ULL << S1_On);
            req.stable[1] |= (1ULL << S2_Running);
        }
    );
    sm.register_final(normal);

    // Register Danger (On + Initializing forbidden)
    auto danger = MyStateMachine::build_final_from_lambda("Danger", 50,
        [](CM &req){ req.stable[0] |= (1ULL << S1_On); },
        [](CM &forb){ forb.stable[0] |= (1ULL << S1_On); forb.temp[0] |= (1ULL << S1_Initializing); }
    );
    sm.register_final(danger);

    // set pure stable -> should match NormalRun (Danger not triggered because temp==0)
    sm.setSubsystem1(S1_On);
    sm.setSubsystem2(S2_Running);

    auto best = sm.best_match();
    if (best) std::cout << "Best match: " << best->name << "\n";

    // set temp initializing -> forbidden hit; best_match may change to none
    sm.setSubsystem1(S1_Initializing);

    auto best2 = sm.best_match();
    if (best2) std::cout << "Best match after temp: " << best2->name << "\n";
    else std::cout << "No best match after temp\n";

    // export finals to JSON
    auto j = sm.export_to_json();
    std::cout << "Finals JSON: " << j.dump(2) << "\n";

    return 0;
}
```

---

## 文件：`tests/CMakeLists.txt` & `tests/test_finals.cpp`

（示例 Catch2 测试文件）

`tests/CMakeLists.txt` (snippet to integrate):

```cmake
FetchContent_Declare(
  catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG v2.13.10
)
FetchContent_MakeAvailable(catch2)
add_executable(tests test_finals.cpp)
target_link_libraries(tests PRIVATE Catch2::Catch2)
target_include_directories(tests PRIVATE ${CMAKE_SOURCE_DIR}/include)
target_sources(tests PRIVATE ../src/my_state_machine.h)
```

`tests/test_finals.cpp`:

```cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include "my_state_machine.h"

TEST_CASE("FinalState matching basic", "[final]") {
    MyStateMachine sm;
    using CM = CombinedMask<4>;
    auto fs = MyStateMachine::build_final_from_lambda("F", 10,
        [](CM &req){ req.stable[0] |= (1ULL << S1_On); req.stable[1] |= (1ULL << S2_Running); }
    );
    sm.register_final(fs);
    sm.setSubsystem1(S1_On);
    sm.setSubsystem2(S2_Running);
    auto best = sm.best_match();
    REQUIRE(best.has_value());
    REQUIRE(best->name == "F");
}

TEST_CASE("Forbidden blocks only when temp present", "[forbidden]") {
    MyStateMachine sm;
    using CM = CombinedMask<4>;
    auto fs = MyStateMachine::build_final_from_lambda("F", 10,
        [](CM &req){ req.stable[0] |= (1ULL << S1_On); },
        [](CM &forb){ forb.stable[0] |= (1ULL << S1_On); forb.temp[0] |= (1ULL << S1_Initializing); }
    );
    sm.register_final(fs);
    sm.setSubsystem1(S1_On);
    REQUIRE(sm.best_match().has_value()); // pure stable matches
    sm.setSubsystem1(S1_Initializing);
    REQUIRE(!sm.best_match().has_value()); // now blocked
}
```

---

## 文件：`CMakeLists.txt`（顶层）

（把 nlohmann/json 与 Catch2 通过 FetchContent 拉取）

```cmake
cmake_minimum_required(VERSION 3.14)
project(StateMachinePro VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)

include(FetchContent)

# nlohmann::json
FetchContent_Declare(
  json
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG v3.11.2
)
FetchContent_MakeAvailable(json)

# main executable
add_executable(sm_demo
    src/main.cpp
    src/my_state_machine.h
)
target_include_directories(sm_demo PRIVATE include)
target_link_libraries(sm_demo PRIVATE nlohmann_json::nlohmann_json)

# tests
FetchContent_Declare(
  catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG v2.13.10
)
FetchContent_MakeAvailable(catch2)
add_executable(tests tests/test_finals.cpp)
target_include_directories(tests PRIVATE include)
target_link_libraries(tests PRIVATE Catch2::Catch2)
```

---

## 使用说明 / 设计说明（简短）

* **倒排索引**：当注册 FinalState 时，会把其 `required.stable` 的每一位加入 `index_[make_index_key(sub_i, bitpos)] -> [final_ids...]`。在 `best_match()` 中读取当前 `current_.stable` 的位位表并从索引聚合 candidate finals 集合（去重），然后仅对 candidates 调用 `matches`。当索引空（例如没有任何 required bits 与当前匹配）会回退到遍历所有 finals。这样在 finals 很多时，匹配复杂度可以大幅下降。
* **序列化**：`FinalState::to_json()` / `FinalState::from_json()` 使用 `nlohmann::json`。JSON 格式简单：数组形式保存每个子系统的 64 位掩码。你可以由 UI 生成这些掩码（或者我们增加更友好的字段解析器，支持按枚举名配置）。
* **事件回调**：`on_state_change` / `on_final_change` 提供观察者接口，`update_current()` 会先触发 state callbacks，再计算新的 best 并触发 final-change 回调（前后 FinalState 比较基于名字与优先级）。
* **模板化 N**：`CombinedMask<N>`, `FinalState<N>`, `StateMachine<N>` 支持任意子系统数。`MyStateMachine` 做 4 子系统的具体化并提供类型化 `setSubsystemX` API。
* **稳态在枚举开头**：你要的约定（稳态放前面，后面为临时转换态）让自动判定 `isStable` 更简单（我们在派生类里按 stable arrays 判定；也可改成编译期 constexpr 做更严谨优化）。

---

## 下一步（可选自动化 / 我可以继续做的事）

1. **友好 JSON 配置格式**：现在 JSON 使用掩码数组（数字），我可以加一个层，支持用枚举名字（字符串）来配置 FinalState（更易维护）。这需要枚举名->bitpos 的映射（可通过宏生成表）。
2. **CLI / 管理工具**：小工具将 JSON 配置可视化（HTML/JS 或 Qt）。
3. **性能调优**：倒排索引按子系统/bit 建立的同时可以维护 final -> required\_bits\_count，以优先试探更有可能匹配的 finals。
4. **更严格的并发模型**：目前使用 `shared_mutex` 读多写少适合查找密集场景，如果注册非常频繁可改 RW locks 或版本号 + RCU 风格。
5. **更多单元测试覆盖**：边界情况、except 的组合、序列化 round-trip。

---

如果你希望 **我现在把这些文件打包为单一可复制文本（比如一个 ZIP 的内容）或直接给出一个单文件 `ver4.cpp`（方便快速跑），我可以立刻输出对应版本**。另外，如果你想要我**把 JSON 的配置格式从掩码数字换成按枚举名字**（更友好），也告诉我 — 我会把枚举名-位映射宏化并更新序列化/反序列化。


好 — 我把你要求的**迭代改进**都整合进一个可直接复制/编译的示例（单文件 `ver5.cpp`，演示工程级功能）。这个版本包含：

* 用 **X-macro** 为每个子系统生成 `enum`、字符串表、以及枚举名→位位置的映射函数（friendly JSON 支持）。
* `CombinedMask<N>` 模板化、并提供位操作工具。
* `FinalState<N>` 支持 JSON 的**友好配置格式**（使用枚举名字而不是原始掩码数字），并实现 `to_json()` / `from_json()`。
* **倒排索引（inverted index） + required\_bits\_count**：在注册 final 时为索引记录每个 final 的 required bit 总数；在匹配时优先测试 required\_bits\_count 大的 final（更具体的先试）。
* **更严格的并发模型（读无锁 / 写复制）**：采用 RCU 风格：写时复制 `finals` 与 `index`（protected by `std::mutex`），读者通过 `std::atomic<std::shared_ptr<...>>` 直接读取快照（无需全局读锁）。这样在查找频繁/注册较少的场景下读性能最优；并且写也安全。
* **事件回调**：`on_state_change` 与 `on_final_change` 回调支持。
* 演示了 **JSON 配置文件** 的字符串格式和程序化注册两种方式。
* 给出**测试建议/示例**（Catch2 风格测试片段）供你扩展为单元测试用例。

> 注意：示例中使用 `nlohmann::json`（`#include <nlohmann/json.hpp>`）。在 CMake 中用 FetchContent 拉取或在项目中直接添加头文件。

---

下面是 `ver5.cpp`（很长，但包含完整实现与示例）。把它粘贴为单文件测试或按照之前的多文件设计拆分为多个源/头文件。

```cpp
// ver5.cpp
// Build with: -std=c++17 and link nlohmann/json (single-header) available.
// Example: g++ ver5.cpp -I/path/to/nlohmann -pthread -std=c++17 -O2

#include <iostream>
#include <vector>
#include <string>
#include <array>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <algorithm>
#include <functional>
#include <sstream>
#include <cassert>
#include <fstream>

// nlohmann::json - make sure available in include path
#include <nlohmann/json.hpp>
using json = nlohmann::json;

/* ===========================
   1) ENUM DECLS + X-MACRO
   ===========================
   For each subsystem we use an X-macro to:
   - declare enum values (stable first, then temporary)
   - generate a names array and helper mapping from name->index
*/

// Helper macros for general enum lists
#define ENUM_ITEM(x) x,
#define ENUM_STR(x) #x,

// Subsystem1 list (stable first)
#define SUB1_LIST(M) \
    M(S1_Off) M(S1_On) M(S1_Fault) /* stable */ \
    M(S1_Initializing) M(S1_Shutdown) /* temporary */

// Subsystem2 list
#define SUB2_LIST(M) \
    M(S2_Idle) M(S2_Running) M(S2_Error) \
    M(S2_Recovering)

// Subsystem3 list
#define SUB3_LIST(M) \
    M(S3_Disabled) M(S3_Active) M(S3_Busy) \
    M(S3_Transition)

// Subsystem4 list
#define SUB4_LIST(M) \
    M(S4_Standby) M(S4_Working) M(S4_Fail) \
    M(S4_Resetting)

// Expand enums and string arrays
enum Subsystem1State { SUB1_LIST(ENUM_ITEM) SUB1_COUNT };
static const char* SUB1_NAMES[] = { SUB1_LIST(ENUM_STR) };

enum Subsystem2State { SUB2_LIST(ENUM_ITEM) SUB2_COUNT };
static const char* SUB2_NAMES[] = { SUB2_LIST(ENUM_STR) };

enum Subsystem3State { SUB3_LIST(ENUM_ITEM) SUB3_COUNT };
static const char* SUB3_NAMES[] = { SUB3_LIST(ENUM_STR) };

enum Subsystem4State { SUB4_LIST(ENUM_ITEM) SUB4_COUNT };
static const char* SUB4_NAMES[] = { SUB4_LIST(ENUM_STR) };

// stable counts (how many stable states per subsystem; we follow the convention: stable enums are declared first)
static constexpr unsigned SUB1_STABLE_COUNT = 3; // S1_Off,S1_On,S1_Fault
static constexpr unsigned SUB2_STABLE_COUNT = 3; // S2_Idle,S2_Running,S2_Error
static constexpr unsigned SUB3_STABLE_COUNT = 3; // S3_Disabled,S3_Active,S3_Busy
static constexpr unsigned SUB4_STABLE_COUNT = 3; // S4_Standby,S4_Working,S4_Fail

// name->index mapping (built at runtime once)
struct EnumNameMaps {
    std::unordered_map<std::string,unsigned> m1, m2, m3, m4;
    EnumNameMaps() {
        for (unsigned i=0;i<SUB1_COUNT;++i) m1[SUB1_NAMES[i]] = i;
        for (unsigned i=0;i<SUB2_COUNT;++i) m2[SUB2_NAMES[i]] = i;
        for (unsigned i=0;i<SUB3_COUNT;++i) m3[SUB3_NAMES[i]] = i;
        for (unsigned i=0;i<SUB4_COUNT;++i) m4[SUB4_NAMES[i]] = i;
    }
};
static EnumNameMaps ENUM_MAPS;

/* ===========================
   2) CombinedMask<N>
   =========================== */

template <size_t N>
struct CombinedMask {
    std::array<uint64_t, N> stable{};
    std::array<uint64_t, N> temp{};

    void reset() { stable.fill(0); temp.fill(0); }

    void set_bit(size_t sub, unsigned bitpos, bool is_stable) {
        assert(sub < N && bitpos < 64);
        if (is_stable) stable[sub] |= (1ULL<<bitpos);
        else temp[sub] |= (1ULL<<bitpos);
    }

    void set_stable_mask(size_t sub, uint64_t mask) {
        assert(sub < N);
        stable[sub] |= mask;
    }

    void set_temp_mask(size_t sub, uint64_t mask) {
        assert(sub < N);
        temp[sub] |= mask;
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "CombinedMask{";
        for (size_t i=0;i<N;++i){
            oss << " sub" << i << "[s=0x" << std::hex << stable[i] << " t=0x" << temp[i] << std::dec << "]";
        }
        oss << " }";
        return oss.str();
    }
    bool operator==(const CombinedMask& o) const {
        return stable==o.stable && temp==o.temp;
    }
};

/* ===========================
   3) FinalState<N> with JSON friendly (string names)
   =========================== */

template <size_t N>
struct FinalState {
    std::string name;
    int priority = 0;
    CombinedMask<N> required;
    CombinedMask<N> forbidden;
    std::vector<CombinedMask<N>> except;

    // precomputed specificity: number of required stable bits (sum across subsystems)
    unsigned required_bits_count() const {
        unsigned cnt = 0;
        for (size_t i=0;i<N;++i) cnt += __builtin_popcountll(required.stable[i]);
        return cnt;
    }

    bool matches(const CombinedMask<N>& cur) const {
        // required: all required stable bits must be present
        for (size_t i=0;i<N;++i) {
            if ((cur.stable[i] & required.stable[i]) != required.stable[i]) return false;
        }
        // forbidden: only considered when cur.temp[i] != 0
        for (size_t i=0;i<N;++i) {
            if (cur.temp[i] == 0) continue;
            bool forb_stab_ok = (forbidden.stable[i]==0) ? true
                : ((cur.stable[i] & forbidden.stable[i]) == forbidden.stable[i]);
            bool forb_temp_ok = (forbidden.temp[i]==0) ? true
                : ((cur.temp[i] & forbidden.temp[i]) == forbidden.temp[i]);
            if (forb_stab_ok && forb_temp_ok) {
                if (forbidden.stable[i]!=0 || forbidden.temp[i]!=0) return false;
            }
        }
        // except: if any except's stable masks are subset of cur.stable => reject
        for (const auto &e : except) {
            bool hit = true;
            for (size_t i=0;i<N;++i) {
                if ((cur.stable[i] & e.stable[i]) != e.stable[i]) { hit = false; break; }
            }
            if (hit) return false;
        }
        return true;
    }

    // ----- JSON serialization (friendly with enum names) -----
    // JSON format (example):
    // {
    //   "name": "Normal",
    //   "priority": 10,
    //   "required": [ ["S1_On"], ["S2_Running"], [], [] ],
    //   "forbidden": { "sub0": { "stable":["S1_On"], "temp":["S1_Initializing"] }, ... }
    //   "except": [ [ ["S1_Off"],[],[],[] ], ... ]  // array of per-subsystem array of stable names
    // }
    json to_json() const {
        json j;
        j["name"] = name;
        j["priority"] = priority;
        // required: per-subsystem array of names
        json req = json::array();
        for (size_t i=0;i<N;++i) {
            json arr = json::array();
            uint64_t mask = required.stable[i];
            for (unsigned b=0;b<64;++b) {
                if (mask & (1ULL<<b)) {
                    arr.push_back(enum_name_by_index(i,b));
                }
            }
            req.push_back(arr);
        }
        j["required"] = req;
        // forbidden: per-subsystem object of stable/temp name arrays
        json forb = json::array();
        for (size_t i=0;i<N;++i) {
            json obj;
            json sarr = json::array();
            json tarr = json::array();
            uint64_t sm = forbidden.stable[i];
            uint64_t tm = forbidden.temp[i];
            for (unsigned b=0;b<64;++b) {
                if (sm & (1ULL<<b)) sarr.push_back(enum_name_by_index(i,b));
                if (tm & (1ULL<<b)) tarr.push_back(enum_name_by_index(i,b));
            }
            obj["stable"] = sarr;
            obj["temp"] = tarr;
            forb.push_back(obj);
        }
        j["forbidden"] = forb;
        // except: array of per-except stable-only arrays
        json exc = json::array();
        for (auto &e : except) {
            json er = json::array();
            for (size_t i=0;i<N;++i) {
                json arr = json::array();
                uint64_t mask = e.stable[i];
                for (unsigned b=0;b<64;++b) if (mask & (1ULL<<b)) arr.push_back(enum_name_by_index(i,b));
                er.push_back(arr);
            }
            exc.push_back(er);
        }
        j["except"] = exc;
        return j;
    }

    static FinalState<N> from_json(const json &j) {
        FinalState<N> fs;
        fs.name = j.value("name", std::string());
        fs.priority = j.value("priority", 0);
        // read required
        if (j.contains("required") && j["required"].is_array()) {
            for (size_t i=0;i<N && i<j["required"].size(); ++i) {
                for (auto &v : j["required"][i]) {
                    std::string s = v.get<std::string>();
                    auto idx = enum_index_by_name(i, s);
                    if (idx.has_value()) fs.required.stable[i] |= (1ULL<<idx.value());
                    else {
                        std::cerr << "[Warning] unknown enum name '"<<s<<"' for subsystem "<<i<<"\n";
                    }
                }
            }
        }
        // forbidden
        if (j.contains("forbidden") && j["forbidden"].is_array()) {
            for (size_t i=0;i<N && i<j["forbidden"].size(); ++i) {
                auto &obj = j["forbidden"][i];
                if (obj.contains("stable")) for (auto &v : obj["stable"]) {
                    std::string s = v.get<std::string>();
                    auto idx = enum_index_by_name(i,s);
                    if (idx) fs.forbidden.stable[i] |= (1ULL<<idx.value());
                }
                if (obj.contains("temp")) for (auto &v : obj["temp"]) {
                    std::string s = v.get<std::string>();
                    auto idx = enum_index_by_name(i,s);
                    if (idx) fs.forbidden.temp[i] |= (1ULL<<idx.value());
                }
            }
        }
        // except
        if (j.contains("except") && j["except"].is_array()) {
            for (auto &ent : j["except"]) {
                CombinedMask<N> ecm; ecm.reset();
                for (size_t i=0;i<N && i<ent.size(); ++i) {
                    for (auto &v : ent[i]) {
                        auto idx = enum_index_by_name(i, v.get<std::string>());
                        if (idx) ecm.stable[i] |= (1ULL<<idx.value());
                    }
                }
                fs.except.push_back(ecm);
            }
        }
        return fs;
    }

private:
    // helper: map subsystem index and bitpos -> enum name string
    static std::string enum_name_by_index(size_t sub_i, unsigned bitpos) {
        switch (sub_i) {
            case 0: if (bitpos < SUB1_COUNT) return SUB1_NAMES[bitpos]; break;
            case 1: if (bitpos < SUB2_COUNT) return SUB2_NAMES[bitpos]; break;
            case 2: if (bitpos < SUB3_COUNT) return SUB3_NAMES[bitpos]; break;
            case 3: if (bitpos < SUB4_COUNT) return SUB4_NAMES[bitpos]; break;
        }
        return std::string("Unknown");
    }
    // helper: map name->index (subsystem i)
    static std::optional<unsigned> enum_index_by_name(size_t sub_i, const std::string &name) {
        if (sub_i==0) {
            auto it = ENUM_MAPS.m1.find(name);
            if (it!=ENUM_MAPS.m1.end()) return it->second;
        } else if (sub_i==1) {
            auto it = ENUM_MAPS.m2.find(name);
            if (it!=ENUM_MAPS.m2.end()) return it->second;
        } else if (sub_i==2) {
            auto it = ENUM_MAPS.m3.find(name);
            if (it!=ENUM_MAPS.m3.end()) return it->second;
        } else if (sub_i==3) {
            auto it = ENUM_MAPS.m4.find(name);
            if (it!=ENUM_MAPS.m4.end()) return it->second;
        }
        return std::nullopt;
    }
};

/* ===========================
   4) StateMachine<N>
   - RCU-like read (atomic shared_ptr)
   - writer locks for register/unregister and rebuild index
   - inverted index + required_bits_count used to prioritize candidates
   - callbacks for state/final changes
   =========================== */

inline uint64_t make_index_key(uint32_t sub_i, uint32_t bitpos) {
    return ( (uint64_t)sub_i << 32 ) | (uint64_t)bitpos;
}

template <size_t N>
class StateMachine {
public:
    using CM = CombinedMask<N>;
    using FS = FinalState<N>;
    using FSVec = std::vector<FS>;
    using IndexMap = std::unordered_map<uint64_t, std::vector<size_t>>;
    using StateChangeCb = std::function<void(const CM&)>;
    using FinalChangeCb = std::function<void(const std::optional<FS>& prev, const std::optional<FS>& next)>;

    StateMachine() {
        finals_ptr_.store(std::make_shared<FSVec>());
        index_ptr_.store(std::make_shared<IndexMap>());
    }

    // write-side operations (lock writer_mutex_)
    void register_final(const FS &fs) {
        std::lock_guard<std::mutex> wlock(writer_mutex_);
        // clone finals
        auto new_finals = std::make_shared<FSVec>(*finals_ptr_.load());
        new_finals->push_back(fs);
        // compute new index (we can incrementally update but for simplicity rebuild)
        auto new_index = std::make_shared<IndexMap>();
        build_index(*new_finals, *new_index);
        // publish (atomic swap)
        finals_ptr_.store(new_finals);
        index_ptr_.store(new_index);
    }

    bool unregister_final_by_name(const std::string &name) {
        std::lock_guard<std::mutex> wlock(writer_mutex_);
        auto old = finals_ptr_.load();
        auto new_finals = std::make_shared<FSVec>();
        for (const auto &f : *old) if (f.name != name) new_finals->push_back(f);
        if (new_finals->size() == old->size()) return false;
        auto new_index = std::make_shared<IndexMap>();
        build_index(*new_finals, *new_index);
        finals_ptr_.store(new_finals);
        index_ptr_.store(new_index);
        return true;
    }

    void clear_finals() {
        std::lock_guard<std::mutex> wlock(writer_mutex_);
        finals_ptr_.store(std::make_shared<FSVec>());
        index_ptr_.store(std::make_shared<IndexMap>());
    }

    // import finals from friendly JSON array
    void import_from_json(const json &arr) {
        std::lock_guard<std::mutex> wlock(writer_mutex_);
        auto v = std::make_shared<FSVec>();
        if (!arr.is_array()) return;
        for (auto &j : arr) {
            FS f = FS::from_json(j);
            v->push_back(std::move(f));
        }
        auto idx = std::make_shared<IndexMap>();
        build_index(*v, *idx);
        finals_ptr_.store(v);
        index_ptr_.store(idx);
    }

    json export_to_json() const {
        auto finals = finals_ptr_.load();
        json arr = json::array();
        for (auto &f : *finals) arr.push_back(f.to_json());
        return arr;
    }

    // callback registration
    void on_state_change(StateChangeCb cb) {
        std::lock_guard<std::mutex> g(cb_mutex_);
        state_cbs_.push_back(cb);
    }
    void on_final_change(FinalChangeCb cb) {
        std::lock_guard<std::mutex> g(cb_mutex_);
        final_cbs_.push_back(cb);
    }

    // update current state (writer modifies state under state_mutex_)
    void update_current(const CM &cm) {
        std::optional<FS> prev_best = best_match_nolock_state(); // snapshot previous
        {
            std::unique_lock<std::shared_mutex> lock(state_mutex_);
            current_ = cm;
        }
        // call state callbacks (copy under lock)
        std::vector<StateChangeCb> scbs;
        {
            std::lock_guard<std::mutex> g(cb_mutex_);
            scbs = state_cbs_;
        }
        for (auto &cb : scbs) cb(cm);

        std::optional<FS> new_best = best_match();
        if (!final_equal(prev_best, new_best)) {
            std::vector<FinalChangeCb> fcbs;
            {
                std::lock_guard<std::mutex> g(cb_mutex_);
                fcbs = final_cbs_;
            }
            for (auto &cb : fcbs) cb(prev_best, new_best);
        }
    }

    CM get_current() const {
        std::shared_lock<std::shared_mutex> lock(state_mutex_);
        return current_;
    }

    // best match (read without writer lock)
    std::optional<FS> best_match() const {
        auto finals = finals_ptr_.load();
        auto idx = index_ptr_.load();
        CM snapshot;
        {
            std::shared_lock<std::shared_mutex> lock(state_mutex_);
            snapshot = current_;
        }
        auto candidates = collect_candidates(snapshot, *idx, *finals);
        // try candidates sorted by required_bits_count desc
        std::optional<FS> best;
        unsigned best_prio = 0;
        for (size_t id : candidates) {
            const FS &f = (*finals)[id];
            if (f.matches(snapshot)) {
                if (!best || f.priority > (int)best_prio) {
                    best = f; best_prio = f.priority;
                }
            }
        }
        return best;
    }

    std::vector<FS> match_all() const {
        auto finals = finals_ptr_.load();
        auto idx = index_ptr_.load();
        CM snapshot;
        {
            std::shared_lock<std::shared_mutex> lock(state_mutex_);
            snapshot = current_;
        }
        auto candidates = collect_candidates(snapshot, *idx, *finals);
        std::vector<FS> out;
        for (size_t id : candidates) {
            const FS &f = (*finals)[id];
            if (f.matches(snapshot)) out.push_back(f);
        }
        std::sort(out.begin(), out.end(), [](const FS&a,const FS&b){ return a.priority>b.priority; });
        return out;
    }

protected:
    // Build inverted index and also compute required_bits_count vector
    static void build_index(const FSVec &finals, IndexMap &idx) {
        for (size_t id=0; id<finals.size(); ++id) {
            const FS &f = finals[id];
            // for each sub, for each set bit in required.stable[sub] add index
            for (size_t sub=0; sub<N; ++sub) {
                uint64_t m = f.required.stable[sub];
                for (unsigned b=0; b<64 && m; ++b) {
                    if (m & (1ULL<<b)) {
                        uint64_t key = make_index_key((uint32_t)sub, b);
                        idx[key].push_back(id);
                    }
                }
            }
        }
    }

    // collect candidate final ids: gather index lists for each stable bit in snapshot
    static std::vector<size_t> collect_candidates(const CM &snapshot, const IndexMap &idx, const FSVec &finals) {
        std::unordered_set<size_t> s;
        for (size_t sub=0; sub<N; ++sub) {
            uint64_t m = snapshot.stable[sub];
            for (unsigned b=0; b<64 && m; ++b) {
                if (m & (1ULL<<b)) {
                    uint64_t key = make_index_key((uint32_t)sub, b);
                    auto it = idx.find(key);
                    if (it!=idx.end()) {
                        for (size_t id : it->second) s.insert(id);
                    }
                }
            }
        }
        std::vector<size_t> out;
        if (s.empty()) {
            // fallback: all finals
            out.resize(finals.size());
            std::iota(out.begin(), out.end(), 0);
        } else {
            // convert to vector and sort by required_bits_count desc, then priority desc
            out.assign(s.begin(), s.end());
            std::sort(out.begin(), out.end(), [&](size_t a, size_t b){
                const FS &fa = finals[a], &fb = finals[b];
                unsigned ca = fa.required_bits_count(), cb = fb.required_bits_count();
                if (ca != cb) return ca > cb;
                return fa.priority > fb.priority;
            });
        }
        return out;
    }

    // used in update_current to get previous best (without requiring writer lock)
    std::optional<FS> best_match_nolock_state() const {
        auto finals = finals_ptr_.load();
        auto idx = index_ptr_.load();
        CM snapshot;
        {
            std::shared_lock<std::shared_mutex> lock(state_mutex_);
            snapshot = current_;
        }
        auto candidates = collect_candidates(snapshot, *idx, *finals);
        std::optional<FS> best;
        unsigned best_prio = 0;
        for (size_t id : candidates) {
            const FS &f = (*finals)[id];
            if (f.matches(snapshot)) {
                if (!best || f.priority > (int)best_prio) { best = f; best_prio = f.priority; }
            }
        }
        return best;
    }

    static bool final_equal(const std::optional<FS> &a, const std::optional<FS>& b) {
        if (!a && !b) return true;
        if (!!a != !!b) return false;
        return a->name == b->name && a->priority == b->priority;
    }

private:
    // atomic snapshot pointers for read-mostly access
    std::atomic<std::shared_ptr<FSVec>> finals_ptr_;
    std::atomic<std::shared_ptr<IndexMap>> index_ptr_;

    // writer mutex to protect rebuild on writes
    mutable std::mutex writer_mutex_;

    // current state protected by shared_mutex
    mutable std::shared_mutex state_mutex_;
    CM current_;

    // callbacks
    mutable std::mutex cb_mutex_;
    std::vector<StateChangeCb> state_cbs_;
    std::vector<FinalChangeCb> final_cbs_;
};

/* ===========================
   5) Concrete MyStateMachine for N=4 with typed API
   =========================== */

class MyStateMachine : public StateMachine<4> {
public:
    using Base = StateMachine<4>;
    using CM = CombinedMask<4>;
    using FS = FinalState<4>;

    MyStateMachine() = default;

    // typed setters: automatically mark stable vs temp using convention stable-first counts
    void setSubsystem1(Subsystem1State s) {
        CM cm = Base::get_current();
        bool is_stable = (unsigned(s) < SUB1_STABLE_COUNT);
        cm.set_bit(0, (unsigned)s, is_stable);
        Base::update_current(cm);
    }
    void setSubsystem2(Subsystem2State s) {
        CM cm = Base::get_current();
        bool is_stable = (unsigned(s) < SUB2_STABLE_COUNT);
        cm.set_bit(1, (unsigned)s, is_stable);
        Base::update_current(cm);
    }
    void setSubsystem3(Subsystem3State s) {
        CM cm = Base::get_current();
        bool is_stable = (unsigned(s) < SUB3_STABLE_COUNT);
        cm.set_bit(2, (unsigned)s, is_stable);
        Base::update_current(cm);
    }
    void setSubsystem4(Subsystem4State s) {
        CM cm = Base::get_current();
        bool is_stable = (unsigned(s) < SUB4_STABLE_COUNT);
        cm.set_bit(3, (unsigned)s, is_stable);
        Base::update_current(cm);
    }

    void clearTempSubsystem1() { CM cm = Base::get_current(); cm.temp[0] = 0; Base::update_current(cm); }
    void clearTempSubsystem2() { CM cm = Base::get_current(); cm.temp[1] = 0; Base::update_current(cm); }
    void clearTempSubsystem3() { CM cm = Base::get_current(); cm.temp[2] = 0; Base::update_current(cm); }
    void clearTempSubsystem4() { CM cm = Base::get_current(); cm.temp[3] = 0; Base::update_current(cm); }

    // build FS via builder lambdas
    static FS build_final(const std::string &name, int prio,
                          std::function<void(CM&)> req_builder,
                          std::function<void(CM&)> forb_builder = [](CM&){},
                          std::function<void(std::vector<CM>&)> except_builder = [](std::vector<CM>&){}) {
        FS f; f.name = name; f.priority = prio;
        req_builder(f.required);
        forb_builder(f.forbidden);
        except_builder(f.except);
        return f;
    }

    // load finals from JSON file (friendly format)
    bool load_finals_from_file(const std::string &path) {
        std::ifstream ifs(path);
        if (!ifs.is_open()) return false;
        json j; ifs >> j;
        Base::import_from_json(j);
        return true;
    }
};

/* ===========================
   6) DEMO main()
   =========================== */

int main() {
    MyStateMachine sm;

    // register callbacks
    sm.on_state_change([](const CombinedMask<4>& cm){
        std::cout << "[state-changed] " << cm.to_string() << std::endl;
    });
    sm.on_final_change([](const std::optional<FinalState<4>>& prev, const std::optional<FinalState<4>>& next){
        std::cout << "[final-changed] from " 
                  << (prev ? prev->name : "NONE")
                  << " -> "
                  << (next ? next->name : "NONE") << "\n";
    });

    // create NormalRun via builder (using enum names in code)
    auto normal = MyStateMachine::build_final("NormalRun", 10,
        [](CombinedMask<4> &req){
            req.stable[0] |= (1ULL << S1_On);
            req.stable[1] |= (1ULL << S2_Running);
        }
    );
    sm.register_final(normal);

    // create Danger: S1_On but forbidden when S1_Initializing present
    auto danger = MyStateMachine::build_final("Danger", 50,
        [](CombinedMask<4> &req){ req.stable[0] |= (1ULL << S1_On); },
        [](CombinedMask<4> &forb){ forb.stable[0] |= (1ULL << S1_On); forb.temp[0] |= (1ULL << S1_Initializing); }
    );
    sm.register_final(danger);

    // Create a final via JSON string (friendly names)
    // sample json array string:
    std::string json_txt = R"([
      {
        "name": "SafeAll",
        "priority": 5,
        "required": [ ["S1_Off"], ["S2_Idle"], ["S3_Disabled"], ["S4_Standby"] ],
        "forbidden": [ {"stable": [], "temp": []}, {"stable": [], "temp":[]}, {"stable": [], "temp": []}, {"stable": [], "temp": []} ],
        "except": []
      }
    ])";
    json jf = json::parse(json_txt);
    sm.import_from_json(jf);

    // pure stable: set S1_On S2_Running -> should match NormalRun
    sm.setSubsystem1(S1_On);
    sm.setSubsystem2(S2_Running);

    auto best = sm.best_match();
    if (best) std::cout << "Best match: " << best->name << "\n"; else std::cout << "No best\n";

    // add temporary S1_Initializing -> Dangerous triggers forbidden and blocks matches
    sm.setSubsystem1(S1_Initializing);
    auto best2 = sm.best_match();
    if (best2) std::cout << "Best after temp: " << best2->name << "\n"; else std::cout << "No best after temp\n";

    // export finals to friendly JSON
    json exported = sm.export_to_json();
    std::cout << "Exported finals JSON: " << exported.dump(2) << "\n";

    return 0;
}
```

---

## 说明 — 你会得到什么

1. **友好 JSON 配置**：`FinalState::from_json` 支持按**枚举名字**配置 `required` / `forbidden` / `except`，格式直观，便于 UI 与人类维护（无需手动写掩码数字）。示例中 `import_from_json` 演示如何导入 JSON 文件/字符串。
2. **倒排索引 + required\_bits\_count 优化**：`StateMachine::collect_candidates` 通过索引快速收集候选 finals，然后按 `required_bits_count`（越多越具体）及 `priority` 优先测试，更快命中最匹配的 final。
3. **读无锁 / 写复制（RCU 风格）**：读者通过 `std::shared_ptr` 快照读取 `finals` 与 `index`，无需写锁；写入（register/unregister/import）在 `writer_mutex_` 下复制并重建索引，最后用 `atomic` 发布新快照。适用于“查找远比注册频繁”的场景。
4. **事件回调**：`on_state_change` / `on_final_change` 提供观察者接口，`update_current` 会触发回调（先状态变更回调、再 final 变更回调）。
5. **并发改进建议实现思路**：我们已经采用 RCU-like 快照；如需更强吞吐可结合 `epoch`/RCU 库实现 lock-free reclamation。
6. **单元测试**：你可把 `FinalState::from_json` / `to_json` 做 round-trip 测试（示例的 Catch2 测试片段之前已经列出）；还可为 `matches` 加大量边界测试（forbidden 与 except 组合）。

---

## 下一步（我可以继续做）

* 把上面的单文件示例拆回**多头文件工程**（包含 CMake 配置、tests、示例 JSON 文件）。
* 把 JSON 配置格式升级：允许用 `"S1":["On","Fault"]` 这样的短名形式（不带前缀），并支持别名。
* 把枚举名表自动生成到一个 header（X-macro 改造）并导出给 UI（例如生成 JSON Schema）。
* 增加更多单元测试（包括并发读写压力测试、index 覆盖率测试、except 边界测试）。

你想先把上述哪个功能（拆分工程 / JSON 别名 / 自动头生成 / 增加测试）落到实处？我可以直接把对应代码和 CMake 配置写好并发给你。

