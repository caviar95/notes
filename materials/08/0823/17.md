下面把 **C++17** 的主要新特性 / 能力按主题列出来，并给出每项的精简示例（可直接用 `-std=c++17` 编译）。我会优先给常用、实用且会改变写法的特性 —— 每个小节都配一个小示例，方便你快速上手。

# 快速总览

* 结构化绑定（structured bindings）
* `if` / `switch` 带初始化语句（init-statement）
* `if constexpr`（编译期分支）
* 折叠表达式（fold expressions）用于可变参数模板
* 类模板参数推导（CTAD）
* 内联变量（inline variables）
* `std::optional` / `std::variant` / `std::any`
* `std::string_view`
* 新的 `<filesystem>`（标准化）
* 并行算法（execution policies）
* `std::byte`
* 属性：`[[nodiscard]]` 等
* 保证的返回值优化（必然 elision/改变值类别）
* 新的命名空间语法 `namespace A::B {}`
* Lambda 捕获 `*this` 的值拷贝 `[ *this ]`（以及通用改进）
* `std::apply` / 若干辅助类型 trait 改进（`std::invoke_result` 等）
* 移除/弃用旧 API（如 `std::random_shuffle` 被移除）

下面逐项展开，带示例。

---

# 结构化绑定（structured bindings）

把 tuple/pair/array/struct 的多个返回值直接“解包”到变量：

```cpp
#include <tuple>
#include <iostream>
#include <array>

std::tuple<int,double> f() { return {42, 3.14}; }

int main(){
    auto [i, d] = f();                 // 结构化绑定
    std::array<int,3> a = {1,2,3};
    auto [x,y,z] = a;                  // 也支持数组
    std::cout << i << " " << d << "\n";
}
```

# `if` / `switch` 带初始化语句

在条件语句中先初始化临时变量（类似 `for`）：

```cpp
#include <map>
#include <string>
#include <iostream>

int main(){
    std::map<std::string,int> m{{"a",1}};
    if (auto it = m.find("a"); it != m.end()) {
        std::cout << it->first << " -> " << it->second << "\n";
    }
}
```

# `if constexpr`（编译期分支）

在模板中根据编译期条件选择代码路径（无未使用分支的编译错误）：

```cpp
#include <type_traits>
#include <iostream>

template<typename T>
void f(T x){
    if constexpr (std::is_integral_v<T>) {
        std::cout << "integral: " << x << "\n";
    } else {
        std::cout << "non-integral\n";
    }
}
int main(){ f(10); f(3.14); }
```

# 折叠表达式（fold expressions）

写变参模板的聚合操作更简洁：

```cpp
#include <iostream>

template<typename... Ts>
auto sum(Ts... xs){
    return (xs + ... + 0);   // 折叠表达式：((x1 + x2) + x3) + ...
}

int main(){ std::cout << sum(1,2,3,4) << "\n"; }
```

# 类模板参数推导（CTAD）

构造类模板对象时，编译器可以推导模板参数（少写 `<...>`）：

```cpp
#include <vector>
#include <utility>

int main(){
    std::pair p(1, 2.0);        // C++17: std::pair<int,double>
    std::vector v{1,2,3};      // std::vector<int>
}
```

你也可以为自定义类提供 `deduction guides`（更高级的用法）。

# 内联变量（inline variables）

允许在头文件定义变量而不产生多重定义（替代 `extern` + 定义）：

```cpp
// header:
inline int global_counter = 0;   // 在多个翻译单元中安全

// usage:
#include <iostream>
int main(){ ++global_counter; std::cout << global_counter; }
```

# `std::optional`, `std::variant`, `std::any`

标准化了“可能为空”的返回值和类型安全的多类型/任意类型容器：

```cpp
#include <optional>
#include <variant>
#include <any>
#include <iostream>

std::optional<int> maybe(bool ok){
    if(ok) return 42;
    return std::nullopt;
}

int main(){
    if(auto v = maybe(true)) std::cout << *v << "\n";

    std::variant<int,std::string> var = "hi";
    if (auto p = std::get_if<std::string>(&var)) std::cout << *p << "\n";

    std::any a = 3.14;
    try { std::cout << std::any_cast<double>(a) << "\n"; }
    catch(...) {}
}
```

# `std::string_view`

轻量的、非拥有的字符串视图（避免拷贝），适合读操作：

```cpp
#include <string_view>
#include <iostream>

void print(std::string_view sv){
    std::cout << sv << "\n";
}

int main(){
    std::string s = "hello";
    print(s);                 // 不拷贝数据
    print("world");           // 字面量也可
}
```

注意生命周期：`string_view` 不拥有数据，必须保证被引用字符串存活。

# `<filesystem>`（标准化）

文件/路径操作进入标准库（替代各平台自实现）：

```cpp
#include <filesystem>
#include <iostream>

int main(){
    namespace fs = std::filesystem;
    for (auto& p : fs::directory_iterator(".")) {
        std::cout << p.path() << "\n";
    }
}
```

# 并行算法（execution policies）

许多 `<algorithm>` 可使用执行策略做并行执行（取决于实现/平台）：

```cpp
#include <algorithm>
#include <execution>
#include <vector>

int main(){
    std::vector<int> v(1000000);
    // fill, shuffle, etc. then:
    std::for_each(std::execution::par, v.begin(), v.end(), [](int &x){ x *= 2; });
}
```

（注意：编译器/标准库实现的并行支持存在差异，实际效果依赖实现）

# `std::byte`

专门表示“字节”而非整型，避免与字符/整数混淆：

```cpp
#include <cstddef>
#include <iostream>

int main(){
    std::byte b = std::byte{0x1};
    auto v = std::to_integer<int>(b);
    std::cout << v << "\n";
}
```

# 属性：`[[nodiscard]]` 等

提示调用者不要忽略返回值：

```cpp
[[nodiscard]] int compute(){ return 42; }
int main(){ compute(); }  // 编译器可发出警告
```

# 保证的返回值优化（Mandatory copy elision）

返回 prvalue 时拷贝/移动可以被保证省略，改变了某些值类别与拷贝时机，代码更高效：

```cpp
#include <string>
std::string make(){
    return std::string("hello"); // C++17 保证直接构造到目标，无复制
}
```

# 新的命名空间语法

```
namespace A::B {
    // 等价于 namespace A { namespace B { ... } }
}
```

# Lambda 捕获 `*this` 的值拷贝

可以把 `this` 的副本捕获进 lambda（移动语义）：

```cpp
#include <iostream>
#include <memory>

struct X {
    int v = 42;
    auto get_lambda(){
        return [*this]{ std::cout << v << "\n"; }; // 捕获 this 的副本
    }
};
```

# `std::apply`

把 tuple 的元素展开成函数参数调用：

```cpp
#include <tuple>
#include <iostream>
#include <functional>

int add(int a,int b){ return a+b; }

int main(){
    auto t = std::make_tuple(1,2);
    std::cout << std::apply(add, t) << "\n"; // 3
}
```

# 移除/弃用旧 API

例如 `std::random_shuffle` 在 C++17 被移除，推荐使用 `std::shuffle`（需要显式随机引擎）。

---

# 小结与实践建议

* **代码风格**：`std::string_view` + `std::optional` + `if constexpr` + 结构化绑定 能显著简化接口和模板代码。
* **性能**：C++17 的保证 RVO/返回值优化 + 内联变量 + `string_view` 带来更少拷贝。
* **库**：`std::filesystem` 和 `std::variant`/`optional` 是工程上常用且能替代很多手写工具的部分。
* **兼容性**：并行算法与 `<filesystem>` 在不同编译器/标准库中的实现成熟度可能不同（使用前在目标平台测试）。

如果你想，我可以：

* 为你把上面某几项（例如 `std::variant`、`std::filesystem`、并行算法）写成更详细的实战小教程（带更多示例和注意点）；
* 或者把这些示例打包成一个可直接编译的单文件 demo（带注释）。

你想先看哪一块更深入？
