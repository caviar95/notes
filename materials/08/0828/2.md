好 — 我把常见的、可马上落地的方案都列清楚了（按可维护性优先），每种方案都给出要点、示例和应该注意的坑。你说已经把对应的 `.so` 链接进来了，我会额外说明在这种“真实库已经存在”的情况下如何覆盖/替换。

# 总体建议（优先级）

1. **首选：依赖注入 + 接口抽象（最稳、最可测试）** — 改造代码以注入一个 interface/抽象客户端，单元测试用 mock/fake。
2. **次优：使用 Google Mock 直接 Mock 生成的 StubInterface（如果 gRPC/proto 已经生成了 StubInterface）**。
3. **无侵入替代：链接/运行时覆盖（LD\_PRELOAD、linker `--wrap`、测试时把你的 stub 放在 link 顺序前）** — 适用于无法修改生产代码但想替换实现的场景。
4. **gRPC 专用：In-process server / channel / testing helpers** — 如果使用 gRPC，可以用 InProcess 或 testing 工具绕开网络。

下面逐项展开并给出代码/命令示例。

---

# 1) 依赖注入 + 接口抽象（强烈推荐）

思路：把直接依赖的 RPC Stub 包一层抽象 `interface`，生产环境里用真实实现包装生成的 stub，测试时注入 mock/fake。

示例（C++）：

```cpp
// IMyRpcClient.h
class IMyRpcClient {
public:
    virtual ~IMyRpcClient() = default;
    virtual grpc::Status DoSomething(grpc::ClientContext* ctx,
                                     const Request& req, Response* resp) = 0;
};

// MyRpcClientImpl.h
class MyRpcClientImpl : public IMyRpcClient {
public:
    explicit MyRpcClientImpl(std::unique_ptr<MyService::StubInterface> stub)
      : stub_(std::move(stub)) {}
    grpc::Status DoSomething(grpc::ClientContext* ctx,
                             const Request& req, Response* resp) override {
        return stub_->DoSomething(ctx, req, resp);
    }
private:
    std::unique_ptr<MyService::StubInterface> stub_;
};

// 使用方（接受接口）
class UserOfRpc {
public:
    explicit UserOfRpc(std::shared_ptr<IMyRpcClient> client) : client_(client) {}
    // ...
private:
    std::shared_ptr<IMyRpcClient> client_;
};
```

测试：

```cpp
// 使用 gmock 创建 mock
class MockMyRpcClient : public IMyRpcClient {
public:
    MOCK_METHOD(grpc::Status, DoSomething,
                (grpc::ClientContext*, const Request&, Response*),
                (override));
};

// 在测试中注入 MockMyRpcClient 并设置 EXPECT_CALL
```

优点：最小副作用、代码可读、容易写单元测试。若能改代码，这是首选。

---

# 2) 直接用 Google Mock Mock StubInterface（适用于 gRPC）

gRPC 的生成代码通常会包含一个 `StubInterface`（注意不同版本生成细节可能不同）。可以直接继承并 MOCK\_METHOD。

示例：

```cpp
class MockMyServiceStub : public MyService::StubInterface {
public:
    MOCK_METHOD(::grpc::Status, DoSomething,
                (::grpc::ClientContext*, const Request&, Response*),
                (override));
};

// 测试中把 client 使用的 stub 换成 MockMyServiceStub。
// 例如把 client 构造签名改为接收 std::unique_ptr<StubInterface>
```

注意：

* `MOCK_METHOD` 的签名要和生成的 StubInterface 中的签名严格一致（包括命名空间）。
* 如果生成的 StubInterface 不易替换（代码直接调用 `MyService::NewStub(channel)` 并持有），可以在 wrapper 层做一层工厂以便替换。

---

# 3) 无侵入：运行时/链接时替换实现（当你不能改生产代码时）

场景：你无法修改/重编译目标二进制，只能在测试时替换符号。常见方法：

### a) LD\_PRELOAD（动态链接时覆盖符号）

写一个共享库实现和真实库相同的符号（对 C 风格符号比较简单；C++ 需注意 name-mangling）。

stub.cpp:

```cpp
extern "C" int rpc_call(int a) {
    // test stub impl
    return 42;
}
```

编译：

```bash
g++ -shared -fPIC -o librpc_stub.so stub.cpp
LD_PRELOAD=./librpc_stub.so ./your_test_binary
```

注意：

* 对 C++ 成员函数或类方法不容易直接覆盖（name mangling，重载），需要用 `nm -D` / `readelf -Ws` 找出符号名或提供 `extern "C"` 的 C 风格 wrapper。
* 如果目标程序是静态链接（或者函数被内联/优化掉），LD\_PRELOAD 无效。

### b) 把你的 stub 放在链接顺序前（测试编译时）

如果你控制测试链接流程，把 `-L/path/to/testlib -lteststub` 放到链接参数的前面或把你的实现的对象文件先链接，链接器会优先用你的符号。对 GNU ld/ld.gold，链接顺序关键。

### c) 链接器 `--wrap`（编译时）

在链接时加 `-Wl,--wrap=target_symbol`，并实现 `__wrap_target_symbol`，必要时调用 `__real_target_symbol`。适用于替换单个函数符号（C 风格更方便）。
示例：

```c
// wrap.c
int __wrap_target(int x) { return 100; }
```

链接：

```bash
g++ test.o -Wl,--wrap=target_symbol -o test
```

注意 `--wrap` 需要在链接时指定，不能在运行时动态生效。

### d) dlopen + dlsym hack

如果生产代码用 `dlopen` 动态加载 .so，你可以在测试中 `dlopen` 目标 .so，然后用 `dlsym` 拿到原始函数，自己实现 wrapper。复杂、脆弱，一般不推荐。

---

# 4) gRPC 专用：In-process server / testing helpers

如果你用的是 gRPC，可以用 in-process 服务器/通道来避免网络调用（把服务端直接跑在同进程内）：

* 启动一个 `grpc::Server`（绑定到 `InProcessChannel` 或 `InProcessServer`），然后客户端创建 `InProcessChannel` 指向该 server。
* 也可以用 gRPC 的 testing utilities（不同版本 API 名称会变），但思路是让服务端直接在测试中返回你期望的响应（实现一个 fake service）。

示例伪代码思路：

```cpp
// 在测试中：创建 FakeServiceImpl : public MyService::Service，
// 在其 RPC 方法里返回预设结果。
// 启动 Server，并用 InProcessChannel 创建 stub 进行调用。
```

优点：行为接近真实 RPC，但没有网络延迟，适合集成/更高层测试。

---

# 5) 已经把真实 .so 链进来了，如何覆盖？

你说“之前因为编译链接问题已经将对应的so链接进来了”，那通常有两种情况：

A. **测试二进制在链接阶段已经把真实 .so 当作依赖**：

* 在测试链接时，把你的 stub 库放在链接顺序的前面（或直接把 stub 的对象文件加入链接），从而覆盖同名符号。
* 或者使用 `-Wl,--wrap` 替换需要的符号（如果可行）。

B. **运行时动态加载（.so 已被加载）**：

* 使用 `LD_PRELOAD` 注入一个替代实现（进程启动前设置环境）。
* 如果进程已启动并且 .so 已被加载，LD\_PRELOAD 无效——需重启进程或修改启动脚本以加入 LD\_PRELOAD。
* 确认符号是否导出（`nm -D libxyz.so | c++filt`），C++ 符号名需要精确匹配。

额外工具：`ldd`、`readelf -Ws libname.so`、`nm -D`、`c++filt`。这些可以帮你确认实际导出的符号名与能否覆盖。

---

# 6) 排查与常见坑

* **C++ 名称修饰**：覆盖 C++ 成员函数/重载难度高；最好通过 wrapper C 函数或接口注入来避免。用 `nm`/`c++filt` 看符号。
* **inline / header-only / templated**：如果函数被内联或优化掉，不能替换。
* **线程安全**：stub 的行为要考虑和生产环境一致（尤其是并发/阻塞行为），否则测试会误报。
* **清理全局状态**：如果 stub 设置全局状态（单例、静态），确保测试之间 reset。
* **gRPC 版本差异**：不同 gRPC 版本生成代码细节不同（是否有 `StubInterface` 等），Mock 策略需稍作调整。

---

# 7) 推荐实践清单（快速参考）

* 能改代码就做：把 RPC client 抽象为接口，注入实现 → 用 gmock 写 Mock。✅
* 如果使用 gRPC，检查是否能直接 Mock `StubInterface` 或启动 InProcess server。✅
* 不能改代码且是动态链接：优先用 LD\_PRELOAD 注入 stub。⚠️
* 不能改代码且是静态/难修改：考虑在测试编译时利用 `--wrap` 或调整链接顺序。⚠️
* 使用 `nm -D`/`readelf -Ws`/`c++filt` 定位符号名。🔍

---

如果你愿意，我可以立刻做下面任一具体操作（我会直接给出可编译的示例）——你选一个，我就给完整代码和具体命令：

1. 改造示例：如何从直接 `NewStub` 改为注入 `StubInterface`（含示例改造步骤）。
2. gmock 示例：基于 gRPC 生成的 `StubInterface` 写 Mock 的完整可编译示例。
3. LD\_PRELOAD 示例：写一个简单的 C/C++ stub `.so`，并展示如何运行测试以覆盖原实现（包含调试命令如 `nm`、`readelf`）。
4. 链接器 `--wrap` 的最小示例（编译/链接命令）。

告诉我你想直接看哪个（或直接回复 “3”），我会把对应的代码和具体编译/运行命令贴出来。


# LD\_PRELOAD 完整示例 —— 从头到尾（含调试命令和注意事项）

下面给出一个**可复制运行**的最小示例，说明如何用 `LD_PRELOAD` 注入一个 stub 动态库来覆盖原库中的函数符号，并演示如何用 `nm` / `readelf` / `c++filt` 检查符号。示例以最常见也最可靠的 **C 风格符号** 为主（C++ 成员函数/方法的覆盖更脆弱，我在后面专门说明处理办法和替代方案）。

---

## 1) 目录结构（示例）

```
ldpreload-example/
  ├─ orig/                # 原始库和程序
  │   ├─ liborig.c
  │   └─ main.c
  └─ stub/
      └─ stub.c
```

---

## 2) 原始库（liborig.so）和主程序

`orig/liborig.c`

```c
#include <stdio.h>

int rpc_call(int a) {
    printf("[liborig] rpc_call called with %d\n", a);
    return a + 1;
}
```

`orig/main.c`

```c
#include <stdio.h>

// 声明会由 liborig 提供
int rpc_call(int a);

int main(void) {
    int r = rpc_call(7);
    printf("[app] rpc_call returned %d\n", r);
    return 0;
}
```

编译命令（在 `ldpreload-example` 根目录运行）：

```bash
# 编译 liborig.so
gcc -fPIC -shared orig/liborig.c -o orig/liborig.so

# 编译主程序并在链接时依赖 liborig.so（示范为运行时用 LD_LIBRARY_PATH 查找）
gcc orig/main.c -Lorig -lorig -Wl,-rpath,'$ORIGIN/../orig' -o orig/test_app
```

说明：

* `-fPIC -shared` 生成共享库 `liborig.so`。
* `-Wl,-rpath,'$ORIGIN/../orig'` 使可执行文件在运行时能找到同目录下的 `liborig.so`（方便演示）。

---

## 3) 写一个 LD\_PRELOAD stub 库

`stub/stub.c`

```c
#include <stdio.h>

// 与原库同名的符号：覆盖 rpc_call
int rpc_call(int a) {
    printf("[stub] intercepted rpc_call, returning 42 (was %d)\n", a);
    return 42;
}
```

编译 stub：

```bash
gcc -fPIC -shared stub/stub.c -o stub/librpc_stub.so
```

---

## 4) 运行演示

先看**不使用** LD\_PRELOAD 的输出（默认使用原库实现）：

```bash
./orig/test_app
```

预期输出：

```
[liborig] rpc_call called with 7
[app] rpc_call returned 8
```

现在用 `LD_PRELOAD` 注入 stub：

```bash
LD_PRELOAD=./stub/librpc_stub.so ./orig/test_app
```

预期输出：

```
[stub] intercepted rpc_call, returning 42 (was 7)
[app] rpc_call returned 42
```

这就说明 `librpc_stub.so` 中的 `rpc_call` 覆盖并拦截了 `liborig.so` 中的符号。

---

## 5) 查看符号表 / 确认哪些符号可被覆盖

在替换前，建议用下面命令确认 `liborig.so` 导出了 `rpc_call`：

```bash
nm -D --defined-only orig/liborig.so
# 或者（更通用）
readelf -Ws orig/liborig.so | c++filt
```

示例（预期）`nm -D` 输出片段：

```
00000000000006a0 T rpc_call
```

`readelf -Ws orig/liborig.so | c++filt` 列表会包含可导出的符号名和类型。若看到 `rpc_call` 在 `T` 段（text/defined）则说明这是可覆盖的动态符号。

如果符号没有出现在 `nm -D` / `readelf -Ws` 的输出中，说明该符号不是动态导出（可能被编译为 local/hidden，或被内联掉/优化掉），这种情况下 `LD_PRELOAD` 无法覆盖它。

常用工具：

* `nm -D libname.so`：查看动态符号（shared object）。
* `readelf -Ws libname.so`：更详细的动态符号表（可配合 `| c++filt` 反混淆 C++ 名）。
* `c++filt`：对 C++ 符号名进行反混淆（demangle），例如 `echo '_ZN3Foo3barEv' | c++filt`。

---

## 6) 常见问题与坑（必须知道）

1. **静态链接或内联函数**：如果目标可执行或库是静态链接（`-static`）或函数被 `inline` 并优化掉，`LD_PRELOAD` 无效。
2. **符号可见性（visibility）**：如果库使用了 `-fvisibility=hidden` 或符号被标记为本地（local），则不能被覆盖。用 `readelf -Ws` 检查 `BIND` 列（GLOBAL/LOCAL、DEFAULT/HIDDEN）。
3. **C++ 成员函数（name mangling）**：C++ 的类方法名称被混淆（mangled），要覆盖需要精确使用 mangled 名称定义（非常脆弱且平台/编译器相关）。**更好的办法**：在代码里增加一个 C 风格 wrapper（例如 `extern "C" int rpc_call_c(int)`）并覆盖该 wrapper；或使用依赖注入改造。
4. **符号版本（versioned symbols）**：某些库使用 symbol versioning（`GLIBC_2.2.5` 等），直接覆盖可能失败或产生版本冲突。`readelf -Ws` 会显示版本信息。
5. **线程与状态**：被替换的函数若有复杂并发或全局状态，stub 要模仿其行为，否则测试结果不可信。
6. **安全与权限**：在 CI 中注入 LD\_PRELOAD 有时受限（容器/安全策略），可能需要调整 runner 配置。

---

## 7) 覆盖 C++ 符号的处理建议（实用建议，不推荐直接用 mangled 名）

覆盖 C++ 成员函数可以做到，但非常易碎（需要精确 mangled 名称，且不同编译器/版本会不同）。推荐更可靠的几种做法：

* **最推荐：在可控代码处增加 C wrapper / 抽象接口**
  例如在库里提供 `extern "C" int rpc_call_c(int a)`，库内部调用 C++ 方法。这样测试时只需覆盖 `rpc_call_c`，非常稳定。

* **如果不能改库**：

  * 用 `nm -D liborig.so | c++filt` 找到确切的 mangled 名，然后在 stub 中定义同名符号（非常脆弱，可能需要手动写符号别名 asm 指令）。
  * 或者使用 `--wrap` 在链接阶段 wrap（如果你能控制测试程序的链接过程）。

* **若实在要覆盖 C++ 方法（示例思路，仅供参考）**：

  1. 找到 mangled 名：`nm -D liborig.so | grep 'Client::Do'` 然后用 `c++filt` 验证。
  2. 写一个 C 函数作为“跳板”，并用汇编/alias 将 mangled symbol 指向你的实现（平台依赖、出错概率高）。
  3. 我通常不推荐这个方法，除非别无选择并且你能在本地调试 symbol table。

---

## 8) 调试加载过程（高级）

如果 `LD_PRELOAD` 没起作用，调试加载过程可以用 `LD_DEBUG` 环境变量：

```bash
LD_DEBUG=bindings LD_PRELOAD=./stub/librpc_stub.so ./orig/test_app 2>&1 | less
```

或者 `LD_DEBUG=all`（输出会非常多）。这些信息可以帮助你确认：

* stub 是否被加载；
* 哪个库提供了目标符号（symbol binding 信息）；
* 符号绑定是否在运行时被解析为 stub。

也可以用 `ldd ./orig/test_app` 看运行时依赖。

---

## 9) 完整流程总结（命令速查）

```bash
# 编译原库和程序（按示例）
gcc -fPIC -shared orig/liborig.c -o orig/liborig.so
gcc orig/main.c -Lorig -lorig -Wl,-rpath,'$ORIGIN/../orig' -o orig/test_app

# 编译 stub
gcc -fPIC -shared stub/stub.c -o stub/librpc_stub.so

# 查看原库导出符号
nm -D --defined-only orig/liborig.so
readelf -Ws orig/liborig.so | c++filt

# 运行（原实现）
./orig/test_app

# 运行（注入 stub）
LD_PRELOAD=./stub/librpc_stub.so ./orig/test_app

# 如果需要调试加载过程
LD_DEBUG=bindings LD_PRELOAD=./stub/librpc_stub.so ./orig/test_app 2>&1 | less
```

---

## 10) 如果你需要我帮你做的事（我可以直接给出）

* 把你项目里**具体的函数签名 / 库名**贴来（特别是如果是 C++：把 `nm -D` 的输出片段贴上来），我可以**为你写出精确的 stub 源代码**，并给出精确的 `LD_PRELOAD` 可执行步骤（以及如果需要的话，自动化的 Makefile）。
* 如果目标是 C++ 成员函数，我可以尝试生成一个替换方案或建议更稳妥的替代（wrapper / DI / `--wrap`）并给出代码示例。

要不要我现在根据你当前项目中的某个符号生成一个具体的 `librpc_stub.so` 源文件和编译命令？如果愿意，直接把 `nm -D yourlib.so | grep <可能的名字>` 的输出贴上来（或者把库名和要替换的函数名告诉我），我会把完整、可编译的 stub 源文件和运行命令发给你。


# 用 CMake 构建（中文快速指南 + 针对你上面 LD\_PRELOAD 示例的完整 CMake 配置）

下面先给出**核心概念与常用命令速查**，然后给出**与你之前 LD\_PRELOAD 示例一模一样的、可直接运行的 CMake 项目**（包含 `orig` 和 `stub` 两个子模块），以及构建/运行命令和注意事项。

---

# 一、CMake 基本概念（要点）

* **CMake 是一个元构建系统**：它生成平台/编译器特定的 Makefile、Ninja 文件或 Visual Studio 工程等。你用 `cmake` 生成构建文件，再用 `cmake --build` 编译。
* **重要文件**：`CMakeLists.txt`（每个目录通常一个）。
* **现代 CMake 推荐做法**：

  * 使用 target 导向 API（`target_link_libraries`, `target_include_directories`, `target_compile_features`），尽量避免全局命令（如 `include_directories`、`add_definitions`）；
  * 把依赖的可见性标注明确为 `PUBLIC` / `PRIVATE` / `INTERFACE`；
  * 使用 `find_package` 或 `FetchContent` 管理外部依赖；
  * 用 **out-of-source build**（在单独 `build/` 目录生成构建文件）。
* **常用命令**：

  * 配置：`cmake -S . -B build`（在源目录运行，生成到 build）
  * 构建：`cmake --build build -- -j4` 或 `cmake --build build --config Release`（multi-config generators）
  * 运行测试：`ctest --test-dir build -V` 或 `cmake --build build --target test`
  * 清理：删除 `build` 目录或用 `cmake --build build --target clean`（取决于 generator）
* **配置构建类型**：`-DCMAKE_BUILD_TYPE=Release`（单配置生成器，如 Makefile/Ninja）。Visual Studio 使用 `--config Release`。

---

# 二、常用 CMake 指令（摘选）

* `cmake_minimum_required(VERSION 3.14)`：指定最低 cmake 版本。
* `project(myproj LANGUAGES C CXX)`：定义项目。
* `add_executable(name sources...)`：添加可执行文件。
* `add_library(name STATIC|SHARED|MODULE sources...)`：添加库。
* `target_link_libraries(target PRIVATE|PUBLIC|INTERFACE lib)`：连接库，控制传播。
* `target_include_directories(target PRIVATE|PUBLIC|INTERFACE path)`：添加 include 路径。
* `target_compile_features(target PUBLIC cxx_std_17)`：要求 C++17。
* `find_package(Pkg REQUIRED)`：查找系统/第三方包。
* `add_subdirectory(subdir)`：把子目录加入构建（常用于 multi-library repo）。
* `install(TARGETS ...)`：安装目标（打包 / 安装用）。

---

# 三、LD\_PRELOAD 示例的 CMake 项目（直接可用）

目录结构（与前面示例一致）：

```
ldpreload-example/
  CMakeLists.txt        # 顶层
  orig/
    CMakeLists.txt
    liborig.c
    main.c
  stub/
    CMakeLists.txt
    stub.c
```

把下面文件内容分别写入（或直接复制整个项目）。

`CMakeLists.txt`（顶层）：

```cmake
cmake_minimum_required(VERSION 3.14)
project(ldpreload_example LANGUAGES C)

add_subdirectory(orig)
add_subdirectory(stub)
```

`orig/CMakeLists.txt`：

```cmake
cmake_minimum_required(VERSION 3.14)

# 创建共享库 liborig.so 和 test_app 可执行文件
add_library(orig SHARED liborig.c)

# 让可执行文件和库放在同一目录，方便运行时用 $ORIGIN 定位
set_target_properties(orig PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/orig
)

add_executable(test_app main.c)

# 把可执行文件也输出到同目录
set_target_properties(test_app PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/orig
)

# 在链接 test_app 时引用 orig 库（相对路径 rpath 让可执行文件在运行时找到 lib）
target_link_libraries(test_app PRIVATE orig)

# 设置运行时 rpath（使用 $ORIGIN 指向可执行文件同目录）
# 这样运行 build/orig/test_app 时会在同目录寻找 liborig.so
set_target_properties(test_app PROPERTIES
    BUILD_RPATH "$ORIGIN"
)
```

`orig/liborig.c`（同你之前内容）：

```c
#include <stdio.h>

int rpc_call(int a) {
    printf("[liborig] rpc_call called with %d\n", a);
    return a + 1;
}
```

`orig/main.c`：

```c
#include <stdio.h>

int rpc_call(int a);

int main(void) {
    int r = rpc_call(7);
    printf("[app] rpc_call returned %d\n", r);
    return 0;
}
```

`stub/CMakeLists.txt`：

```cmake
cmake_minimum_required(VERSION 3.14)

add_library(rpc_stub SHARED stub.c)

# 把 stub 输出到 build/stub 目录，方便 LD_PRELOAD 使用
set_target_properties(rpc_stub PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/stub
)
```

`stub/stub.c`（同你之前内容）：

```c
#include <stdio.h>

int rpc_call(int a) {
    printf("[stub] intercepted rpc_call, returning 42 (was %d)\n", a);
    return 42;
}
```

---

# 四、构建 & 运行（命令）

在项目根目录运行：

```bash
# 1) 生成构建文件（out-of-source）
cmake -S . -B build

# 2) 编译（并行）
cmake --build build -- -j$(nproc)

# 3) 不使用 LD_PRELOAD（跑原实现）
./build/orig/test_app
# 期望输出：
# [liborig] rpc_call called with 7
# [app] rpc_call returned 8

# 4) 使用 LD_PRELOAD 注入 stub
LD_PRELOAD=$(pwd)/build/stub/librpc_stub.so ./build/orig/test_app
# 期望输出：
# [stub] intercepted rpc_call, returning 42 (was 7)
# [app] rpc_call returned 42
```

> Windows / Visual Studio 用户：`LD_PRELOAD` 在 Linux/Unix 生效；Windows 可用类似机制（`Detours`、API hooking），但不是 `LD_PRELOAD`。

---

# 五、如何用 `nm` / `readelf` / `c++filt` 检查符号（和 CMake 一起用）

构建后检查 `liborig.so` 是否导出 `rpc_call`：

```bash
# 列出动态符号
nm -D --defined-only build/orig/liborig.so

# 或更详细
readelf -Ws build/orig/liborig.so | c++filt

# 示例期望能看到类似：
# 00000000000006a0 T rpc_call
```

如果没有看到 `rpc_call`（或看成 local/hidden），说明该符号不能被 LD\_PRELOAD 覆盖（见前面“常见坑”）。

---

# 六、常见问题与调试技巧（与 CMake 相关）

* **找不到 lib 被加载**：确认 `RPATH` / `LD_LIBRARY_PATH`。我们在 CMake 中设置了 `BUILD_RPATH "$ORIGIN"`，这样可执行程序会在其运行目录查找共享库。若不生效，可 `LD_LIBRARY_PATH=build/orig ./build/orig/test_app` 试试。
* **目标文件/库输出目录**：用 `RUNTIME_OUTPUT_DIRECTORY` / `LIBRARY_OUTPUT_DIRECTORY` 控制输出位置，便于测试和部署。
* **多配置生成器（VS）**：需要 `--config Release` 指定配置，且 `RUNTIME_OUTPUT_DIRECTORY` 更复杂（CMake 会把配置名包含路径）。
* **若替换 C++ 成员函数**：尽量不要用 LD\_PRELOAD 覆盖 C++ 成员函数；应在代码层引入 C wrapper 或用依赖注入；如果必须用 LD\_PRELOAD 覆盖 C++ 符号，需 `nm -D | c++filt` 找到 mangled 名并用极其小心的方法覆盖（不推荐）。

---

# 七、进阶建议（若你要把 CMake 用于更复杂项目）

* 使用 `target_compile_features(target PRIVATE cxx_std_17)` 强制 C++ 标准。
* 使用 `FetchContent` 或 `find_package` 管理第三方库（GoogleTest、gRPC、Boost 等）。
* 用 `add_subdirectory` 组织多模块工程，每个模块导出 targets。
* 把测试用例集成到 CTest：`enable_testing()` + `add_test(...)`，然后 `ctest`。
* 写 `install()` 和 `export()` 用于打包/安装、生成 pkg-config/CMake config 文件。
* 对跨编译使用 `-DCMAKE_TOOLCHAIN_FILE=your-toolchain.cmake`。

---

如果你想，我可以：

* 把上面的 CMake 项目打包成一个单个压缩包或直接给出完整的 shell 命令来创建这些文件（我可以把内容贴出，方便你 `cat > file` 一次性粘贴），或者
* 根据你真实项目的 `CMakeLists.txt` 做改进建议或帮你把某个目标改成可被 LD\_PRELOAD 替换（例如添加一个 `extern "C"` wrapper），或帮你写一个更复杂的 CMake 配置（含测试、安装等）。

你要我把上面的示例以可直接 `git clone`/`tar` 的形式完整输出吗？还是现在就把针对你工程的 `CMakeLists.txt` 改造建议贴出来（把你的现有 CMake 内容粘过来）？
