**目录结构**
```
proto-gtest-stub/           # 项目根目录
├── CMakeLists.txt         # 顶层 CMake 配置
├── proto/
│   ├── person.proto       # Proto 定义
│   └── person_stub.bin    # 预先生成的二进制打桩文件
├── src/
│   ├── CMakeLists.txt     # 库工程配置
│   └── person_util.cpp    # 序列化/反序列化工具实现
├── include/
│   └── person_util.h      # 工具头文件
└── tests/
    ├── CMakeLists.txt     # 测试工程配置
    └── test_person.cpp    # GoogleTest 测试代码
```

---

### 1. 根 CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.15)
project(proto_gtest_stub)
set(CMAKE_CXX_STANDARD 17)

# 找到 Protobuf
find_package(Protobuf REQUIRED)
# 包含目录
include_directories(${Protobuf_INCLUDE_DIRS} include)

# 添加子工程
add_subdirectory(src)
add_subdirectory(tests)
```

---

### 2. proto/person.proto
```proto
syntax = "proto3";
package tutorial;

message Person {
  int32 id = 1;
  string name = 2;
  string email = 3;
}
```

---

### 3. 生成打桩文件: person_stub.bin
```bash
# 先生成 C++ 代码：
# protoc --cpp_out=src --descriptor_set_out=proto/person.desc --proto_path=proto proto/person.proto
# 然后运行一个小程序，将 Person 填充并序列化到文件：

cat << 'EOF' > generate_stub.cpp
#include "proto/person.pb.h"
#include <fstream>
int main() {
  tutorial::Person p;
  p.set_id(42);
  p.set_name("Alice Stub");
  p.set_email("alice@example.com");
  std::ofstream out("proto/person_stub.bin", std::ios::binary);
  p.SerializeToOstream(&out);
  return 0;
}
EOF

# 编译并运行：
# g++ generate_stub.cpp proto/person.pb.cc -o gen_stub `pkg-config --cflags --libs protobuf`
# ./gen_stub  # 会生成 proto/person_stub.bin
```

---

### 4. src/CMakeLists.txt
```cmake
# 生成静态库 person_util
add_library(person_util
  person_util.cpp
  ${CMAKE_CURRENT_SOURCE_DIR}/../proto/person.pb.cc
)

target_link_libraries(person_util PUBLIC ${Protobuf_LIBRARIES})
```

---

### 5. include/person_util.h
```cpp
#pragma once
#include <string>
#include <iostream>
#include "person.pb.h"

namespace tutorial {

// 从打桩文件反序列化
inline Person LoadPersonFromStub(const std::string& path) {
    Person p;
    std::ifstream in(path, std::ios::binary);
    if (!in) throw std::runtime_error("Cannot open stub file");
    if (!p.ParseFromIstream(&in))
        throw std::runtime_error("Parse failed");
    return p;
}

}
```

---

### 6. src/person_util.cpp
```cpp
#include "person_util.h"
// 如果有额外逻辑，可以补充
```

---

### 7. tests/CMakeLists.txt
```cmake
# 下载并启用 GoogleTest
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/release-1.12.1.zip
)
FetchContent_MakeAvailable(googletest)

enable_testing()

# 添加测试可执行文件
add_executable(test_person
  test_person.cpp
)
target_link_libraries(test_person
  person_util
  gtest_main
  ${Protobuf_LIBRARIES}
)

gtest_discover_tests(test_person)
```

---

### 8. tests/test_person.cpp
```cpp
#include "gtest/gtest.h"
#include "person_util.h"

TEST(PersonStubTest, DeserializeFromBin) {
  // 指向项目中的打桩文件
  std::string stub_path = PROJECT_SOURCE_DIR "/proto/person_stub.bin";
  tutorial::Person p = tutorial::LoadPersonFromStub(stub_path);

  EXPECT_EQ(p.id(), 42);
  EXPECT_EQ(p.name(), "Alice Stub");
  EXPECT_EQ(p.email(), "alice@example.com");
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

---

**使用方法**：
```bash
mkdir build && cd build
cmake ..
make            # 会生成 gen_stub (可选)，person_util 库，以及 test_person 可执行
ctest --output-on-failure
```
完整项目即为上述目录与文件，展示了如何在 gtest 中结合打桩文件进行反序列化测试。
