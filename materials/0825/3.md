# 掩码状态机（Mask State Machine）设计 — C++ 实现方案

下面给出一个**通用、可扩展**的 C++17 实现方案，满足你提出的需求：

* 支持**多个子系统**（每个子系统用一段位掩码表示）组合成一个 `CombinedState`；
* `CombinedState` 提供常用匹配接口（包含/重叠/按规则匹配）；
* 能把\*\*当前组合状态匹配到一组“最终状态（FinalState）”\*\*并返回可匹配到的最终状态集合；
* 能从一组组合状态中按自定义比较规则（优先级 / 字典序）得到**最高的组合状态**；
* 提供便捷的组合/交/比较/可视化方法，并考虑可扩展与线程安全（注册/查询分离，注册可在启动阶段进行）。

下面先给出完整实现代码，随后给出说明和示例。

---

## 代码（C++17）

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// CombinedState: N 个子系统，每个子系统用 uint64_t 表示位集合（支持每子系统最多64位）
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem (bit0..bit63)

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // 检查 this 是否包含 other（即 other 的每一位都在 this 中）
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // 检查对每个子系统，都至少存在一位重叠（用于要求每个子系统都匹配到某些状态）
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // 检查任意子系统存在重叠（任意一处匹配就算匹配）
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // 验证每个子系统的位宽不超过允许的 widths（由外部传入配置）
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            if (widths[i] <= 0 || widths[i] > 64) throw std::invalid_argument("invalid width");
            if (widths[i] < 64) {
                uint64_t mask = (widths[i] == 64) ? ~uint64_t(0) : ((uint64_t(1) << widths[i]) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << widths[i];
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    // 将 CombinedState 转为可读字符串（便于调试）
    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// FinalState: 一个最终态/目标态，使用一个 CombinedState 的掩码描述，附带名字与优先级
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // 哪些组合状态能匹配到这个最终态（掩码含义由使用者定义）
    int priority = 0;         // 用于排序/选择最高最终态，数字越大优先级越高

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// MaskStateMachine: 管理 FinalState 注册与匹配逻辑
// 比较规则：优先级（越大越优先），若优先级相同，按 lexicographic（从 subs[0] ... subs[N-1]）比较 CombinedState 的数值大小（可视为“权重”）
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // widths: 每个子系统允许的位宽（用于 validate）
    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // 注册最终态（线程安全：建议在初始化阶段注册）
    void register_final(const FS& f) {
        // validate mask fits width
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // 返回当前状态匹配到的所有最终态（匹配策略可选）
    // match_mode:
    //   "contains" : final.mask is subset of current -> current.contains_all(final.mask)
    //   "overlaps_all_subsystems": each subsystem has at least one overlapping bit
    //   "overlaps_any": any subsystem overlap
    std::vector<FS> match_final_states(const CS& current, const std::string& match_mode = "contains") const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            if (match_mode == "contains") {
                ok = current.contains_all(f.mask);
            } else if (match_mode == "overlaps_all_subsystems") {
                ok = current.overlaps_all_subsystems(f.mask);
            } else if (match_mode == "overlaps_any") {
                ok = current.overlaps_any(f.mask);
            } else {
                throw std::invalid_argument("unknown match_mode");
            }
            if (ok) out.push_back(f);
        }
        // sort by priority desc, then by lexicographic mask desc (so highest first)
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
        });
        return out;
    }

    // 给定一组 CombinedState，从中选出“最高”的一个（依据与 finals 无关的纯比较）
    // 规则：先比较某个权重序列（priority_weights；如果不提供则按 subs 索引顺序作为显著性，从低索引更重要）
    // 返回 std::optional<CS> （如果输入为空则返回 std::nullopt）
    std::optional<CS> highest_of_set(const std::vector<CS>& set,
                                     const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // 计算带权值比较：对每个子系统，权 * value，加和比较（注意 uint64->unsigned long long）
                __int128 va = 0, vb = 0;
                for (size_t i = 0; i < N; ++i) {
                    va = va * (__int128(priority_weights->at(i) + 1)) + __int128(a.subs[i]);
                    vb = vb * (__int128(priority_weights->at(i) + 1)) + __int128(b.subs[i]);
                }
                return va > vb;
            } else {
                // 默认 lexicographic 从 subs[0] ... subs[N-1]，subs[0] 更重要（高位）
                return lexicographic_mask_cmp<N>(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) {
            if (cmp(set[i], *best)) best = &set[i];
        }
        return *best;
    }

    // 获取已注册的所有 FinalState（只读）
    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    // helper lexicographic comparator: 返回 >0 if a> b, 0 if equal, <0 if a<b
    template <size_t M>
    static int lexicographic_mask_cmp(const CombinedState<M>& a, const CombinedState<M>& b) {
        for (size_t i = 0; i < M; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// ----------------- 简短示例 -----------------
/*
假设有4个子系统（N=4），每个子系统用8位（0..7）来表示状态（最多 8 个可组合状态位）。
例如：
 - 子系统0 位0 表示 Ready，位1 表示 Busy，位2 表示 Error ...
 - 子系统1 的位表示其它子系统状态细分
*/
void example() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8}; // 每个子系统 8 位
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // 定义 final states：
    // Final A: 要求 子系统0 固定位0（0x1） && 子系统2 任意位（示例）
    CS finalA_mask = CS::from_array({{0x1, 0x0, 0xFF, 0x0}});
    m.register_final(FS("FinalA", finalA_mask, 10)); // priority 10

    // Final B:
    CS finalB_mask = CS::from_array({{0x2, 0x04, 0x00, 0x00}});
    m.register_final(FS("FinalB", finalB_mask, 5));

    // 当前组合状态（来自运行时）
    CS cur = CS::from_array({{0x3, 0x04, 0x01, 0x00}}); // sub0 bits 0 and 1, sub1 bit2, sub2 bit0

    // match finals by "contains"（即 cur 包含 final.mask）
    auto matches = m.match_final_states(cur, "contains");
    std::cout << "Matched finals (contains):\n";
    for (const auto& f : matches) {
        std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask.to_string() << "\n";
    }

    // 从一个组合状态集合中选最高
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest: " << highest->to_string() << "\n";
}
```

---

## 设计说明（为什么这样设计 & 如何使用）

### 1. 子系统 & 位宽

* 每个子系统用一个 `uint64_t` 存放位集合（因此每个子系统最多支持 64 个状态位）。整体 `CombinedState` 是 `std::array<uint64_t, N>`。
* 在 `MaskStateMachine` 构造时传入 `widths`（每个子系统位宽），用于在注册/验证时防止越界（例如你的例子 4 个子系统，每个 8 位，就是 `{8,8,8,8}`）。

### 2. 匹配语义（三种常见）

* `contains`：`current.contains_all(final.mask)` —— final.mask 的所有位都必须在 current 中（用于“必须完全满足某些必需位”的场景）；
* `overlaps_all_subsystems`：对每个子系统都要求至少有一个位重叠（用于“每个子系统都必须处于某个可接受状态”的场景）；
* `overlaps_any`：任意子系统有重叠即视为匹配（较宽松）。

你可以按需扩展更多匹配规则，例如“子系统 i 要求包含某个位集合并且子系统 j 要求至少有一位重叠”——可以把规则封装成对象/策略。

### 3. FinalState 与优先级

* `FinalState` 包含 `mask`、`name`、`priority`。匹配返回结果默认按 `priority` 降序排序；priority 相同则用 `lexicographic` 的掩码比较作为 tiebreaker（可改为其它策略）。

### 4. 从集合中选出“最高”组合状态

* `highest_of_set` 提供两种比较：默认按 lexicographic（从 subs\[0] 开始，越高越“更重要”），或提供 `priority_weights`（每个子系统的权值，用以合并比较）。
* 比较可根据实际业务调整：你可以把某个子系统当作“高权重”主导位。

### 5. 扩展性与线程安全

* 该实现把注册（`register_final`）与查询（`match_final_states`）分离。若需要并发环境：

  * 在启动阶段完成所有 `register_final`，之后只做只读 `match_final_states`（无需加锁）。
  * 若需运行时动态注册/注销，则在 `finals_` 上加互斥（或使用读写锁 / atomic shared\_ptr 替换 vector）以保证并发安全。

### 6. 关于“最高的组合状态”的另一种理解

* 有时“最高”并不是按位数值比较，而是“位的位置更高优先”或“包含更多位优先”。你可以定义 `CombinedState` 的 `score()` 函数来量化（例如加权和、位数计数、或某些关键位权重），然后在 `highest_of_set` 中使用这个 `score`。

---

## 使用场景举例（回到你之前提到的4个子系统，每个8位）

* 你可以把一个 32 位整型看成 4 个子系统各 8 位的集合，但更灵活的是把每个子系统独立为 `uint64_t`，这样当需要扩展到不均匀的位数（例如子系统0用8位、子系统1用12位）时也很方便。
* 示例中展示了如何注册两个 FinalState，并把当前状态匹配到能到达的 FinalState 列表中，按 priority 排序返回。

---

如果你愿意我可以：

* 把示例扩展为完整可运行的 demo（包含编译并运行的 `main()`）；
* 把 `match` 规则扩展为可配置的策略对象（策略模式），并演示如何基于 JSON 配置加载规则；
* 改用位字段拼接成单一大整数（比如在已知各子系统固定宽度时）以获得更快的比较；或改为可变宽度（runtime widths）并提供序列化/反序列化方法。

你想要哪个方向我就直接把代码补全成可编译的 demo（不再问 clarifying question）？


好——我明白你的规则：**“最高最终状态匹配”**的语义是：只要**任意一个子系统**当前状态能够单独匹配到某个最终态（按子系统级别的匹配规则），就把该最终态作为候选；在所有候选最终态中选择优先级最高的那个并返回。下面我把之前的实现扩展出一个清晰、可复用的方法 `highest_final_by_any_subsystem`，并给出示例和说明。

---

### 关键实现（在之前 `MaskStateMachine<N>` 类中加入）

```cpp
// 返回任意子系统级别能匹配到的最高 FinalState（按 priority -> lexicographic mask）
template <size_t N>
std::optional<FinalState<N>> highest_final_by_any_subsystem(
    const CombinedState<N>& current,
    const std::string& per_subsystem_match = "contains"    // "contains" 或 "overlaps"
) const {
    std::vector<FinalState<N>> candidates;
    candidates.reserve(finals_.size());

    for (const auto &f : finals_) {
        bool matched_by_some_sub = false;
        for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
            uint64_t cur_bits = current.subs[i];
            uint64_t final_bits = f.mask.subs[i];

            if (per_subsystem_match == "contains") {
                // 子系统 i 的所有 final_bits 都被 current.subs[i] 包含
                if ((cur_bits & final_bits) == final_bits && final_bits != 0) {
                    matched_by_some_sub = true;
                }
            } else if (per_subsystem_match == "overlaps") {
                // 子系统 i 存在任意 bit 重叠
                if ((cur_bits & final_bits) != 0) {
                    matched_by_some_sub = true;
                }
            } else {
                throw std::invalid_argument("unknown per_subsystem_match mode");
            }
        }
        if (matched_by_some_sub) candidates.push_back(f);
    }

    if (candidates.empty()) return std::nullopt;

    // 选择最高：按 priority 降序，然后按掩码字典序降序
    std::sort(candidates.begin(), candidates.end(), [](const FinalState<N>& a, const FinalState<N>& b){
        if (a.priority != b.priority) return a.priority > b.priority;
        return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
    });

    return candidates.front();
}
```

---

### 语义说明与可配置点

* `per_subsystem_match == "contains"`：当某个最终态的**在某个子系统上的要求位**被当前子系统状态**完全包含**时（即该子系统就足以满足该最终态在该子系统上的需求），就把该最终态作为候选。通常用在“final 的某些子系统位是必需位（must-have）”的语义下。
* `per_subsystem_match == "overlaps"`：只要某子系统有位与 final 在该子系统上的位**任意重叠**，就视为该子系统“能匹配到”这个 final。语义更宽松，适合“部分匹配也能触发更高态”的场景。
* 如果多个最终态都被某些子系统匹配到，函数会按 `priority`（更大优先）并以 lexicographic 掩码作为 tiebreaker 来选出**单个最高最终态**返回。
* 如果没有任何子系统匹配到任何 final，则返回 `std::nullopt`。

---

### 小示例（基于之前的 `example()`）

```cpp
// 在 example() 注册完 FinalA (prio 10) 和 FinalB (prio 5) 后：
CS cur = CS::from_array({{0x04, 0x00, 0x00, 0x00}}); // 只有子系统0的 bit2 被置位

// 假设 FinalC 的 mask 在子系统0 上为 0x04，priority = 20
CS finalC_mask = CS::from_array({{0x04,0x00,0x00,0x00}});
m.register_final(FS("FinalC", finalC_mask, 20));

// 使用子系统级别的 contains 匹配
auto best = m.highest_final_by_any_subsystem(cur, "contains");
if (best) {
    std::cout << "Best final by any subsystem: " << best->name
              << " (prio=" << best->priority << ")\n";
} else {
    std::cout << "No final matched by any single subsystem.\n";
}
```

在上面例子里，`cur` 的子系统0 包含 `FinalC` 在子系统0 上的位，因此 `FinalC` 会成为候选，且因其 priority=20 为最高被返回。

---

### 注意事项与建议

1. **子系统位语义要清晰**：决定使用 `contains` 还是 `overlaps`，取决于 final 的掩码如何定义（是“必需位”还是“提示位/部分匹配即可”）。
2. **避免误触发**：若某些 final 的掩码在多个子系统均为 0（即没有在某子系统上设置任何位），这会影响匹配逻辑；在实现里 `contains` 检查我额外排除了 `final_bits != 0` 的情形，避免把“空位”当成匹配条件，你也可以在 FinalState 定义阶段强制要求每个 final 在至少一个子系统上有非零位。
3. **并发**：此方法读取 `finals_`，若运行时可能动态注册/注销 final，请加锁或采用读写锁/原子替换容器策略。
4. **可扩展性**：如果你后来需要更复杂的规则（例如“某子系统匹配到 X 且另一个子系统匹配到 Y 时才视为候选”），建议把匹配规则拆成策略对象并在注册 final 时把规则一并注册。

---

如果你愿意我可以：

* 把上述方法合并进完整类并给出可编译的 `main()` demo；
* 或者直接把匹配规则变成策略模式（`PerSubsystemMatchPolicy`），并展示如何用 JSON 配置 final 的匹配策略（例如某 final 需要 `contains` 在子系统0 且 `overlaps` 在子系统2）。

你想要哪个（我直接把代码写成可编译 demo）？


我已把修改后的**完整、可编译 C++ 源文件**放到画布（名为 **Mask State Machine**）里，你可以在旁边查看/复制。下面是对代码能力的说明、设计注意点和可能的提示（prompt）修正建议 —— 便于你快速调整或让我继续迭代。

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// Mask State Machine - single-file demo
// C++17

// -------------------- CombinedState --------------------
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // Checks whether 'this' contains all bits from other
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // For each subsystem, there must be at least one overlapping bit
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // Any subsystem overlaps
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // Validate each subsystem does not use bits beyond 'widths'
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            int w = widths[i];
            if (w <= 0 || w > 64) throw std::invalid_argument("invalid width");
            if (w < 64) {
                uint64_t mask = ((uint64_t(1) << w) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << w;
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// -------------------- FinalState --------------------
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // mask that describes bits relevant for this final
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// -------------------- Match enums --------------------
enum class MatchMode {
    Contains,            // current contains final.mask
    OverlapsAllSubsystems,
    OverlapsAny
};

enum class PerSubsystemMatch {
    Contains, // per-subsystem: final_bits fully contained in current.subs[i]
    Overlaps  // per-subsystem: any overlap
};

// -------------------- MaskStateMachine --------------------
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // Register a final state (call validate on mask)
    void register_final(const FS& f) {
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // Match finals according to high-level MatchMode
    std::vector<FS> match_final_states(const CS& current, MatchMode mode = MatchMode::Contains) const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            switch (mode) {
                case MatchMode::Contains: ok = current.contains_all(f.mask); break;
                case MatchMode::OverlapsAllSubsystems: ok = current.overlaps_all_subsystems(f.mask); break;
                case MatchMode::OverlapsAny: ok = current.overlaps_any(f.mask); break;
                default: throw std::invalid_argument("unknown match mode");
            }
            if (ok) out.push_back(f);
        }
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return out;
    }

    // Highest final matched by any single subsystem (per-subsystem policy: Contains or Overlaps)
    std::optional<FS> highest_final_by_any_subsystem(const CS& current, PerSubsystemMatch policy = PerSubsystemMatch::Contains) const {
        std::vector<FS> candidates;
        candidates.reserve(finals_.size());

        for (const auto &f : finals_) {
            bool matched_by_some_sub = false;
            for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
                uint64_t cur_bits = current.subs[i];
                uint64_t final_bits = f.mask.subs[i];
                if (final_bits == 0) continue; // skip empty per-subsystem requirement
                if (policy == PerSubsystemMatch::Contains) {
                    if ((cur_bits & final_bits) == final_bits) matched_by_some_sub = true;
                } else { // Overlaps
                    if ((cur_bits & final_bits) != 0) matched_by_some_sub = true;
                }
            }
            if (matched_by_some_sub) candidates.push_back(f);
        }

        if (candidates.empty()) return std::nullopt;

        std::sort(candidates.begin(), candidates.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return candidates.front();
    }

    // From a set of CombinedState pick the highest according to optional priority weights (or lexicographic)
    std::optional<CS> highest_of_set(const std::vector<CS>& set, const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // compute weighted lexicographic-like comparison
                for (size_t i = 0; i < N; ++i) {
                    if (priority_weights->at(i) != 0) {
                        if (a.subs[i] != b.subs[i]) return a.subs[i] * priority_weights->at(i) > b.subs[i] * priority_weights->at(i);
                    }
                }
                return lexicographic_mask_cmp(a, b) > 0;
            } else {
                return lexicographic_mask_cmp(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (cmp(set[i], *best)) best = &set[i];
        return *best;
    }

    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    static int lexicographic_mask_cmp(const CS& a, const CS& b) {
        for (size_t i = 0; i < N; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// -------------------- Demo main --------------------
int main() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8};
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // Register some final states
    CS maskA = CS::from_array({{0x01, 0x00, 0xFF, 0x00}}); // final A needs sub0 bit0 and sub2 any
    CS maskB = CS::from_array({{0x02, 0x04, 0x00, 0x00}});
    CS maskC = CS::from_array({{0x04, 0x00, 0x00, 0x00}});

    m.register_final(FS("FinalA", maskA, 10));
    m.register_final(FS("FinalB", maskB, 5));
    m.register_final(FS("FinalC", maskC, 20));

    // Current state
    CS cur = CS::from_array({{0x04, 0x04, 0x01, 0x00}});

    // 1) match by "contains"
    auto matched_contains = m.match_final_states(cur, MatchMode::Contains);
    std::cout << "Matched (Contains):\n";
    for (auto &f : matched_contains) std::cout << "  " << f.name << " prio=" << f.priority << " mask=" << f.mask.to_string() << "\n";

    // 2) match by overlaps_any
    auto matched_any = m.match_final_states(cur, MatchMode::OverlapsAny);
    std::cout << "Matched (OverlapsAny):\n";
    for (auto &f : matched_any) std::cout << "  " << f.name << " prio=" << f.priority << "\n";

    // 3) highest final by any subsystem (contains)
    auto best_by_sub_contains = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Contains);
    if (best_by_sub_contains) std::cout << "Best by any-subsystem (Contains): " << best_by_sub_contains->name << " prio=" << best_by_sub_contains->priority << "\n";
    else std::cout << "No best final (Contains)\n";

    // 4) highest final by any subsystem (overlaps)
    auto best_by_sub_overlaps = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Overlaps);
    if (best_by_sub_overlaps) std::cout << "Best by any-subsystem (Overlaps): " << best_by_sub_overlaps->name << " prio=" << best_by_sub_overlaps->priority << "\n";
    else std::cout << "No best final (Overlaps)\n";

    // 5) highest of a set
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest of set: " << highest->to_string() << "\n";

    return 0;
}

```

# 能力概览（代码提供的功能）

* 支持任意数量子系统（模板参数 `N`），每个子系统用 `uint64_t` 保存位掩码。
* 每个子系统可配置位宽（在 `MaskStateMachine` 构造时传入 `widths`），会在注册 `FinalState` 时做验证以防越界。
* `CombinedState` 提供常用操作：

  * 位或（`|`）、位与（`&`）、相等比较；
  * `contains_all`（当前包含另一个掩码的所有位）；
  * `overlaps_all_subsystems`（每个子系统都有至少一个重叠位）；
  * `overlaps_any`（任意子系统有重叠）；
  * `validate_widths` 与 `to_string`（调试友好）。
* `FinalState`：包含 `name`、`mask` 和 `priority`。
* `MaskStateMachine` 提供：

  * `register_final()`：注册最终态（并验证掩码合法性）；
  * `match_final_states(current, MatchMode)`：按三种高层匹配模式返回所有匹配的最终态，按 `priority`（降序）和掩码字典序排序；
  * `highest_final_by_any_subsystem(current, PerSubsystemMatch)`：实现你要求的“**只要任意一个子系统能够匹配到更高的最终态，就返回该最终态**”策略；支持两种子系统级别策略：`Contains`（子系统必须完全包含 final 在该子系统的位）和 `Overlaps`（任意重叠即可）；
  * `highest_of_set(...)`：从一组 `CombinedState` 里选最高项（默认字典序，或用可选的权重向量来自定义比较）。
* 含一个 `main()` 演示：注册若干 Final、演示三类匹配、演示“最高最终态匹配（按任意子系统）”、演示从集合选择最高组合状态。

# 设计与行为细节（重要）

* **优先级决定最终态优先顺序**：`priority` 数字越大越优先；相同优先级时使用掩码字典序（从 `subs[0]` 到 `subs[N-1]`）作为 tiebreaker。
* 在 `highest_final_by_any_subsystem` 内，默认跳过 `final.mask` 在某子系统上的空位（`final_bits == 0`），以避免把“没有要求”的子系统当成匹配触发器。
* `PerSubsystemMatch::Contains` 更严格（用于 final 在某子系统上定义了必需位）；`Overlaps` 更宽松（用于提示/模糊匹配）。
* 当前代码对 `finals_` 的注册和查询**未**做并发保护：推荐在初始化阶段完成注册，之后读取即可无锁使用；如果需要运行时动态注册/注销，请用互斥/读写锁或用 `std::shared_ptr<std::vector<...>>` 原子替换策略。

# 可选改进点（我可以帮助实现任意一项）

* 把 `MatchMode` / `PerSubsystemMatch` 做成策略对象（策略模式），使每个 `FinalState` 能携带自定义匹配策略（例如：finalA 用 `contains`，finalB 用 `overlaps`）。
* 支持按子系统组合的更复杂规则（例如：final 要求 `sub0` contains X **且** (`sub1` overlaps Y **或** `sub2` contains Z））。可通过注册时附带布尔表达式或小型规则树实现。
* 动态注册/注销：增加 `std::mutex` 或 `std::shared_mutex` 保护 `finals_`，或使用无锁读多写少的原子交换容器。
* 序列化/反序列化：把 final 状态列表导出为 JSON（便于 UI），并可以从 JSON 恢复。
* 性能优化：当 N 很大或 final 很多时，可建立索引（例如按子系统位建立倒排表）以加速 `highest_final_by_any_subsystem` 的查找。
* 增加单元测试和 fuzz 测试示例，确保匹配语义在边界位（如位宽边界、mask 全 0）时符合预期。

# 测试与验证建议（快速检查点）

* 测试 `Contains` 与 `Overlaps` 在边界位：例如 final.mask 在某子系统为 `0`（应被视作无要求）；
* 测试多个 final 同时满足条件：优先级较大的应被返回；
* 测试 `highest_of_set` 的比较策略是否符合你的业务（如果不是，告诉我你期望如何比较）。
* 测试在 N、各子系统宽度与 mask 较大时是否越界（构造非法 mask 应抛异常）。

# 如何提示我改动（示例 prompt 模板）

* 如果你想我把“每个 final 携带自己的匹配策略”实现成策略对象：`请把 FinalState 扩展为包含一个匹配策略对象，并在 register_final 时允许传入 lambda 或策略类型。给出完整代码。`
* 要我把注册线程安全化并实现运行时注销：`请把 MaskStateMachine 修改为线程安全，支持 register 和 unregister（根据 name），并给出使用示例。`
* 要我把匹配模式从 enum 改成可由 JSON 指定：`请实现从 JSON 加载 final 列表，并支持 per-final 指定 \"per_subsystem_match\": \"contains\"/\"overlaps\"。给出示例 JSON 与完整代码。`
* 如果你想改变 tiebreaker（比如“包含更多位优先而不是掩码字典序”）：`请修改排序规则使得优先级相同的 final 中包含位数更多的 final 优先；如果位数相同再用字典序。`

---

如果你希望，我可以直接按你选中的改动把源文件更新为新的版本（我会把改动后的完整源码放到画布并在此说明）。你想现在先让我把哪个改进/调整实现为可编译 demo？
