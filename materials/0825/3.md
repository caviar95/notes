# 掩码状态机（Mask State Machine）设计 — C++ 实现方案

下面给出一个**通用、可扩展**的 C++17 实现方案，满足你提出的需求：

* 支持**多个子系统**（每个子系统用一段位掩码表示）组合成一个 `CombinedState`；
* `CombinedState` 提供常用匹配接口（包含/重叠/按规则匹配）；
* 能把\*\*当前组合状态匹配到一组“最终状态（FinalState）”\*\*并返回可匹配到的最终状态集合；
* 能从一组组合状态中按自定义比较规则（优先级 / 字典序）得到**最高的组合状态**；
* 提供便捷的组合/交/比较/可视化方法，并考虑可扩展与线程安全（注册/查询分离，注册可在启动阶段进行）。

下面先给出完整实现代码，随后给出说明和示例。

---

## 代码（C++17）

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// CombinedState: N 个子系统，每个子系统用 uint64_t 表示位集合（支持每子系统最多64位）
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem (bit0..bit63)

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // 检查 this 是否包含 other（即 other 的每一位都在 this 中）
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // 检查对每个子系统，都至少存在一位重叠（用于要求每个子系统都匹配到某些状态）
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // 检查任意子系统存在重叠（任意一处匹配就算匹配）
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // 验证每个子系统的位宽不超过允许的 widths（由外部传入配置）
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            if (widths[i] <= 0 || widths[i] > 64) throw std::invalid_argument("invalid width");
            if (widths[i] < 64) {
                uint64_t mask = (widths[i] == 64) ? ~uint64_t(0) : ((uint64_t(1) << widths[i]) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << widths[i];
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    // 将 CombinedState 转为可读字符串（便于调试）
    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// FinalState: 一个最终态/目标态，使用一个 CombinedState 的掩码描述，附带名字与优先级
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // 哪些组合状态能匹配到这个最终态（掩码含义由使用者定义）
    int priority = 0;         // 用于排序/选择最高最终态，数字越大优先级越高

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// MaskStateMachine: 管理 FinalState 注册与匹配逻辑
// 比较规则：优先级（越大越优先），若优先级相同，按 lexicographic（从 subs[0] ... subs[N-1]）比较 CombinedState 的数值大小（可视为“权重”）
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // widths: 每个子系统允许的位宽（用于 validate）
    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // 注册最终态（线程安全：建议在初始化阶段注册）
    void register_final(const FS& f) {
        // validate mask fits width
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // 返回当前状态匹配到的所有最终态（匹配策略可选）
    // match_mode:
    //   "contains" : final.mask is subset of current -> current.contains_all(final.mask)
    //   "overlaps_all_subsystems": each subsystem has at least one overlapping bit
    //   "overlaps_any": any subsystem overlap
    std::vector<FS> match_final_states(const CS& current, const std::string& match_mode = "contains") const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            if (match_mode == "contains") {
                ok = current.contains_all(f.mask);
            } else if (match_mode == "overlaps_all_subsystems") {
                ok = current.overlaps_all_subsystems(f.mask);
            } else if (match_mode == "overlaps_any") {
                ok = current.overlaps_any(f.mask);
            } else {
                throw std::invalid_argument("unknown match_mode");
            }
            if (ok) out.push_back(f);
        }
        // sort by priority desc, then by lexicographic mask desc (so highest first)
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
        });
        return out;
    }

    // 给定一组 CombinedState，从中选出“最高”的一个（依据与 finals 无关的纯比较）
    // 规则：先比较某个权重序列（priority_weights；如果不提供则按 subs 索引顺序作为显著性，从低索引更重要）
    // 返回 std::optional<CS> （如果输入为空则返回 std::nullopt）
    std::optional<CS> highest_of_set(const std::vector<CS>& set,
                                     const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // 计算带权值比较：对每个子系统，权 * value，加和比较（注意 uint64->unsigned long long）
                __int128 va = 0, vb = 0;
                for (size_t i = 0; i < N; ++i) {
                    va = va * (__int128(priority_weights->at(i) + 1)) + __int128(a.subs[i]);
                    vb = vb * (__int128(priority_weights->at(i) + 1)) + __int128(b.subs[i]);
                }
                return va > vb;
            } else {
                // 默认 lexicographic 从 subs[0] ... subs[N-1]，subs[0] 更重要（高位）
                return lexicographic_mask_cmp<N>(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) {
            if (cmp(set[i], *best)) best = &set[i];
        }
        return *best;
    }

    // 获取已注册的所有 FinalState（只读）
    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    // helper lexicographic comparator: 返回 >0 if a> b, 0 if equal, <0 if a<b
    template <size_t M>
    static int lexicographic_mask_cmp(const CombinedState<M>& a, const CombinedState<M>& b) {
        for (size_t i = 0; i < M; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// ----------------- 简短示例 -----------------
/*
假设有4个子系统（N=4），每个子系统用8位（0..7）来表示状态（最多 8 个可组合状态位）。
例如：
 - 子系统0 位0 表示 Ready，位1 表示 Busy，位2 表示 Error ...
 - 子系统1 的位表示其它子系统状态细分
*/
void example() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8}; // 每个子系统 8 位
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // 定义 final states：
    // Final A: 要求 子系统0 固定位0（0x1） && 子系统2 任意位（示例）
    CS finalA_mask = CS::from_array({{0x1, 0x0, 0xFF, 0x0}});
    m.register_final(FS("FinalA", finalA_mask, 10)); // priority 10

    // Final B:
    CS finalB_mask = CS::from_array({{0x2, 0x04, 0x00, 0x00}});
    m.register_final(FS("FinalB", finalB_mask, 5));

    // 当前组合状态（来自运行时）
    CS cur = CS::from_array({{0x3, 0x04, 0x01, 0x00}}); // sub0 bits 0 and 1, sub1 bit2, sub2 bit0

    // match finals by "contains"（即 cur 包含 final.mask）
    auto matches = m.match_final_states(cur, "contains");
    std::cout << "Matched finals (contains):\n";
    for (const auto& f : matches) {
        std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask.to_string() << "\n";
    }

    // 从一个组合状态集合中选最高
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest: " << highest->to_string() << "\n";
}
```

---

## 设计说明（为什么这样设计 & 如何使用）

### 1. 子系统 & 位宽

* 每个子系统用一个 `uint64_t` 存放位集合（因此每个子系统最多支持 64 个状态位）。整体 `CombinedState` 是 `std::array<uint64_t, N>`。
* 在 `MaskStateMachine` 构造时传入 `widths`（每个子系统位宽），用于在注册/验证时防止越界（例如你的例子 4 个子系统，每个 8 位，就是 `{8,8,8,8}`）。

### 2. 匹配语义（三种常见）

* `contains`：`current.contains_all(final.mask)` —— final.mask 的所有位都必须在 current 中（用于“必须完全满足某些必需位”的场景）；
* `overlaps_all_subsystems`：对每个子系统都要求至少有一个位重叠（用于“每个子系统都必须处于某个可接受状态”的场景）；
* `overlaps_any`：任意子系统有重叠即视为匹配（较宽松）。

你可以按需扩展更多匹配规则，例如“子系统 i 要求包含某个位集合并且子系统 j 要求至少有一位重叠”——可以把规则封装成对象/策略。

### 3. FinalState 与优先级

* `FinalState` 包含 `mask`、`name`、`priority`。匹配返回结果默认按 `priority` 降序排序；priority 相同则用 `lexicographic` 的掩码比较作为 tiebreaker（可改为其它策略）。

### 4. 从集合中选出“最高”组合状态

* `highest_of_set` 提供两种比较：默认按 lexicographic（从 subs\[0] 开始，越高越“更重要”），或提供 `priority_weights`（每个子系统的权值，用以合并比较）。
* 比较可根据实际业务调整：你可以把某个子系统当作“高权重”主导位。

### 5. 扩展性与线程安全

* 该实现把注册（`register_final`）与查询（`match_final_states`）分离。若需要并发环境：

  * 在启动阶段完成所有 `register_final`，之后只做只读 `match_final_states`（无需加锁）。
  * 若需运行时动态注册/注销，则在 `finals_` 上加互斥（或使用读写锁 / atomic shared\_ptr 替换 vector）以保证并发安全。

### 6. 关于“最高的组合状态”的另一种理解

* 有时“最高”并不是按位数值比较，而是“位的位置更高优先”或“包含更多位优先”。你可以定义 `CombinedState` 的 `score()` 函数来量化（例如加权和、位数计数、或某些关键位权重），然后在 `highest_of_set` 中使用这个 `score`。

---

## 使用场景举例（回到你之前提到的4个子系统，每个8位）

* 你可以把一个 32 位整型看成 4 个子系统各 8 位的集合，但更灵活的是把每个子系统独立为 `uint64_t`，这样当需要扩展到不均匀的位数（例如子系统0用8位、子系统1用12位）时也很方便。
* 示例中展示了如何注册两个 FinalState，并把当前状态匹配到能到达的 FinalState 列表中，按 priority 排序返回。

---

如果你愿意我可以：

* 把示例扩展为完整可运行的 demo（包含编译并运行的 `main()`）；
* 把 `match` 规则扩展为可配置的策略对象（策略模式），并演示如何基于 JSON 配置加载规则；
* 改用位字段拼接成单一大整数（比如在已知各子系统固定宽度时）以获得更快的比较；或改为可变宽度（runtime widths）并提供序列化/反序列化方法。

你想要哪个方向我就直接把代码补全成可编译的 demo（不再问 clarifying question）？


好——我明白你的规则：**“最高最终状态匹配”**的语义是：只要**任意一个子系统**当前状态能够单独匹配到某个最终态（按子系统级别的匹配规则），就把该最终态作为候选；在所有候选最终态中选择优先级最高的那个并返回。下面我把之前的实现扩展出一个清晰、可复用的方法 `highest_final_by_any_subsystem`，并给出示例和说明。

---

### 关键实现（在之前 `MaskStateMachine<N>` 类中加入）

```cpp
// 返回任意子系统级别能匹配到的最高 FinalState（按 priority -> lexicographic mask）
template <size_t N>
std::optional<FinalState<N>> highest_final_by_any_subsystem(
    const CombinedState<N>& current,
    const std::string& per_subsystem_match = "contains"    // "contains" 或 "overlaps"
) const {
    std::vector<FinalState<N>> candidates;
    candidates.reserve(finals_.size());

    for (const auto &f : finals_) {
        bool matched_by_some_sub = false;
        for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
            uint64_t cur_bits = current.subs[i];
            uint64_t final_bits = f.mask.subs[i];

            if (per_subsystem_match == "contains") {
                // 子系统 i 的所有 final_bits 都被 current.subs[i] 包含
                if ((cur_bits & final_bits) == final_bits && final_bits != 0) {
                    matched_by_some_sub = true;
                }
            } else if (per_subsystem_match == "overlaps") {
                // 子系统 i 存在任意 bit 重叠
                if ((cur_bits & final_bits) != 0) {
                    matched_by_some_sub = true;
                }
            } else {
                throw std::invalid_argument("unknown per_subsystem_match mode");
            }
        }
        if (matched_by_some_sub) candidates.push_back(f);
    }

    if (candidates.empty()) return std::nullopt;

    // 选择最高：按 priority 降序，然后按掩码字典序降序
    std::sort(candidates.begin(), candidates.end(), [](const FinalState<N>& a, const FinalState<N>& b){
        if (a.priority != b.priority) return a.priority > b.priority;
        return lexicographic_mask_cmp<N>(a.mask, b.mask) > 0;
    });

    return candidates.front();
}
```

---

### 语义说明与可配置点

* `per_subsystem_match == "contains"`：当某个最终态的**在某个子系统上的要求位**被当前子系统状态**完全包含**时（即该子系统就足以满足该最终态在该子系统上的需求），就把该最终态作为候选。通常用在“final 的某些子系统位是必需位（must-have）”的语义下。
* `per_subsystem_match == "overlaps"`：只要某子系统有位与 final 在该子系统上的位**任意重叠**，就视为该子系统“能匹配到”这个 final。语义更宽松，适合“部分匹配也能触发更高态”的场景。
* 如果多个最终态都被某些子系统匹配到，函数会按 `priority`（更大优先）并以 lexicographic 掩码作为 tiebreaker 来选出**单个最高最终态**返回。
* 如果没有任何子系统匹配到任何 final，则返回 `std::nullopt`。

---

### 小示例（基于之前的 `example()`）

```cpp
// 在 example() 注册完 FinalA (prio 10) 和 FinalB (prio 5) 后：
CS cur = CS::from_array({{0x04, 0x00, 0x00, 0x00}}); // 只有子系统0的 bit2 被置位

// 假设 FinalC 的 mask 在子系统0 上为 0x04，priority = 20
CS finalC_mask = CS::from_array({{0x04,0x00,0x00,0x00}});
m.register_final(FS("FinalC", finalC_mask, 20));

// 使用子系统级别的 contains 匹配
auto best = m.highest_final_by_any_subsystem(cur, "contains");
if (best) {
    std::cout << "Best final by any subsystem: " << best->name
              << " (prio=" << best->priority << ")\n";
} else {
    std::cout << "No final matched by any single subsystem.\n";
}
```

在上面例子里，`cur` 的子系统0 包含 `FinalC` 在子系统0 上的位，因此 `FinalC` 会成为候选，且因其 priority=20 为最高被返回。

---

### 注意事项与建议

1. **子系统位语义要清晰**：决定使用 `contains` 还是 `overlaps`，取决于 final 的掩码如何定义（是“必需位”还是“提示位/部分匹配即可”）。
2. **避免误触发**：若某些 final 的掩码在多个子系统均为 0（即没有在某子系统上设置任何位），这会影响匹配逻辑；在实现里 `contains` 检查我额外排除了 `final_bits != 0` 的情形，避免把“空位”当成匹配条件，你也可以在 FinalState 定义阶段强制要求每个 final 在至少一个子系统上有非零位。
3. **并发**：此方法读取 `finals_`，若运行时可能动态注册/注销 final，请加锁或采用读写锁/原子替换容器策略。
4. **可扩展性**：如果你后来需要更复杂的规则（例如“某子系统匹配到 X 且另一个子系统匹配到 Y 时才视为候选”），建议把匹配规则拆成策略对象并在注册 final 时把规则一并注册。

---

如果你愿意我可以：

* 把上述方法合并进完整类并给出可编译的 `main()` demo；
* 或者直接把匹配规则变成策略模式（`PerSubsystemMatchPolicy`），并展示如何用 JSON 配置 final 的匹配策略（例如某 final 需要 `contains` 在子系统0 且 `overlaps` 在子系统2）。

你想要哪个（我直接把代码写成可编译 demo）？


我已把修改后的**完整、可编译 C++ 源文件**放到画布（名为 **Mask State Machine**）里，你可以在旁边查看/复制。下面是对代码能力的说明、设计注意点和可能的提示（prompt）修正建议 —— 便于你快速调整或让我继续迭代。

```cpp
#include <array>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdint>
#include <stdexcept>
#include <sstream>
#include <iostream>
#include <optional>

// Mask State Machine - single-file demo
// C++17

// -------------------- CombinedState --------------------
template <size_t N>
struct CombinedState {
    std::array<uint64_t, N> subs{}; // each element is bitmask for that subsystem

    CombinedState() { subs.fill(0); }

    static CombinedState from_array(const std::array<uint64_t, N>& a) {
        CombinedState s; s.subs = a; return s;
    }

    // bitwise OR combine
    CombinedState operator|(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] | o.subs[i];
        return r;
    }
    // bitwise AND
    CombinedState operator&(const CombinedState& o) const {
        CombinedState r;
        for (size_t i = 0; i < N; ++i) r.subs[i] = subs[i] & o.subs[i];
        return r;
    }

    bool operator==(const CombinedState& o) const { return subs == o.subs; }
    bool operator!=(const CombinedState& o) const { return !(*this == o); }

    // Checks whether 'this' contains all bits from other
    bool contains_all(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != other.subs[i]) return false;
        }
        return true;
    }

    // For each subsystem, there must be at least one overlapping bit
    bool overlaps_all_subsystems(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) == 0) return false;
        }
        return true;
    }

    // Any subsystem overlaps
    bool overlaps_any(const CombinedState& other) const {
        for (size_t i = 0; i < N; ++i) {
            if ((subs[i] & other.subs[i]) != 0) return true;
        }
        return false;
    }

    // Validate each subsystem does not use bits beyond 'widths'
    void validate_widths(const std::array<int, N>& widths) const {
        for (size_t i = 0; i < N; ++i) {
            int w = widths[i];
            if (w <= 0 || w > 64) throw std::invalid_argument("invalid width");
            if (w < 64) {
                uint64_t mask = ((uint64_t(1) << w) - 1);
                if ((subs[i] & ~mask) != 0) {
                    std::ostringstream oss;
                    oss << "CombinedState: subsystem " << i << " has bits outside width " << w;
                    throw std::out_of_range(oss.str());
                }
            }
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        for (size_t i = 0; i < N; ++i) {
            if (i) oss << ", ";
            oss << "sub" << i << ":0x" << std::hex << subs[i] << std::dec;
        }
        oss << "}";
        return oss.str();
    }
};

// -------------------- FinalState --------------------
template <size_t N>
struct FinalState {
    std::string name;
    CombinedState<N> mask;    // mask that describes bits relevant for this final
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, CombinedState<N> m, int p = 0) : name(std::move(n)), mask(m), priority(p) {}
};

// -------------------- Match enums --------------------
enum class MatchMode {
    Contains,            // current contains final.mask
    OverlapsAllSubsystems,
    OverlapsAny
};

enum class PerSubsystemMatch {
    Contains, // per-subsystem: final_bits fully contained in current.subs[i]
    Overlaps  // per-subsystem: any overlap
};

// -------------------- MaskStateMachine --------------------
template <size_t N>
class MaskStateMachine {
public:
    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    MaskStateMachine(const std::array<int, N>& widths) : widths_(widths) {
        for (int w : widths_) {
            if (w <= 0 || w > 64) throw std::invalid_argument("widths must be in 1..64");
        }
    }

    // Register a final state (call validate on mask)
    void register_final(const FS& f) {
        f.mask.validate_widths(widths_);
        finals_.push_back(f);
    }

    // Match finals according to high-level MatchMode
    std::vector<FS> match_final_states(const CS& current, MatchMode mode = MatchMode::Contains) const {
        std::vector<FS> out;
        for (const auto& f : finals_) {
            bool ok = false;
            switch (mode) {
                case MatchMode::Contains: ok = current.contains_all(f.mask); break;
                case MatchMode::OverlapsAllSubsystems: ok = current.overlaps_all_subsystems(f.mask); break;
                case MatchMode::OverlapsAny: ok = current.overlaps_any(f.mask); break;
                default: throw std::invalid_argument("unknown match mode");
            }
            if (ok) out.push_back(f);
        }
        std::sort(out.begin(), out.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return out;
    }

    // Highest final matched by any single subsystem (per-subsystem policy: Contains or Overlaps)
    std::optional<FS> highest_final_by_any_subsystem(const CS& current, PerSubsystemMatch policy = PerSubsystemMatch::Contains) const {
        std::vector<FS> candidates;
        candidates.reserve(finals_.size());

        for (const auto &f : finals_) {
            bool matched_by_some_sub = false;
            for (size_t i = 0; i < N && !matched_by_some_sub; ++i) {
                uint64_t cur_bits = current.subs[i];
                uint64_t final_bits = f.mask.subs[i];
                if (final_bits == 0) continue; // skip empty per-subsystem requirement
                if (policy == PerSubsystemMatch::Contains) {
                    if ((cur_bits & final_bits) == final_bits) matched_by_some_sub = true;
                } else { // Overlaps
                    if ((cur_bits & final_bits) != 0) matched_by_some_sub = true;
                }
            }
            if (matched_by_some_sub) candidates.push_back(f);
        }

        if (candidates.empty()) return std::nullopt;

        std::sort(candidates.begin(), candidates.end(), [](const FS& a, const FS& b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return lexicographic_mask_cmp(a.mask, b.mask) > 0;
        });
        return candidates.front();
    }

    // From a set of CombinedState pick the highest according to optional priority weights (or lexicographic)
    std::optional<CS> highest_of_set(const std::vector<CS>& set, const std::optional<std::array<uint64_t, N>>& priority_weights = std::nullopt) const {
        if (set.empty()) return std::nullopt;
        auto cmp = [&](const CS& a, const CS& b)->bool {
            if (priority_weights) {
                // compute weighted lexicographic-like comparison
                for (size_t i = 0; i < N; ++i) {
                    if (priority_weights->at(i) != 0) {
                        if (a.subs[i] != b.subs[i]) return a.subs[i] * priority_weights->at(i) > b.subs[i] * priority_weights->at(i);
                    }
                }
                return lexicographic_mask_cmp(a, b) > 0;
            } else {
                return lexicographic_mask_cmp(a, b) > 0;
            }
        };
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (cmp(set[i], *best)) best = &set[i];
        return *best;
    }

    const std::vector<FS>& finals() const { return finals_; }

private:
    std::array<int, N> widths_;
    std::vector<FS> finals_;

    static int lexicographic_mask_cmp(const CS& a, const CS& b) {
        for (size_t i = 0; i < N; ++i) {
            if (a.subs[i] > b.subs[i]) return 1;
            if (a.subs[i] < b.subs[i]) return -1;
        }
        return 0;
    }
};

// -------------------- Demo main --------------------
int main() {
    constexpr size_t N = 4;
    std::array<int, N> widths = {8,8,8,8};
    MaskStateMachine<N> m(widths);

    using CS = CombinedState<N>;
    using FS = FinalState<N>;

    // Register some final states
    CS maskA = CS::from_array({{0x01, 0x00, 0xFF, 0x00}}); // final A needs sub0 bit0 and sub2 any
    CS maskB = CS::from_array({{0x02, 0x04, 0x00, 0x00}});
    CS maskC = CS::from_array({{0x04, 0x00, 0x00, 0x00}});

    m.register_final(FS("FinalA", maskA, 10));
    m.register_final(FS("FinalB", maskB, 5));
    m.register_final(FS("FinalC", maskC, 20));

    // Current state
    CS cur = CS::from_array({{0x04, 0x04, 0x01, 0x00}});

    // 1) match by "contains"
    auto matched_contains = m.match_final_states(cur, MatchMode::Contains);
    std::cout << "Matched (Contains):\n";
    for (auto &f : matched_contains) std::cout << "  " << f.name << " prio=" << f.priority << " mask=" << f.mask.to_string() << "\n";

    // 2) match by overlaps_any
    auto matched_any = m.match_final_states(cur, MatchMode::OverlapsAny);
    std::cout << "Matched (OverlapsAny):\n";
    for (auto &f : matched_any) std::cout << "  " << f.name << " prio=" << f.priority << "\n";

    // 3) highest final by any subsystem (contains)
    auto best_by_sub_contains = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Contains);
    if (best_by_sub_contains) std::cout << "Best by any-subsystem (Contains): " << best_by_sub_contains->name << " prio=" << best_by_sub_contains->priority << "\n";
    else std::cout << "No best final (Contains)\n";

    // 4) highest final by any subsystem (overlaps)
    auto best_by_sub_overlaps = m.highest_final_by_any_subsystem(cur, PerSubsystemMatch::Overlaps);
    if (best_by_sub_overlaps) std::cout << "Best by any-subsystem (Overlaps): " << best_by_sub_overlaps->name << " prio=" << best_by_sub_overlaps->priority << "\n";
    else std::cout << "No best final (Overlaps)\n";

    // 5) highest of a set
    std::vector<CS> set = {
        CS::from_array({{0x01,0x00,0x00,0x00}}),
        CS::from_array({{0x03,0x01,0x00,0x00}}),
        CS::from_array({{0x02,0xFF,0x01,0x00}})
    };
    auto highest = m.highest_of_set(set);
    if (highest) std::cout << "Highest of set: " << highest->to_string() << "\n";

    return 0;
}

```

# 能力概览（代码提供的功能）

* 支持任意数量子系统（模板参数 `N`），每个子系统用 `uint64_t` 保存位掩码。
* 每个子系统可配置位宽（在 `MaskStateMachine` 构造时传入 `widths`），会在注册 `FinalState` 时做验证以防越界。
* `CombinedState` 提供常用操作：

  * 位或（`|`）、位与（`&`）、相等比较；
  * `contains_all`（当前包含另一个掩码的所有位）；
  * `overlaps_all_subsystems`（每个子系统都有至少一个重叠位）；
  * `overlaps_any`（任意子系统有重叠）；
  * `validate_widths` 与 `to_string`（调试友好）。
* `FinalState`：包含 `name`、`mask` 和 `priority`。
* `MaskStateMachine` 提供：

  * `register_final()`：注册最终态（并验证掩码合法性）；
  * `match_final_states(current, MatchMode)`：按三种高层匹配模式返回所有匹配的最终态，按 `priority`（降序）和掩码字典序排序；
  * `highest_final_by_any_subsystem(current, PerSubsystemMatch)`：实现你要求的“**只要任意一个子系统能够匹配到更高的最终态，就返回该最终态**”策略；支持两种子系统级别策略：`Contains`（子系统必须完全包含 final 在该子系统的位）和 `Overlaps`（任意重叠即可）；
  * `highest_of_set(...)`：从一组 `CombinedState` 里选最高项（默认字典序，或用可选的权重向量来自定义比较）。
* 含一个 `main()` 演示：注册若干 Final、演示三类匹配、演示“最高最终态匹配（按任意子系统）”、演示从集合选择最高组合状态。

# 设计与行为细节（重要）

* **优先级决定最终态优先顺序**：`priority` 数字越大越优先；相同优先级时使用掩码字典序（从 `subs[0]` 到 `subs[N-1]`）作为 tiebreaker。
* 在 `highest_final_by_any_subsystem` 内，默认跳过 `final.mask` 在某子系统上的空位（`final_bits == 0`），以避免把“没有要求”的子系统当成匹配触发器。
* `PerSubsystemMatch::Contains` 更严格（用于 final 在某子系统上定义了必需位）；`Overlaps` 更宽松（用于提示/模糊匹配）。
* 当前代码对 `finals_` 的注册和查询**未**做并发保护：推荐在初始化阶段完成注册，之后读取即可无锁使用；如果需要运行时动态注册/注销，请用互斥/读写锁或用 `std::shared_ptr<std::vector<...>>` 原子替换策略。

# 可选改进点（我可以帮助实现任意一项）

* 把 `MatchMode` / `PerSubsystemMatch` 做成策略对象（策略模式），使每个 `FinalState` 能携带自定义匹配策略（例如：finalA 用 `contains`，finalB 用 `overlaps`）。
* 支持按子系统组合的更复杂规则（例如：final 要求 `sub0` contains X **且** (`sub1` overlaps Y **或** `sub2` contains Z））。可通过注册时附带布尔表达式或小型规则树实现。
* 动态注册/注销：增加 `std::mutex` 或 `std::shared_mutex` 保护 `finals_`，或使用无锁读多写少的原子交换容器。
* 序列化/反序列化：把 final 状态列表导出为 JSON（便于 UI），并可以从 JSON 恢复。
* 性能优化：当 N 很大或 final 很多时，可建立索引（例如按子系统位建立倒排表）以加速 `highest_final_by_any_subsystem` 的查找。
* 增加单元测试和 fuzz 测试示例，确保匹配语义在边界位（如位宽边界、mask 全 0）时符合预期。

# 测试与验证建议（快速检查点）

* 测试 `Contains` 与 `Overlaps` 在边界位：例如 final.mask 在某子系统为 `0`（应被视作无要求）；
* 测试多个 final 同时满足条件：优先级较大的应被返回；
* 测试 `highest_of_set` 的比较策略是否符合你的业务（如果不是，告诉我你期望如何比较）。
* 测试在 N、各子系统宽度与 mask 较大时是否越界（构造非法 mask 应抛异常）。

# 如何提示我改动（示例 prompt 模板）

* 如果你想我把“每个 final 携带自己的匹配策略”实现成策略对象：`请把 FinalState 扩展为包含一个匹配策略对象，并在 register_final 时允许传入 lambda 或策略类型。给出完整代码。`
* 要我把注册线程安全化并实现运行时注销：`请把 MaskStateMachine 修改为线程安全，支持 register 和 unregister（根据 name），并给出使用示例。`
* 要我把匹配模式从 enum 改成可由 JSON 指定：`请实现从 JSON 加载 final 列表，并支持 per-final 指定 \"per_subsystem_match\": \"contains\"/\"overlaps\"。给出示例 JSON 与完整代码。`
* 如果你想改变 tiebreaker（比如“包含更多位优先而不是掩码字典序”）：`请修改排序规则使得优先级相同的 final 中包含位数更多的 final 优先；如果位数相同再用字典序。`

---

如果你希望，我可以直接按你选中的改动把源文件更新为新的版本（我会把改动后的完整源码放到画布并在此说明）。你想现在先让我把哪个改进/调整实现为可编译 demo？



```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>

// Enum-based Mask State Machine
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// CombinedState: holds one enum value per subsystem
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }

private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << to_underlying(std::get<I>(subs)) ) ) );
    }
};

// ------------------------------------------------------
// FinalState: each subsystem may be optional (std::nullopt means "don't care")
// ------------------------------------------------------
template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<std::optional<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // optional per-subsystem requirement
    int priority = 0;

    FinalState() = default;

    FinalState(std::string n, MaskTuple m, int p = 0)
        : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), (std::get<I>(mask).has_value() ? (oss << "sub"<<I<<":"<< to_underlying(*std::get<I>(mask))) : (oss << "sub"<<I<<":-")) ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // register final state (call during init)
    void register_final(const FS& f) {
        finals_.push_back(f);
    }

    // match all finals that fully match the current CombinedState (every non-empty mask entry equals the current value)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem (i.e., any subsystem value equals that final's requirement for that subsystem)
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem (useful for debugging)
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS>& finals() const { return finals_; }

private:
    std::vector<FS> finals_;

    // full-match: for all indexes: either final.mask is nullopt or equal to cur.subs
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void)( ok = ok && ( !std::get<I>(f.mask).has_value() || *std::get<I>(f.mask) == std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where final.mask == current.subs (and mask not nullopt)
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).has_value() && *std::get<I>(f.mask) == std::get<I>(cur.subs) ) ) ));
        return triggered;
    }

    // compare CombinedState lexicographically by underlying enum integer values
    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    // sort finals by priority desc, then by mask lexicographic desc (higher underlying values first)
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [this](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    // compare masks lexicographically where nullopt is treated as lowest
    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }
    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_opt(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    template <typename E>
    static int compare_opt(const std::optional<E> &a, const std::optional<E> &b) {
        if (a.has_value() && b.has_value()) {
            auto ua = to_underlying(*a);
            auto ub = to_underlying(*b);
            if (ua == ub) return 0; return ua > ub ? 1 : -1;
        }
        if (a.has_value()) return 1;   // has value considered > no-value
        if (b.has_value()) return -1;
        return 0;
    }
};

// ------------------------------------------------------
// Example enums and demo usage
// ------------------------------------------------------
enum class EngineState { Idle = 0, Running = 1, Error = 2 };
enum class NetworkState { Disconnected = 0, Connecting = 1, Connected = 2 };
enum class PowerState { Off = 0, On = 1 };
enum class SensorState { OK = 0, Warn = 1, Fail = 2 };

int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals. For masks use std::make_tuple with std::optional values (std::nullopt == don't care)
    // Final: Engine Running, any network, Power On, any sensor
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        std::optional<EngineState>(EngineState::Running),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(PowerState::On),
        std::optional<SensorState>(std::nullopt)
    ), 10));

    // Final: Network Connected (regardless other subsystems), highest priority
    sm.register_final(FS("NetworkConnected", std::make_tuple(
        std::optional<EngineState>(std::nullopt),
        std::optional<NetworkState>(NetworkState::Connected),
        std::optional<PowerState>(std::nullopt),
        std::optional<SensorState>(std::nullopt)
    ), 30));

    // Final: Sensor Fail (alerts)
    sm.register_final(FS("SensorFail", std::make_tuple(
        std::optional<EngineState>(std::nullopt),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(std::nullopt),
        std::optional<SensorState>(SensorState::Fail)
    ), 20));

    // Final: Engine Error + Power On (combined)
    sm.register_final(FS("EngineError_Powered", std::make_tuple(
        std::optional<EngineState>(EngineState::Error),
        std::optional<NetworkState>(std::nullopt),
        std::optional<PowerState>(PowerState::On),
        std::optional<SensorState>(std::nullopt)
    ), 25));

    // Current state example
    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);
    std::cout << "Current: " << cur.to_string() << "
";

    // 1) All finals that fully match current
    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    // 2) All finals that match any subsystem
    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    // 3) Highest final triggered by any single subsystem
    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // 4) Highest of a set of CombinedState
    std::vector<CS> set = { CS(EngineState::Idle, NetworkState::Disconnected, PowerState::Off, SensorState::OK),
                            CS(EngineState::Running, NetworkState::Connected, PowerState::On, SensorState::Warn),
                            CS(EngineState::Error, NetworkState::Connecting, PowerState::On, SensorState::Fail) };
    auto h = sm.highest_of_set(set);
    if (h) std::cout << "Highest of set: " << h->to_string() << "
";

    return 0;
}

```

我已把 **完整修改后的枚举版源码** 更新到画布（文件名仍为 **Mask State Machine**）。你可以在画布中查看/运行该文件。下面是对修改点、能力和如何提示我继续改进的简短说明 — 方便你直接给出修改指示。

## 本次主要改动（概要）

* 把“子系统状态为位掩码”的实现，全面改为**每个子系统由 enum 表示**（类型安全、易读）。
* `CombinedState` 现在是 `std::tuple<Enum...>`，每个子系统仅能处于单一枚举值。
* `FinalState` 的掩码为 `std::tuple<std::optional<Enum>...>`：`nullopt` 表示该子系统**不关心**。
* 提供核心接口：

  * `match_full_all(cur)`：返回与当前状态完全匹配（所有非空字段相等）的最终态集合（按优先级排序）。
  * `match_by_any_subsystem_all(cur)`：返回至少在一个子系统匹配的最终态集合。
  * `highest_final_by_any_subsystem(cur)`：实现你要的“只要任意子系统能匹配到更高最终态就返回它”的策略（返回优先级最高的那个）。
  * `highest_of_set(...)`：从若干 `CombinedState` 中选出“最高”的一个（按枚举底层值的字典序）。
* 增加打印（`to_string()` / `mask_to_string()`）用于调试与展示。
* 附带 `main()` 演示：定义 4 个子系统枚举（Engine/Network/Power/Sensor），注册若干 FinalState，并演示各种匹配结果。

## 能力与语义说明（快速参考）

* Final 的优先级 (`priority`) 决定冲突时哪个先返回；优先级相同时按掩码字典序比较（有值视为大于无值）。
* `highest_final_by_any_subsystem` 的语义：只要**某个子系统**的当前枚举值与某 Final 在该子系统的要求相等（且该 Final 在该子系统上有要求），该 Final 即被视作候选；在所有候选中返回 `priority` 最大的。
* 设计便于扩展：你可让 FinalState 的掩码更复杂（支持集合、多值、条件表达式）——我可以帮你把 mask 从 `optional<Enum>` 扩展为 `std::vector<Enum>`（允许一组可接受值）或一个小规则表达式树。

## 进一步改进建议（你可以直接挑一项让我实现）

* 让 FinalState 在每个子系统上支持**多个可接受枚举值**（例如子系统0 可接受 {Idle, Running}）；
* 支持 per-Final 自定义匹配策略（例如某个 Final 对子系统0 用“equals”，对子系统1 用“in set”或“negation”）——策略对象或 lambda 的方式；
* 运行时的注册/注销线程安全（添加 `std::shared_mutex`）；
* 把 FinalState 列表导入/导出为 JSON（方便 UI 配置），以及从 JSON 创建 `FinalState`（我可以加入 `nlohmann::json` 示例）；
* 把枚举到字符串的映射（更可读的打印）自动化（通过宏或映射表）。

告诉我你想继续哪一项（例如：`把每个 final 的每个子系统改为支持一组可接受枚举值`），我会直接在画布把文件改好并在此说明改动细节。


```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>
#include <functional>
#include <shared_mutex>
#include <unordered_set>

// Enum-based Mask State Machine (advanced)
// - Each subsystem uses an enum type (defined via X-macro for automatic string mapping)
// - FinalState supports per-subsystem multi-value matching (sets) and custom predicates
// - Per-Final per-subsystem matching policies via SubMatcher
// - Thread-safe register/unregister using std::shared_mutex
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// X-macro helper to declare enums with string mapping
// Usage:
// #define LIST 
 X(Idle) 
 X(Running)
// DECLARE_ENUM_WITH_STRINGS(EngineState, LIST)
// ------------------------------------------------------
#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST)                 \
    enum class NAME {                                       \
        LIST(ENUM_DECLARE_ELEM)                             \
    };                                                      \
    inline const char* to_string(NAME v) {                  \
        static const char* _names[] = { LIST(ENUM_STRING_ELEM) }; \
        auto idx = static_cast<size_t>(to_underlying(v));   \
        return _names[idx];                                 \
    }

#define ENUM_DECLARE_ELEM(x) x,
#define ENUM_STRING_ELEM(x) #x,

// Helper to expand list macro style
// We'll require lists to be provided as a macro that takes one macro argument
// Example:
// #define ENGINE_STATE_LIST(M) M(Idle) M(Running) M(Error)

// ------------------------------------------------------
// SubMatcher: per-subsystem matching policy and accepted values
// ------------------------------------------------------
template <typename E>
struct SubMatcher {
    // kinds of matcher
    enum class Kind { Any, Equals, InSet, NotEquals, NotInSet, Predicate };

    Kind kind = Kind::Any;
    std::vector<E> values; // used for Equals (single) or InSet
    std::function<bool(E)> pred; // used for Predicate

    SubMatcher() = default;
    static SubMatcher Any() { return SubMatcher(); }
    static SubMatcher Equals(E v) { SubMatcher m; m.kind = Kind::Equals; m.values = {v}; return m; }
    static SubMatcher InSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::InSet; m.values = vs; return m; }
    static SubMatcher NotEquals(E v) { SubMatcher m; m.kind = Kind::NotEquals; m.values = {v}; return m; }
    static SubMatcher NotInSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::NotInSet; m.values = vs; return m; }
    static SubMatcher Predicate(std::function<bool(E)> p) { SubMatcher m; m.kind = Kind::Predicate; m.pred = std::move(p); return m; }

    bool matches(E cur) const {
        switch (kind) {
            case Kind::Any: return true;
            case Kind::Equals: return !values.empty() && cur == values[0];
            case Kind::InSet: return std::any_of(values.begin(), values.end(), [&](E v){ return v == cur; });
            case Kind::NotEquals: return !values.empty() && cur != values[0];
            case Kind::NotInSet: return !std::any_of(values.begin(), values.end(), [&](E v){ return v == cur; });
            case Kind::Predicate: return pred ? pred(cur) : false;
            default: return false;
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        switch (kind) {
            case Kind::Any: oss << "Any"; break;
            case Kind::Equals: oss << "= " << to_underlying(values[0]); break;
            case Kind::InSet: {
                oss << "in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::NotEquals: oss << "!= " << to_underlying(values[0]); break;
            case Kind::NotInSet: {
                oss << "not_in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::Predicate: oss << "pred(...)"; break;
        }
        return oss.str();
    }
};

// ------------------------------------------------------
// CombinedState: holds one enum value per subsystem
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << to_string(std::get<I>(subs)) ) ) );
    }
};

// ------------------------------------------------------
// FinalState: each subsystem represented by SubMatcher<E>
// ------------------------------------------------------
template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<SubMatcher<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // per-subsystem matcher
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, MaskTuple m, int p = 0) : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub"<<I<<":"<< std::get<I>(mask).to_string() ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic with thread-safety
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // Register final state (thread-safe)
    void register_final(const FS& f) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        finals_.push_back(f);
    }

    // Unregister final state by name (thread-safe)
    bool unregister_final(const std::string& name) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        auto it = std::remove_if(finals_.begin(), finals_.end(), [&](const FS &f){ return f.name == name; });
        if (it == finals_.end()) return false;
        finals_.erase(it, finals_.end());
        return true;
    }

    // match all finals that fully match the current CombinedState (every subsystem matcher returns true)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS> snapshot_finals() const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        return finals_;
    }

private:
    mutable std::shared_mutex mu_;
    std::vector<FS> finals_;

    // full-match: for all indexes: matcher.matches(cur.subs[index]) must be true
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void) ( ok = ok && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where matcher.matches(cur.subs[index]) is true and matcher is not Any
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).kind != SubMatcher<typename std::tuple_element<I, std::tuple<Subsystems...>>::type>::Kind::Any && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ) ));
        return triggered;
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    // sort finals by priority desc, then by mask specificity/lexicographic desc
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_submatcher(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }

    // compare two SubMatcher<E>
    template <typename E>
    static int compare_submatcher(const SubMatcher<E> &a, const SubMatcher<E> &b) {
        // Specificity ranking: Predicate > Equals > InSet (larger set considered more specific by size) > NotEquals/NotInSet > Any
        auto rank = [](typename SubMatcher<E>::Kind k) {
            switch (k) {
                case SubMatcher<E>::Kind::Predicate: return 5;
                case SubMatcher<E>::Kind::Equals: return 4;
                case SubMatcher<E>::Kind::InSet: return 3;
                case SubMatcher<E>::Kind::NotEquals: return 2;
                case SubMatcher<E>::Kind::NotInSet: return 1;
                case SubMatcher<E>::Kind::Any: return 0;
            }
            return 0;
        };
        int ra = rank(a.kind), rb = rank(b.kind);
        if (ra != rb) return ra > rb ? 1 : -1;
        // same kind -> tiebreaker by underlying values (if available)
        if (a.kind == SubMatcher<E>::Kind::Equals || a.kind == SubMatcher<E>::Kind::NotEquals) {
            if (!a.values.empty() && !b.values.empty()) {
                auto ua = to_underlying(a.values[0]);
                auto ub = to_underlying(b.values[0]);
                if (ua == ub) return 0; return ua > ub ? 1 : -1;
            }
            return 0;
        }
        if (a.kind == SubMatcher<E>::Kind::InSet || a.kind == SubMatcher<E>::Kind::NotInSet) {
            size_t sa = a.values.size();
            size_t sb = b.values.size();
            if (sa != sb) return sa > sb ? 1 : -1; // larger set considered more specific
            // otherwise lexicographic by underlying
            for (size_t i = 0; i < sa; ++i) {
                auto ua = to_underlying(a.values[i]);
                auto ub = to_underlying(b.values[i]);
                if (ua != ub) return ua > ub ? 1 : -1;
            }
            return 0;
        }
        // Predicate or Any -> equal
        return 0;
    }
};

// ------------------------------------------------------
// Example enums using X-macro lists and automatic to_string
// ------------------------------------------------------
#define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
#define NETWORK_LIST(M) M(Disconnected) M(Connecting) M(Connected)
#define POWER_LIST(M) M(Off) M(On)
#define SENSOR_LIST(M) M(OK) M(Warn) M(Fail)

DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
DECLARE_ENUM_WITH_STRINGS(NetworkState, NETWORK_LIST)
DECLARE_ENUM_WITH_STRINGS(PowerState, POWER_LIST)
DECLARE_ENUM_WITH_STRINGS(SensorState, SENSOR_LIST)

// For convenient printing of enum values when used in CombinedState::to_string, we rely on to_string(enum) overloads above.

// ------------------------------------------------------
// Demo usage
// ------------------------------------------------------
int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals with various per-subsystem multi-value matchers and custom predicate
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        SubMatcher<EngineState>::InSet({EngineState::Running}),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Equals(PowerState::On),
        SubMatcher<SensorState>::Any()
    ), 10));

    sm.register_final(FS("NetworkConnected", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Equals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 30));

    sm.register_final(FS("SensorFailOrWarn", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::InSet({SensorState::Fail, SensorState::Warn})
    ), 20));

    // final with custom predicate: engine underlying value >= Running (example predicate)
    sm.register_final(FS("EngineAtLeastRunning", std::make_tuple(
        SubMatcher<EngineState>::Predicate([](EngineState e){ return to_underlying(e) >= to_underlying(EngineState::Running); }),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 15));

    // Complex final: Engine Error but network not connected
    sm.register_final(FS("EngineError_NetNotConnected", std::make_tuple(
        SubMatcher<EngineState>::Equals(EngineState::Error),
        SubMatcher<NetworkState>::NotEquals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 25));

    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);

    std::cout << "Current: " << cur.to_string() << "
";

    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // Demonstrate unregister
    sm.unregister_final("NetworkConnected");
    std::cout << "After unregistering NetworkConnected, any-subsystem matches:
";
    any = sm.match_by_any_subsystem_all(cur);
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    return 0;
}

```

已完成 —— 我把你的要求全部实现并将完整源码更新到画布（Mask State Machine）。新版本具备：

* 每个 FinalState 在每个子系统上支持**多个可接受枚举值**（`InSet`），也支持 `Equals`、`NotEquals`、`NotInSet`。
* 支持**自定义 predicate**（`Predicate`）用于任意复杂判断。
* 使用 `SubMatcher<E>` 封装每个子系统的匹配策略（易于扩展）。
* 对 `finals_` 的注册/注销和匹配操作使用 `std::shared_mutex` 保护（读多写少友好）。
* 枚举与字符串映射通过 X-macro + `DECLARE_ENUM_WITH_STRINGS` 自动生成 `to_string(enum)`，用于更友好的输出。
* 示例 `main()` 展示如何注册各种 FinalState、匹配、以及运行时注销。

如果你想要我做下一步改进，我可以直接在画布里改动代码（例如：把 `SubMatcher::values` 内部使用有序 set 以便比较稳定、把排序策略改为按“命中更多子系统优先”、或将最终态从内存导出为 JSON）。你想我先做哪一项？


已按你的要求移除 X-macro，并把枚举与字符串映射改为显式定义（每个 `enum` 对应一个 `to_string(enum)` 函数）。我已把修改后的完整源码更新到画布。

改动摘要：

* 删除了 X-macro 宏方式，改为每个枚举显式定义 `to_string()`。
* 保留了所有功能：多值匹配（`InSet`）、自定义 predicate、Per-Final 子系统匹配策略（`SubMatcher`）、线程安全注册/注销（`std::shared_mutex`）以及排序/优先级逻辑。
* `CombinedState::to_string()` 现在调用全局 `to_string(enum)` 函数（请确保新加入的 enum 类型都实现相应 `to_string()`）。

接下来我可以：

* 把 `to_string(enum)` 的实现改为返回 `std::string`（目前返回 `const char*`），如果你需要 Unicode 或本地化支持也可以扩展；
* 把 `SubMatcher::values` 存储为 `std::unordered_set`（用于快速 membership 测试）并调整比较逻辑；
* 增加序列化（JSON）接口以导出/导入 FinalState（方便 UI 编辑）；
* 添加单元测试或更详细示例（包括一些边界测试）。

你想我先做哪一项？

```cpp
#include <iostream>
#include <string>
#include <tuple>
#include <vector>
#include <optional>
#include <algorithm>
#include <type_traits>
#include <sstream>
#include <functional>
#include <shared_mutex>
#include <unordered_set>

// Enum-based Mask State Machine (macro-assisted)
// - Uses X-style LIST macros to declare enums + automatic to_string mapping
// - FinalState supports per-subsystem multi-value matching (InSet) and custom predicates
// - Per-Final per-subsystem matching policies via SubMatcher
// - Thread-safe register/unregister using std::shared_mutex
// C++17 single-file demo

// ------------------------------------------------------
// Utilities
// ------------------------------------------------------
template <typename E>
constexpr auto to_underlying(E e) noexcept -> std::underlying_type_t<E> {
    return static_cast<std::underlying_type_t<E>>(e);
}

// ------------------------------------------------------
// X-macro enum helper
// LIST must be a macro that accepts another macro M and expands M(x) for each enumerator x.
// Example:
// #define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
// DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
// ------------------------------------------------------
#define ENUM_DECLARE_ELEM(x) x,
#define ENUM_STRING_ELEM(x) #x,

#define DECLARE_ENUM_WITH_STRINGS(NAME, LIST)                                 \
    enum class NAME { LIST(ENUM_DECLARE_ELEM) };                              \
    inline const char* to_string(NAME v) {                                    \
        static const char* _names[] = { LIST(ENUM_STRING_ELEM) };              \
        auto idx = static_cast<size_t>(to_underlying(v));                     \
        return (idx < sizeof(_names)/sizeof(_names[0])) ? _names[idx] : "Unknown"; \
    }

// ------------------------------------------------------
// SubMatcher: per-subsystem matching policy and accepted values (optimized)
// - values are stored in both vector (deterministic order) and unordered_set (O(1) match)
// ------------------------------------------------------
template <typename E>
struct SubMatcher {
    enum class Kind { Any, Equals, InSet, NotEquals, NotInSet, Predicate };

    Kind kind = Kind::Any;
    std::vector<E> values; // deterministic order for comparison
    std::unordered_set<std::underlying_type_t<E>> setvals; // for fast membership (store underlying)
    std::function<bool(E)> pred; // used for Predicate

    SubMatcher() = default;
    static SubMatcher Any() { return SubMatcher(); }
    static SubMatcher Equals(E v) { SubMatcher m; m.kind = Kind::Equals; m.values = {v}; m.setvals.insert(to_underlying(v)); return m; }
    static SubMatcher InSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::InSet; m.values = vs; for (auto &x: m.values) m.setvals.insert(to_underlying(x)); std::sort(m.values.begin(), m.values.end(), [](E a,E b){return to_underlying(a)<to_underlying(b);}); return m; }
    static SubMatcher NotEquals(E v) { SubMatcher m; m.kind = Kind::NotEquals; m.values = {v}; m.setvals.insert(to_underlying(v)); return m; }
    static SubMatcher NotInSet(std::initializer_list<E> vs) { SubMatcher m; m.kind = Kind::NotInSet; m.values = vs; for (auto &x: m.values) m.setvals.insert(to_underlying(x)); std::sort(m.values.begin(), m.values.end(), [](E a,E b){return to_underlying(a)<to_underlying(b);}); return m; }
    static SubMatcher Predicate(std::function<bool(E)> p) { SubMatcher m; m.kind = Kind::Predicate; m.pred = std::move(p); return m; }

    bool matches(E cur) const {
        switch (kind) {
            case Kind::Any: return true;
            case Kind::Equals: return !values.empty() && cur == values[0];
            case Kind::InSet: return setvals.find(to_underlying(cur)) != setvals.end();
            case Kind::NotEquals: return !values.empty() && cur != values[0];
            case Kind::NotInSet: return setvals.find(to_underlying(cur)) == setvals.end();
            case Kind::Predicate: return pred ? pred(cur) : false;
            default: return false;
        }
    }

    std::string to_string() const {
        std::ostringstream oss;
        switch (kind) {
            case Kind::Any: oss << "Any"; break;
            case Kind::Equals: oss << "= " << to_underlying(values[0]); break;
            case Kind::InSet: {
                oss << "in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::NotEquals: oss << "!= " << to_underlying(values[0]); break;
            case Kind::NotInSet: {
                oss << "not_in{";
                bool first = true;
                for (auto &v : values) { if (!first) oss << ","; first = false; oss << to_underlying(v); }
                oss << "}"; break;
            }
            case Kind::Predicate: oss << "pred(...)"; break;
        }
        return oss.str();
    }
};

// ------------------------------------------------------
// CombinedState and FinalState (same structure as before)
// ------------------------------------------------------
template <typename... Subsystems>
struct CombinedState {
    static constexpr size_t N = sizeof...(Subsystems);
    std::tuple<Subsystems...> subs;

    CombinedState() = default;
    CombinedState(Subsystems... args) : subs(std::make_tuple(args...)) {}

    std::string to_string() const {
        std::ostringstream oss;
        oss << "{";
        to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub" << I << ':' << ::to_string(std::get<I>(subs)) ) ) );
    }
};

template <typename... Subsystems>
struct FinalState {
    using MaskTuple = std::tuple<SubMatcher<Subsystems>...>;

    std::string name;
    MaskTuple mask;   // per-subsystem matcher
    int priority = 0;

    FinalState() = default;
    FinalState(std::string n, MaskTuple m, int p = 0) : name(std::move(n)), mask(std::move(m)), priority(p) {}

    std::string mask_to_string() const {
        std::ostringstream oss;
        oss << "{";
        mask_to_string_impl(oss, std::index_sequence_for<Subsystems...>{});
        oss << "}";
        return oss.str();
    }
private:
    template <size_t... I>
    void mask_to_string_impl(std::ostringstream &oss, std::index_sequence<I...>) const {
        bool first = true;
        (..., ( (void)( (first? first=false: oss<<", "), oss << "sub"<<I<<":"<< std::get<I>(mask).to_string() ) ) );
    }
};

// ------------------------------------------------------
// MaskStateMachine: core logic with thread-safety
// ------------------------------------------------------
template <typename... Subsystems>
class MaskStateMachine {
public:
    using CS = CombinedState<Subsystems...>;
    using FS = FinalState<Subsystems...>;
    static constexpr size_t N = sizeof...(Subsystems);

    MaskStateMachine() = default;

    // Register final state (thread-safe)
    void register_final(const FS& f) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        finals_.push_back(f);
    }

    // Unregister final state by name (thread-safe)
    bool unregister_final(const std::string& name) {
        std::unique_lock<std::shared_mutex> lk(mu_);
        auto it = std::remove_if(finals_.begin(), finals_.end(), [&](const FS &f){ return f.name == name; });
        if (it == finals_.end()) return false;
        finals_.erase(it, finals_.end());
        return true;
    }

    // match all finals that fully match the current CombinedState (every subsystem matcher returns true)
    std::vector<FS> match_full_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_full(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // highest final triggered by any single subsystem
    std::optional<FS> highest_final_by_any_subsystem(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> candidates;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) candidates.push_back(f);
        if (candidates.empty()) return std::nullopt;
        sort_finals(candidates);
        return candidates.front();
    }

    // find all finals that match at least one subsystem
    std::vector<FS> match_by_any_subsystem_all(const CS& cur) const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        std::vector<FS> out;
        for (const auto &f : finals_) if (match_any_subsystem(cur, f)) out.push_back(f);
        sort_finals(out);
        return out;
    }

    // pick highest CombinedState from a set (lexicographic by underlying enum integer values)
    std::optional<CS> highest_of_set(const std::vector<CS>& set) const {
        if (set.empty()) return std::nullopt;
        const CS* best = &set[0];
        for (size_t i = 1; i < set.size(); ++i) if (compare_cs(set[i], *best) > 0) best = &set[i];
        return *best;
    }

    const std::vector<FS> snapshot_finals() const {
        std::shared_lock<std::shared_mutex> lk(mu_);
        return finals_;
    }

private:
    mutable std::shared_mutex mu_;
    std::vector<FS> finals_;

    // full-match: for all indexes: matcher.matches(cur.subs[index]) must be true
    bool match_full(const CS& cur, const FS& f) const {
        return match_full_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_full_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool ok = true;
        (..., ( (void) ( ok = ok && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ));
        return ok;
    }

    // any-subsystem match: exists an index where matcher.matches(cur.subs[index]) is true and matcher is not Any
    bool match_any_subsystem(const CS& cur, const FS& f) const {
        return match_any_impl(cur, f, std::index_sequence_for<Subsystems...>{});
    }

    template <size_t... I>
    bool match_any_impl(const CS& cur, const FS& f, std::index_sequence<I...>) const {
        bool triggered = false;
        (..., ( (void) ( triggered = triggered || ( std::get<I>(f.mask).kind != SubMatcher<typename std::tuple_element<I, std::tuple<Subsystems...>>::type>::Kind::Any && std::get<I>(f.mask).matches( std::get<I>(cur.subs) ) ) ) ));
        return triggered;
    }

    template <size_t... I>
    static int compare_cs_impl(const CS& a, const CS& b, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? ( to_underlying(std::get<I>(a.subs)) == to_underlying(std::get<I>(b.subs)) ? 0 : ( to_underlying(std::get<I>(a.subs)) > to_underlying(std::get<I>(b.subs)) ? 1 : -1 ) ) : res), ... );
        return res;
    }

    static int compare_cs(const CS& a, const CS& b) {
        return compare_cs_impl(a, b, std::index_sequence_for<Subsystems...>{});
    }

    // sort finals by priority desc, then by mask specificity/lexicographic desc
    void sort_finals(std::vector<FS>& v) const {
        std::sort(v.begin(), v.end(), [](const FS &a, const FS &b){
            if (a.priority != b.priority) return a.priority > b.priority;
            return compare_masks(a.mask, b.mask) > 0;
        });
    }

    template <size_t... I>
    static int compare_masks_impl(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B, std::index_sequence<I...>) {
        int res = 0;
        ((res = res == 0 ? compare_submatcher(std::get<I>(A), std::get<I>(B)) : res), ...);
        return res;
    }

    static int compare_masks(const typename FS::MaskTuple &A, const typename FS::MaskTuple &B) {
        return compare_masks_impl(A, B, std::index_sequence_for<Subsystems...>{});
    }

    // compare two SubMatcher<E>
    template <typename E>
    static int compare_submatcher(const SubMatcher<E> &a, const SubMatcher<E> &b) {
        // Specificity ranking: Predicate > Equals > InSet (larger set considered more specific by size) > NotEquals/NotInSet > Any
        auto rank = [](typename SubMatcher<E>::Kind k) {
            switch (k) {
                case SubMatcher<E>::Kind::Predicate: return 5;
                case SubMatcher<E>::Kind::Equals: return 4;
                case SubMatcher<E>::Kind::InSet: return 3;
                case SubMatcher<E>::Kind::NotEquals: return 2;
                case SubMatcher<E>::Kind::NotInSet: return 1;
                case SubMatcher<E>::Kind::Any: return 0;
            }
            return 0;
        };
        int ra = rank(a.kind), rb = rank(b.kind);
        if (ra != rb) return ra > rb ? 1 : -1;
        // same kind -> tiebreaker by underlying values (if available)
        if (a.kind == SubMatcher<E>::Kind::Equals || a.kind == SubMatcher<E>::Kind::NotEquals) {
            if (!a.values.empty() && !b.values.empty()) {
                auto ua = to_underlying(a.values[0]);
                auto ub = to_underlying(b.values[0]);
                if (ua == ub) return 0; return ua > ub ? 1 : -1;
            }
            return 0;
        }
        if (a.kind == SubMatcher<E>::Kind::InSet || a.kind == SubMatcher<E>::Kind::NotInSet) {
            size_t sa = a.values.size();
            size_t sb = b.values.size();
            if (sa != sb) return sa > sb ? 1 : -1; // larger set considered more specific
            // otherwise lexicographic by underlying
            for (size_t i = 0; i < sa; ++i) {
                auto ua = to_underlying(a.values[i]);
                auto ub = to_underlying(b.values[i]);
                if (ua != ub) return ua > ub ? 1 : -1;
            }
            return 0;
        }
        // Predicate or Any -> equal
        return 0;
    }
};

// ------------------------------------------------------
// Example enums using X-macro lists and automatic to_string
// ------------------------------------------------------
#define ENGINE_LIST(M) M(Idle) M(Running) M(Error)
#define NETWORK_LIST(M) M(Disconnected) M(Connecting) M(Connected)
#define POWER_LIST(M) M(Off) M(On)
#define SENSOR_LIST(M) M(OK) M(Warn) M(Fail)

DECLARE_ENUM_WITH_STRINGS(EngineState, ENGINE_LIST)
DECLARE_ENUM_WITH_STRINGS(NetworkState, NETWORK_LIST)
DECLARE_ENUM_WITH_STRINGS(PowerState, POWER_LIST)
DECLARE_ENUM_WITH_STRINGS(SensorState, SENSOR_LIST)

// ------------------------------------------------------
// Demo usage
// ------------------------------------------------------
int main() {
    using MSM = MaskStateMachine<EngineState, NetworkState, PowerState, SensorState>;
    using CS = typename MSM::CS;
    using FS = typename MSM::FS;

    MSM sm;

    // Register finals with various per-subsystem multi-value matchers and custom predicate
    sm.register_final(FS("EngineUp_Powered", std::make_tuple(
        SubMatcher<EngineState>::InSet({EngineState::Running}),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Equals(PowerState::On),
        SubMatcher<SensorState>::Any()
    ), 10));

    sm.register_final(FS("NetworkConnected", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Equals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 30));

    sm.register_final(FS("SensorFailOrWarn", std::make_tuple(
        SubMatcher<EngineState>::Any(),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::InSet({SensorState::Fail, SensorState::Warn})
    ), 20));

    // final with custom predicate: engine underlying value >= Running (example predicate)
    sm.register_final(FS("EngineAtLeastRunning", std::make_tuple(
        SubMatcher<EngineState>::Predicate([](EngineState e){ return to_underlying(e) >= to_underlying(EngineState::Running); }),
        SubMatcher<NetworkState>::Any(),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 15));

    // Complex final: Engine Error but network not connected
    sm.register_final(FS("EngineError_NetNotConnected", std::make_tuple(
        SubMatcher<EngineState>::Equals(EngineState::Error),
        SubMatcher<NetworkState>::NotEquals(NetworkState::Connected),
        SubMatcher<PowerState>::Any(),
        SubMatcher<SensorState>::Any()
    ), 25));

    CS cur(EngineState::Running, NetworkState::Connecting, PowerState::On, SensorState::OK);

    std::cout << "Current: " << cur.to_string() << "
";

    auto full = sm.match_full_all(cur);
    std::cout << "Full matches:
";
    for (auto &f : full) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto any = sm.match_by_any_subsystem_all(cur);
    std::cout << "Any-subsystem matches:
";
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    auto best = sm.highest_final_by_any_subsystem(cur);
    if (best) std::cout << "Highest final by any subsystem: " << best->name << " (prio=" << best->priority << ")
";
    else std::cout << "No final triggered by any subsystem.
";

    // Demonstrate unregister
    sm.unregister_final("NetworkConnected");
    std::cout << "After unregistering NetworkConnected, any-subsystem matches:
";
    any = sm.match_by_any_subsystem_all(cur);
    for (auto &f : any) std::cout << "  " << f.name << " (prio=" << f.priority << ") mask=" << f.mask_to_string() << "
";

    return 0;
}


```

已根据你的意见把代码改为\*\*结合宏（X-macro 列表）\*\*的更优实现，并把完整源码更新到画布。主要变化与优势：

* 使用 `DECLARE_ENUM_WITH_STRINGS(NAME, LIST)` + `LIST(M)` 形式的 X-macro 列表自动生成 `enum class` 和 `to_string(enum)`，极大减少人为抄写 enum → 字符串映射的样板代码。
* `SubMatcher` 内部同时维护 `std::vector<E>`（用于可预测的比较）和 `std::unordered_set<underlying>`（用于快速 membership 测试），兼顾性能与确定性。
* 保持并完善了之前的特性：多值匹配（InSet）、自定义 predicate、per-final 子系统匹配策略、线程安全注册/注销（`std::shared_mutex`）、优先级排序逻辑。
* 示例展示如何用 LIST 宏定义 enums（Engine/Network/Power/Sensor）并注册多种 FinalState。

如果你想，我可以再做：

* 生成 `from_string()` 或 `parse_enum()`（方便从配置加载字符串）；
* 将 FinalState 列表导出/导入为 JSON（便于 UI 编辑），并示例如何从 JSON 构造 `SubMatcher`（需要选 JSON 库，例如 nlohmann::json）；
* 把 `SubMatcher` 的比较逻辑改为“命中子系统数量”优先（如果你更关心匹配的覆盖度而不是掩码具体值）；
* 提供单元测试或更详尽示例（边界条件、并发注册/匹配演示）。

要我继续做哪一项，我会直接把代码在画布上改好并说明改动细节。
