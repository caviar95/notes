```cpp
template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;

    template <typename T>
    static void RegisterType() {
        static_assert(is_base_of<Base, T>::value, "xxx");

        lock_guard<mutex> lk(GetMutex());

        GetCreator() = [] { return make_unique<T>()};
    }

    static unique_ptr<Base> CreateDefault() {
        lock_guard<mutex> lk(GetMutex);

        if (!GetCreator()) {
            return nullptr;
        }

        return GetCreator()();
    }

private:
    static Creator& GetCreator() {
        static Creator instance;
        return instance;

    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;

    }
};

template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister() {
        AutoRegistry<Base>::template RegisterType<Derived>();
    }
};

AutoRegister<ILogger, ProductLogger> reg{};

class Singleton {

public:
    Singleton() : logger_(AtutoRegistry<ILogger>::CreateDefault());

    ILogger *logger_;
};
```

è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ª **è‡ªåŠ¨æ³¨å†Œæœºåˆ¶**ï¼ˆAuto Registrationï¼‰ï¼Œç”¨äºå°†æ´¾ç”Ÿç±»è‡ªåŠ¨æ³¨å†Œåˆ°æŸä¸ª**å·¥å‚å‡½æ•°è¡¨**ä¸­ï¼Œå…è®¸åç»­é€šè¿‡åŸºç±»æŒ‡é’ˆç»Ÿä¸€åˆ›å»ºå®ä¾‹ï¼Œå…¸å‹åº”ç”¨åŒ…æ‹¬æ’ä»¶æ¡†æ¶ã€æ—¥å¿—ç³»ç»Ÿã€åºåˆ—åŒ–æ¡†æ¶ç­‰ã€‚æˆ‘ä»¬ä¸€æ­¥æ­¥è§£é‡Šå®ƒçš„ç»„æˆå’ŒèƒŒåçš„è®¾è®¡æ€æƒ³ã€‚

---

## ä¸€ã€åº”ç”¨èƒŒæ™¯ï¼šä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå†™ï¼Ÿ

åœ¨å¤§å‹ C++ é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å¸¸å¸¸æœ‰è¿™æ ·çš„éœ€æ±‚ï¼š

* å¸Œæœ›é€šè¿‡ä¸€ä¸ªç»Ÿä¸€æ¥å£ï¼ˆæ¯”å¦‚ `ILogger`ï¼‰æ¥ä½¿ç”¨å„ç§ä¸åŒå®ç°ï¼ˆå¦‚ `ProductLogger`, `MockLogger` ç­‰ï¼‰ï¼›
* ä¸æƒ³åœ¨ä¸»å‡½æ•°æˆ–ä¸­å¿ƒæ¨¡å—ä¸­æ‰‹åŠ¨æ³¨å†Œæ¯ä¸ªç±»å‹ï¼›
* å¸Œæœ›æ¯ä¸ªæ´¾ç”Ÿç±»èƒ½**è‡ªåŠ¨æ³¨å†Œè‡ªå·±**ï¼›
* æ³¨å†Œåï¼Œèƒ½**ç»Ÿä¸€åˆ›å»º**å¯¹è±¡ï¼ˆå¦‚é€šè¿‡å·¥å‚æ¨¡å¼ï¼‰ã€‚

è¯¥æ®µä»£ç å°±æ˜¯ä¸€ç§â€œ**è‡ªåŠ¨æ³¨å†Œ + å·¥å‚æ¨¡å¼**â€çš„å®ç°æ–¹å¼ã€‚

---

## äºŒã€å…³é”®ç»„æˆéƒ¨åˆ†ä¸åŸç†

### 1. `AutoRegistry<Base>`ï¼šæ³¨å†Œä¸­å¿ƒ

è¿™æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œç”¨äºä¿å­˜æ´¾ç”Ÿç±»æ„é€ å‡½æ•°çš„æ³¨å†Œå·¥å‚å‡½æ•°ã€‚

```cpp
template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;
```

* `Creator`ï¼šå®šä¹‰äº†ä¸€ä¸ªå¯ä»¥åˆ›å»º `Base` æ´¾ç”Ÿç±»çš„å‡½æ•°å¯¹è±¡ã€‚
* è¿™ä¸ª `Creator` ä¼šè¢«æ³¨å†Œä¸€æ¬¡ï¼Œåœ¨åç»­è°ƒç”¨ `CreateDefault()` æ—¶æ‰§è¡Œã€‚

#### RegisterType<T>()

```cpp
template <typename T>
static void RegisterType() {
    static_assert(is_base_of<Base, T>::value, "xxx");

    lock_guard<mutex> lk(GetMutex());
    GetCreator() = [] { return make_unique<T>(); };
}
```

* **æ¨¡æ¿å‚æ•° T**ï¼šå¿…é¡»æ˜¯ `Base` çš„å­ç±»ã€‚
* **GetCreator()**ï¼šè¿”å›çš„æ˜¯æ³¨å†Œå‡½æ•°çš„å¼•ç”¨ï¼ˆé™æ€å±€éƒ¨å˜é‡ï¼‰ã€‚
* å®é™…ä½œç”¨æ˜¯ï¼š**è®¾ç½®ä¸€ä¸ª lambda åˆ° Creator ä¸­ï¼Œè°ƒç”¨æ—¶å¯ä»¥ç”Ÿæˆ T ç±»å‹å¯¹è±¡ã€‚**

#### CreateDefault()

```cpp
static unique_ptr<Base> CreateDefault() {
    lock_guard<mutex> lk(GetMutex());

    if (!GetCreator()) {
        return nullptr;
    }
    return GetCreator()();
}
```

* è¿”å›ä¹‹å‰æ³¨å†Œçš„æ„é€ å‡½æ•°ç”Ÿæˆçš„å¯¹è±¡ã€‚
* å¦‚æœæ²¡æœ‰æ³¨å†Œï¼Œè¿”å›ç©ºæŒ‡é’ˆã€‚

### 2. `AutoRegister<Base, Derived>`ï¼šç”¨äºåœ¨ç±»ä½œç”¨åŸŸä¸­è‡ªåŠ¨æ³¨å†ŒæŸä¸ªæ´¾ç”Ÿç±»

```cpp
template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister() {
        AutoRegistry<Base>::template RegisterType<Derived>();
    }
};
```

* å½“æŸä¸ª `AutoRegister<ILogger, ProductLogger>` çš„å®ä¾‹åˆ›å»ºæ—¶ï¼Œå°±æ³¨å†Œäº† `ProductLogger`ã€‚

è¿™è¡Œä»£ç æ˜¯å…³é”®ï¼š

```cpp
AutoRegister<ILogger, ProductLogger> reg{};
```

* è¿™è¡Œä»£ç æ„é€ äº†ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œåœ¨ **ç¨‹åºå¯åŠ¨é˜¶æ®µ**ï¼ˆstatic initializationï¼‰æ³¨å†Œäº† `ProductLogger` ä¸ºé»˜è®¤æ„é€ ç±»å‹ã€‚

---

## ä¸‰ã€å®é™…ä½¿ç”¨ï¼šæ„é€  `Singleton` ä¸­çš„é»˜è®¤å¯¹è±¡

```cpp
class Singleton {
public:
    Singleton() : logger_(AutoRegistry<ILogger>::CreateDefault()) {}

    ILogger* logger_;
};
```

* è°ƒç”¨ `AutoRegistry<ILogger>::CreateDefault()`ï¼Œä½¿ç”¨æ³¨å†Œæ—¶ä¿å­˜çš„ `ProductLogger` æ„é€ å‡½æ•°åˆ›å»ºå¯¹è±¡ã€‚
* æ³¨æ„è¿™é‡Œè¿”å›çš„æ˜¯ `unique_ptr<Base>`ï¼Œè€Œæˆå‘˜å˜é‡æ˜¯è£¸æŒ‡é’ˆï¼ˆå¯èƒ½éœ€è¦ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼‰ã€‚

---

## å››ã€å­˜åœ¨çš„é—®é¢˜å’Œä¿®å¤å»ºè®®

### é—®é¢˜ 1ï¼šæ‹¼å†™é”™è¯¯

```cpp
Singleton() : logger_(AtutoRegistry<ILogger>::CreateDefault());
```

åº”ä¸ºï¼š

```cpp
Singleton() : logger_(AutoRegistry<ILogger>::CreateDefault().release()) {}
```

* æ‹¼å†™é”™äº† `AtutoRegistry` â†’ `AutoRegistry`
* æ„é€ å‡½æ•°è¿”å› `unique_ptr`ï¼Œè€Œæˆå‘˜æ˜¯è£¸æŒ‡é’ˆï¼Œè¦è°ƒç”¨ `.release()` å¦åˆ™ç¼–è¯‘ä¸é€šè¿‡

---

### é—®é¢˜ 2ï¼šé”ä¿æŠ¤é—®é¢˜

```cpp
lock_guard<mutex> lk(GetMutex); // ç¼ºäº†æ‹¬å·
```

åº”ä¸ºï¼š

```cpp
lock_guard<mutex> lk(GetMutex());
```

---

## äº”ã€æ€»ç»“ï¼šæ•´ä½“è®¾è®¡å›¾

```
+-----------------+       +-----------------+        +-------------------+
|     ILogger     |<------+  ProductLogger  |        |     Singleton     |
+-----------------+       +-----------------+        +-------------------+
        ^                         |                          |
        |                 AutoRegister<ILogger, ProductLogger>
        |                         |
AutoRegistry<ILogger>::RegisterType<ProductLogger>()
        |
CreateDefault() --> [è¿”å› make_unique<ProductLogger>()]
```

---

## å…­ã€ä¼˜ç¼ºç‚¹

### ä¼˜ç‚¹ âœ…

* å®ç°è‡ªåŠ¨æ³¨å†Œï¼Œè§£è€¦ä¸­å¿ƒæ¨¡å—å’Œå®ç°ç±»ï¼›
* åŸºäºæ¨¡æ¿å’Œé™æ€åˆå§‹åŒ–ï¼Œæ— éœ€æ‰‹åŠ¨ç®¡ç†ï¼›
* å¯æ‰©å±•ï¼Œç”¨äºå„ç§å·¥å‚æ¨¡å¼ã€æ’ä»¶ç³»ç»Ÿã€‚

### ç¼ºç‚¹ âŒ

* é™æ€åˆå§‹åŒ–é¡ºåºä¸ç¨³å®šï¼Œè·¨ç¼–è¯‘å•å…ƒæ³¨å†Œå¯èƒ½å­˜åœ¨â€œ**åˆå§‹åŒ–é¡ºåºé—®é¢˜**â€ï¼›
* ä¸é€‚ç”¨äºéœ€è¦æ³¨å†Œå¤šä¸ªç±»å‹å…±å­˜çš„åœºæ™¯ï¼ˆè¿™é‡Œåªèƒ½æ³¨å†Œä¸€ä¸ªé»˜è®¤ç±»å‹ï¼‰ï¼›
* å¦‚æœ logger\_ æˆå‘˜ä¸ä½¿ç”¨ `unique_ptr` ç®¡ç†ï¼Œå®¹æ˜“å¼•å‘ **èµ„æºæ³„æ¼**ã€‚

---

ä¸‹é¢æ˜¯ä¸€ä¸ª**å®Œæ•´å¯è¿è¡Œçš„ C++ ç¤ºä¾‹å·¥ç¨‹**ï¼Œæ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `AutoRegistry` + `AutoRegister` å®ç°è‡ªåŠ¨æ³¨å†Œå’Œé»˜è®¤å¯¹è±¡åˆ›å»ºçš„æœºåˆ¶ã€‚

---

## âœ… ç¤ºä¾‹ç›®æ ‡

* æ¥å£ç±» `ILogger`
* å®ç°ç±» `ProductLogger`
* ä½¿ç”¨ `AutoRegister` è‡ªåŠ¨æ³¨å†Œ
* ä½¿ç”¨ `AutoRegistry` åˆ›å»ºé»˜è®¤å¯¹è±¡
* `Singleton` ä½¿ç”¨é»˜è®¤æ„é€ çš„ `ILogger` å¯¹è±¡

---

## ğŸ—‚ï¸ å·¥ç¨‹ç»“æ„

```
auto_registry_demo/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ main.cpp
â”œâ”€â”€ logger.hpp
â”œâ”€â”€ registry.hpp
```

---

## ğŸ“„ CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.14)
project(auto_registry_demo)

set(CMAKE_CXX_STANDARD 17)

add_executable(auto_registry_demo
    main.cpp
    logger.hpp
    registry.hpp
)
```

---

## ğŸ“„ logger.hpp

```cpp
#pragma once
#include <iostream>
#include <memory>

struct ILogger {
    virtual ~ILogger() = default;
    virtual void Log(const std::string& message) = 0;
};

class ProductLogger : public ILogger {
public:
    void Log(const std::string& message) override {
        std::cout << "[ProductLogger] " << message << std::endl;
    }
};
```

---

## ğŸ“„ registry.hpp

```cpp
#pragma once

#include <functional>
#include <memory>
#include <mutex>
#include <type_traits>
#include <iostream>

using namespace std;

template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;

    template <typename T>
    static void RegisterType() {
        static_assert(is_base_of<Base, T>::value, "Registered type must derive from Base");
        lock_guard<mutex> lk(GetMutex());
        GetCreator() = [] { return make_unique<T>(); };
    }

    static unique_ptr<Base> CreateDefault() {
        lock_guard<mutex> lk(GetMutex());
        if (!GetCreator()) {
            cerr << "[AutoRegistry] No type registered for default creation.\n";
            return nullptr;
        }
        return GetCreator()();
    }

private:
    static Creator& GetCreator() {
        static Creator creator;
        return creator;
    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;
    }
};

template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister() {
        AutoRegistry<Base>::template RegisterType<Derived>();
    }
};
```

---

## ğŸ“„ main.cpp

```cpp
#include "registry.hpp"
#include "logger.hpp"

AutoRegister<ILogger, ProductLogger> auto_reg_logger;

class Singleton {
public:
    Singleton() {
        auto ptr = AutoRegistry<ILogger>::CreateDefault();
        logger_ = ptr.release();  // raw pointer for simplicity
    }

    ~Singleton() {
        delete logger_;
    }

    void DoSomething() {
        if (logger_) {
            logger_->Log("Singleton is doing something...");
        }
    }

private:
    ILogger* logger_;
};

int main() {
    Singleton instance;
    instance.DoSomething();
    return 0;
}
```

---

## ğŸ”§ ç¼–è¯‘ä¸è¿è¡Œ

### æ­¥éª¤ 1ï¼šç¼–è¯‘

```bash
mkdir build && cd build
cmake ..
make
```

### æ­¥éª¤ 2ï¼šè¿è¡Œ

```bash
./auto_registry_demo
```

### è¾“å‡ºï¼š

```
[ProductLogger] Singleton is doing something...
```

---

## ğŸ“Œ æ³¨æ„äº‹é¡¹

* ä¸ºç®€åŒ–æ¼”ç¤ºï¼Œ`Singleton` ä¸­ä½¿ç”¨äº†è£¸æŒ‡é’ˆã€‚å®é™…é¡¹ç›®ä¸­å»ºè®®ä½¿ç”¨ `std::unique_ptr` ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚
* è‡ªåŠ¨æ³¨å†Œä¾èµ–**é™æ€å¯¹è±¡æ„é€ æ—¶æœº**ï¼Œè·¨å¤šä¸ª `.cpp` æ–‡ä»¶æ—¶éœ€æ³¨æ„æ„é€ é¡ºåºï¼ˆå»ºè®®é›†ä¸­æ³¨å†Œæˆ–ä½¿ç”¨å®ç¡®ä¿åˆå§‹åŒ–ï¼‰ã€‚

---



ä¸‹é¢æ˜¯å¯¹ä½ åŸå§‹ `AutoRegistry` æ¡†æ¶çš„**å¢å¼ºç‰ˆè®¾è®¡**ï¼Œæ”¯æŒï¼š

âœ… **æ³¨å†Œå¤šä¸ªç±»å‹ï¼ˆé€šè¿‡ key å­—ç¬¦ä¸²/æšä¸¾/IDï¼‰**
âœ… **æŒ‰ key åˆ›å»ºå¯¹åº”ç±»å‹çš„å¯¹è±¡**
âœ… **è‡ªåŠ¨æ³¨å†Œæœºåˆ¶ï¼ˆé€šè¿‡æ¨¡æ¿å’Œé™æ€å˜é‡ï¼‰**

---

## ğŸ§  ä¸€ã€ç›®æ ‡æ‰©å±•è®¾è®¡

åŸæ¥çš„è®¾è®¡ï¼š

```cpp
AutoRegistry<Base>::RegisterType<Derived>();
auto obj = AutoRegistry<Base>::CreateDefault();
```

å¢å¼ºåçš„è®¾è®¡ï¼š

```cpp
AutoRegistry<Base>::RegisterType<Derived>("ProductLogger");
auto obj = AutoRegistry<Base>::Create("ProductLogger");
```

---

## ğŸ“„ ç›®å½•ç»“æ„ï¼ˆä¸å˜ï¼‰

```
multi_registry_demo/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ main.cpp
â”œâ”€â”€ logger.hpp
â”œâ”€â”€ registry.hpp
```

---

## ğŸ§± äºŒã€registry.hppï¼šå¢å¼ºæ”¯æŒå¤šç±»å‹æ³¨å†Œ

```cpp
#pragma once

#include <string>
#include <unordered_map>
#include <functional>
#include <memory>
#include <mutex>
#include <iostream>
#include <type_traits>

using namespace std;

template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;

    template <typename T>
    static void RegisterType(const string& key) {
        static_assert(is_base_of<Base, T>::value, "T must derive from Base");

        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        if (map.find(key) != map.end()) {
            cerr << "[AutoRegistry] Duplicate key: " << key << endl;
        }

        map[key] = [] { return make_unique<T>(); };
    }

    static unique_ptr<Base> Create(const string& key) {
        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        auto it = map.find(key);
        if (it == map.end()) {
            cerr << "[AutoRegistry] No type registered with key: " << key << endl;
            return nullptr;
        }
        return it->second();
    }

    static vector<string> RegisteredKeys() {
        lock_guard<mutex> lk(GetMutex());
        vector<string> keys;
        for (auto& [k, _] : GetRegistryMap()) {
            keys.push_back(k);
        }
        return keys;
    }

private:
    static unordered_map<string, Creator>& GetRegistryMap() {
        static unordered_map<string, Creator> creators;
        return creators;
    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;
    }
};

template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister(const string& key) {
        AutoRegistry<Base>::template RegisterType<Derived>(key);
    }
};
```

---

## ğŸ“„ logger.hppï¼šå¤šä¸ªå®ç°ç±»

```cpp
#pragma once
#include <iostream>

struct ILogger {
    virtual ~ILogger() = default;
    virtual void Log(const std::string& msg) = 0;
};

class ProductLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[ProductLogger] " << msg << std::endl;
    }
};

class DebugLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[DebugLogger] " << msg << std::endl;
    }
};
```

---

## ğŸ“„ main.cppï¼šä½¿ç”¨å¤šç±»å‹æ³¨å†Œå’Œåˆ›å»º

```cpp
#include "registry.hpp"
#include "logger.hpp"

AutoRegister<ILogger, ProductLogger> reg_prod("Product");
AutoRegister<ILogger, DebugLogger> reg_debug("Debug");

int main() {
    auto logger1 = AutoRegistry<ILogger>::Create("Product");
    if (logger1) logger1->Log("Created product logger");

    auto logger2 = AutoRegistry<ILogger>::Create("Debug");
    if (logger2) logger2->Log("Created debug logger");

    auto logger_invalid = AutoRegistry<ILogger>::Create("NotExist");
    if (!logger_invalid) {
        std::cout << "[main] No logger created for NotExist\n";
    }

    std::cout << "Available loggers:\n";
    for (const auto& key : AutoRegistry<ILogger>::RegisteredKeys()) {
        std::cout << " - " << key << "\n";
    }

    return 0;
}
```

---

## ğŸ”¨ ä¸‰ã€ç¼–è¯‘ & è¿è¡Œ

### CMakeLists.txtï¼ˆåŒå‰ï¼‰

```cmake
cmake_minimum_required(VERSION 3.14)
project(multi_registry_demo)
set(CMAKE_CXX_STANDARD 17)

add_executable(multi_registry_demo
    main.cpp
    logger.hpp
    registry.hpp
)
```

### ç¼–è¯‘

```bash
mkdir build && cd build
cmake ..
make
./multi_registry_demo
```

### é¢„æœŸè¾“å‡ºï¼š

```
[ProductLogger] Created product logger
[DebugLogger] Created debug logger
[AutoRegistry] No type registered with key: NotExist
[main] No logger created for NotExist
Available loggers:
 - Product
 - Debug
```

---

## ğŸ§© å››ã€å¯æ‹“å±•å»ºè®®

ä½ å¯ä»¥è½»æ¾æ‹“å±•ä¸ºï¼š

| åŠŸèƒ½              | å¦‚ä½•å®ç°                                                                 |
| --------------- | -------------------------------------------------------------------- |
| æ³¨å†Œ ID ä¸ºæ•´å‹æˆ–æšä¸¾    | å°† `unordered_map<string, Creator>` æ›¿æ¢ä¸º `unordered_map<int, Creator>` |
| æ”¯æŒä¼ å‚æ„é€           | æ”¹é€  `Creator` ä¸º `function<unique_ptr<Base>(Args...)>`                 |
| å·¥å‚æ”¯æŒç­–ç•¥æ¨¡å¼ã€IOC å®¹å™¨ | å¼•å…¥ `FactoryManager`ã€æ³¨å†Œå¤šä¸ªæ³¨å†Œè¡¨                                          |
| æ³¨å†Œå®ç®€åŒ–è°ƒç”¨         | å°è£… `AutoRegister` ä¸ºå® `REGISTER_TYPE(Base, Derived, Key)`             |

---

## âœ… æ€»ç»“

è¿™ä¸ªæ¡†æ¶é€šè¿‡ï¼š

* `unordered_map<key, Creator>` æ”¯æŒå¤šç±»æ³¨å†Œ
* æ¨¡æ¿é™æ€å˜é‡ + è‡ªåŠ¨æ³¨å†Œç±»ï¼Œå®ç°ç±»è‡ªæ³¨å†Œ
* æä¾› `Create(key)` æ¥å£ï¼ŒæŒ‰éœ€åˆ›å»ºå¯¹è±¡

å·²å¹¿æ³›ç”¨äº **æ’ä»¶ç³»ç»Ÿã€æ¶ˆæ¯è°ƒåº¦å™¨ã€å›¾å½¢å¼•æ“ã€åºåˆ—åŒ–ç³»ç»Ÿç­‰ç»„ä»¶ä¸­**ã€‚

ä¸‹é¢æ˜¯å¯¹ä¸Šä¸€ä¸ªå¤šç±»å‹è‡ªåŠ¨æ³¨å†Œæ¡†æ¶çš„**å®å°è£…ç‰ˆæœ¬**ï¼Œé€šè¿‡å®å®šä¹‰ç®€åŒ–æ³¨å†Œæ–¹å¼ï¼Œæé«˜å¯è¯»æ€§å’Œä½¿ç”¨ä¾¿æ·æ€§ã€‚

---

## âœ… ç›®æ ‡

å°†åŸæœ¬æ‰‹åŠ¨è°ƒç”¨ `AutoRegister<...> reg("key")`ï¼Œç®€åŒ–ä¸ºï¼š

```cpp
REGISTER_TYPE(ILogger, ProductLogger, "Product");
REGISTER_TYPE(ILogger, DebugLogger, "Debug");
```

---

## ğŸ§± ä¸€ã€æ›´æ–° `registry.hpp`

æˆ‘ä»¬ä¿ç•™åŸå§‹çš„ `AutoRegistry` å’Œ `AutoRegister`ï¼Œæ–°å¢å®å°è£…ï¼š

```cpp
#pragma once

#include <string>
#include <unordered_map>
#include <functional>
#include <memory>
#include <mutex>
#include <iostream>
#include <type_traits>

using namespace std;

template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;

    template <typename T>
    static void RegisterType(const string& key) {
        static_assert(is_base_of<Base, T>::value, "T must derive from Base");

        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        if (map.find(key) != map.end()) {
            cerr << "[AutoRegistry] Duplicate key: " << key << endl;
        }

        map[key] = [] { return make_unique<T>(); };
    }

    static unique_ptr<Base> Create(const string& key) {
        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        auto it = map.find(key);
        if (it == map.end()) {
            cerr << "[AutoRegistry] No type registered with key: " << key << endl;
            return nullptr;
        }
        return it->second();
    }

    static vector<string> RegisteredKeys() {
        lock_guard<mutex> lk(GetMutex());
        vector<string> keys;
        for (auto& [k, _] : GetRegistryMap()) {
            keys.push_back(k);
        }
        return keys;
    }

private:
    static unordered_map<string, Creator>& GetRegistryMap() {
        static unordered_map<string, Creator> creators;
        return creators;
    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;
    }
};

template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister(const string& key) {
        AutoRegistry<Base>::template RegisterType<Derived>(key);
    }
};

// ----------- ğŸ”½ å®å°è£… ğŸ”½ -----------
#define CONCATENATE_DETAIL(x, y) x##y
#define CONCATENATE(x, y) CONCATENATE_DETAIL(x, y)
#define UNIQUE_NAME(base) CONCATENATE(base, __COUNTER__)

/**
 * REGISTER_TYPE(Base, Derived, key)
 * ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªé™æ€æ³¨å†Œå¯¹è±¡ï¼Œæ³¨å†Œ Derived åˆ° Base çš„å·¥å‚æ³¨å†Œè¡¨ä¸­
 */
#define REGISTER_TYPE(Base, Derived, key) \
    static AutoRegister<Base, Derived> UNIQUE_NAME(_auto_register_)(key)
```

---

## ğŸ“„ äºŒã€logger.hppï¼ˆä¸å˜ï¼‰

```cpp
#pragma once
#include <iostream>

struct ILogger {
    virtual ~ILogger() = default;
    virtual void Log(const std::string& msg) = 0;
};

class ProductLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[ProductLogger] " << msg << std::endl;
    }
};

class DebugLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[DebugLogger] " << msg << std::endl;
    }
};
```

---

## ğŸ“„ ä¸‰ã€main.cppï¼šä½¿ç”¨å®æ³¨å†Œ

```cpp
#include "registry.hpp"
#include "logger.hpp"

// ä½¿ç”¨å®æ³¨å†Œå¤šä¸ªç±»
REGISTER_TYPE(ILogger, ProductLogger, "Product");
REGISTER_TYPE(ILogger, DebugLogger, "Debug");

int main() {
    auto logger1 = AutoRegistry<ILogger>::Create("Product");
    if (logger1) logger1->Log("Created product logger");

    auto logger2 = AutoRegistry<ILogger>::Create("Debug");
    if (logger2) logger2->Log("Created debug logger");

    auto logger_invalid = AutoRegistry<ILogger>::Create("NotExist");
    if (!logger_invalid) {
        std::cout << "[main] No logger created for NotExist\n";
    }

    std::cout << "Available loggers:\n";
    for (const auto& key : AutoRegistry<ILogger>::RegisteredKeys()) {
        std::cout << " - " << key << "\n";
    }

    return 0;
}
```

---

## ğŸ“„ CMakeLists.txtï¼ˆä¸å˜ï¼‰

```cmake
cmake_minimum_required(VERSION 3.14)
project(macro_registry_demo)
set(CMAKE_CXX_STANDARD 17)

add_executable(macro_registry_demo
    main.cpp
    logger.hpp
    registry.hpp
)
```

---

## ğŸ§ª å››ã€è¿è¡Œæ•ˆæœ

```bash
mkdir build && cd build
cmake ..
make
./macro_registry_demo
```

è¾“å‡ºï¼š

```
[ProductLogger] Created product logger
[DebugLogger] Created debug logger
[AutoRegistry] No type registered with key: NotExist
[main] No logger created for NotExist
Available loggers:
 - Product
 - Debug
```

---

## âœ… ä¼˜ç‚¹æ€»ç»“

| ç‰¹æ€§            | æ˜¯å¦å®ç° |
| ------------- | ---- |
| è‡ªåŠ¨æ³¨å†Œ          | âœ…    |
| å¤šç±»å‹æ˜ å°„ï¼ˆé€šè¿‡ keyï¼‰ | âœ…    |
| ç®€æ´æ³¨å†Œæ¥å£ï¼ˆå®å°è£…ï¼‰   | âœ…    |
| æ”¯æŒè·¨å¤šä¸ªç±»å‹æ‰©å±•     | âœ…    |
| ç¼–è¯‘æœŸç±»å‹å®‰å…¨æ£€æŸ¥     | âœ…    |

---


ä¸‹é¢æ˜¯å¯¹ä¸Šä¸€ä¸ªå¤šç±»å‹è‡ªåŠ¨æ³¨å†Œæ¡†æ¶çš„**å®å°è£…ç‰ˆæœ¬**ï¼Œé€šè¿‡å®å®šä¹‰ç®€åŒ–æ³¨å†Œæ–¹å¼ï¼Œæé«˜å¯è¯»æ€§å’Œä½¿ç”¨ä¾¿æ·æ€§ã€‚

---

## âœ… ç›®æ ‡

å°†åŸæœ¬æ‰‹åŠ¨è°ƒç”¨ `AutoRegister<...> reg("key")`ï¼Œç®€åŒ–ä¸ºï¼š

```cpp
REGISTER_TYPE(ILogger, ProductLogger, "Product");
REGISTER_TYPE(ILogger, DebugLogger, "Debug");
```

---

## ğŸ§± ä¸€ã€æ›´æ–° `registry.hpp`

æˆ‘ä»¬ä¿ç•™åŸå§‹çš„ `AutoRegistry` å’Œ `AutoRegister`ï¼Œæ–°å¢å®å°è£…ï¼š

```cpp
#pragma once

#include <string>
#include <unordered_map>
#include <functional>
#include <memory>
#include <mutex>
#include <iostream>
#include <type_traits>

using namespace std;

template <typename Base>
class AutoRegistry {
public:
    using Creator = function<unique_ptr<Base>()>;

    template <typename T>
    static void RegisterType(const string& key) {
        static_assert(is_base_of<Base, T>::value, "T must derive from Base");

        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        if (map.find(key) != map.end()) {
            cerr << "[AutoRegistry] Duplicate key: " << key << endl;
        }

        map[key] = [] { return make_unique<T>(); };
    }

    static unique_ptr<Base> Create(const string& key) {
        lock_guard<mutex> lk(GetMutex());

        auto& map = GetRegistryMap();
        auto it = map.find(key);
        if (it == map.end()) {
            cerr << "[AutoRegistry] No type registered with key: " << key << endl;
            return nullptr;
        }
        return it->second();
    }

    static vector<string> RegisteredKeys() {
        lock_guard<mutex> lk(GetMutex());
        vector<string> keys;
        for (auto& [k, _] : GetRegistryMap()) {
            keys.push_back(k);
        }
        return keys;
    }

private:
    static unordered_map<string, Creator>& GetRegistryMap() {
        static unordered_map<string, Creator> creators;
        return creators;
    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;
    }
};

template <typename Base, typename Derived>
class AutoRegister {
public:
    AutoRegister(const string& key) {
        AutoRegistry<Base>::template RegisterType<Derived>(key);
    }
};

// ----------- ğŸ”½ å®å°è£… ğŸ”½ -----------
#define CONCATENATE_DETAIL(x, y) x##y
#define CONCATENATE(x, y) CONCATENATE_DETAIL(x, y)
#define UNIQUE_NAME(base) CONCATENATE(base, __COUNTER__)

/**
 * REGISTER_TYPE(Base, Derived, key)
 * ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªé™æ€æ³¨å†Œå¯¹è±¡ï¼Œæ³¨å†Œ Derived åˆ° Base çš„å·¥å‚æ³¨å†Œè¡¨ä¸­
 */
#define REGISTER_TYPE(Base, Derived, key) \
    static AutoRegister<Base, Derived> UNIQUE_NAME(_auto_register_)(key)
```

---

## ğŸ“„ äºŒã€logger.hppï¼ˆä¸å˜ï¼‰

```cpp
#pragma once
#include <iostream>

struct ILogger {
    virtual ~ILogger() = default;
    virtual void Log(const std::string& msg) = 0;
};

class ProductLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[ProductLogger] " << msg << std::endl;
    }
};

class DebugLogger : public ILogger {
public:
    void Log(const std::string& msg) override {
        std::cout << "[DebugLogger] " << msg << std::endl;
    }
};
```

---

## ğŸ“„ ä¸‰ã€main.cppï¼šä½¿ç”¨å®æ³¨å†Œ

```cpp
#include "registry.hpp"
#include "logger.hpp"

// ä½¿ç”¨å®æ³¨å†Œå¤šä¸ªç±»
REGISTER_TYPE(ILogger, ProductLogger, "Product");
REGISTER_TYPE(ILogger, DebugLogger, "Debug");

int main() {
    auto logger1 = AutoRegistry<ILogger>::Create("Product");
    if (logger1) logger1->Log("Created product logger");

    auto logger2 = AutoRegistry<ILogger>::Create("Debug");
    if (logger2) logger2->Log("Created debug logger");

    auto logger_invalid = AutoRegistry<ILogger>::Create("NotExist");
    if (!logger_invalid) {
        std::cout << "[main] No logger created for NotExist\n";
    }

    std::cout << "Available loggers:\n";
    for (const auto& key : AutoRegistry<ILogger>::RegisteredKeys()) {
        std::cout << " - " << key << "\n";
    }

    return 0;
}
```

---

## ğŸ“„ CMakeLists.txtï¼ˆä¸å˜ï¼‰

```cmake
cmake_minimum_required(VERSION 3.14)
project(macro_registry_demo)
set(CMAKE_CXX_STANDARD 17)

add_executable(macro_registry_demo
    main.cpp
    logger.hpp
    registry.hpp
)
```

---

## ğŸ§ª å››ã€è¿è¡Œæ•ˆæœ

```bash
mkdir build && cd build
cmake ..
make
./macro_registry_demo
```

è¾“å‡ºï¼š

```
[ProductLogger] Created product logger
[DebugLogger] Created debug logger
[AutoRegistry] No type registered with key: NotExist
[main] No logger created for NotExist
Available loggers:
 - Product
 - Debug
```

---

## âœ… ä¼˜ç‚¹æ€»ç»“

| ç‰¹æ€§            | æ˜¯å¦å®ç° |
| ------------- | ---- |
| è‡ªåŠ¨æ³¨å†Œ          | âœ…    |
| å¤šç±»å‹æ˜ å°„ï¼ˆé€šè¿‡ keyï¼‰ | âœ…    |
| ç®€æ´æ³¨å†Œæ¥å£ï¼ˆå®å°è£…ï¼‰   | âœ…    |
| æ”¯æŒè·¨å¤šä¸ªç±»å‹æ‰©å±•     | âœ…    |
| ç¼–è¯‘æœŸç±»å‹å®‰å…¨æ£€æŸ¥     | âœ…    |

---

å¦‚ä½ å¸Œæœ›å¢åŠ ï¼š

* **å¸¦å‚æ•°æ„é€ ï¼ˆå¦‚ä¼ å…¥é…ç½®ï¼‰**
* **åŸºäº enum/int è€Œä¸æ˜¯ string çš„æ³¨å†Œ**
* **ç±»å‹å…ƒä¿¡æ¯æ‰©å±•ï¼ˆå¦‚ name/descï¼‰**

æˆ‘å¯ä»¥ç»§ç»­æ‰©å±•ç»™ä½ ã€‚éœ€è¦å—ï¼Ÿ


å¾ˆå¥½ï¼Œæˆ‘ä»¬ç°åœ¨æ¥å‡çº§ä½ çš„è‡ªåŠ¨æ³¨å†Œæ¡†æ¶ï¼Œæ»¡è¶³ä»¥ä¸‹é«˜çº§éœ€æ±‚ï¼š

---

## âœ… æ–°å¢åŠŸèƒ½

1. **æ”¯æŒå¸¦å‚æ•°æ„é€ ï¼ˆå¦‚ä¼ å…¥é…ç½®ç»“æ„ï¼‰**
2. **æ”¯æŒ enum/int ç±»å‹ä½œä¸ºæ³¨å†Œ key**
3. **æ”¯æŒç±»å‹å…ƒä¿¡æ¯æ‰©å±•ï¼ˆå¦‚ nameã€descï¼‰**

---

## ğŸ§  æ•´ä½“æ€è·¯è°ƒæ•´

* å…è®¸æ³¨å†Œæ—¶æŒ‡å®šå·¥å‚å‡½æ•°ç­¾åï¼Œä¾‹å¦‚ `std::function<std::unique_ptr<Base>(const Config&)>`
* ä½¿ç”¨ `enum` æˆ– `int` ä½œä¸º keyï¼ˆæ›¿ä»£ stringï¼‰
* æ³¨å†Œæ—¶è®°å½•ç±»å‹çš„ `name/desc`ï¼Œå¯ç”¨äº UI å±•ç¤ºã€æ’ä»¶ä¿¡æ¯ç­‰

---

## ğŸ§± ç¤ºä¾‹å·¥ç¨‹ç»“æ„ï¼ˆå‡çº§ç‰ˆï¼‰

```
advanced_registry/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ main.cpp
â”œâ”€â”€ logger.hpp
â”œâ”€â”€ registry.hpp
```

---

## ğŸ”§ ç¬¬ä¸€æ­¥ï¼šå®šä¹‰ Key å’Œé…ç½®ç»“æ„

```cpp
// logger.hpp (æ–°å¢éƒ¨åˆ†)
#pragma once
#include <iostream>
#include <string>

enum class LoggerType {
    Product = 1,
    Debug = 2,
};

struct LoggerConfig {
    std::string prefix;
};
```

---

## âœ¨ ç¬¬äºŒæ­¥ï¼šå®ç°å¯é…ç½®æ³¨å†Œæ”¯æŒ + ç±»å‹å…ƒä¿¡æ¯ + enum key æ³¨å†Œ

```cpp
// registry.hpp
#pragma once

#include <unordered_map>
#include <memory>
#include <functional>
#include <mutex>
#include <type_traits>
#include <string>
#include <iostream>

using namespace std;

template <typename Base, typename Key, typename Config>
class AdvancedRegistry {
public:
    using Creator = function<unique_ptr<Base>(const Config&)>;

    struct MetaEntry {
        Creator creator;
        string name;
        string description;
    };

    template <typename T>
    static void RegisterType(Key key, const string& name, const string& desc) {
        static_assert(is_base_of<Base, T>::value, "T must derive from Base");

        lock_guard<mutex> lk(GetMutex());
        auto& map = GetMap();
        if (map.count(key)) {
            cerr << "[AdvancedRegistry] Duplicate key: " << static_cast<int>(key) << "\n";
        }

        map[key] = MetaEntry{
            [](const Config& cfg) {
                return make_unique<T>(cfg);
            },
            name,
            desc
        };
    }

    static unique_ptr<Base> Create(Key key, const Config& cfg) {
        lock_guard<mutex> lk(GetMutex());
        auto& map = GetMap();
        auto it = map.find(key);
        if (it == map.end()) {
            cerr << "[AdvancedRegistry] No type for key: " << static_cast<int>(key) << "\n";
            return nullptr;
        }
        return it->second.creator(cfg);
    }

    static vector<pair<Key, MetaEntry>> ListRegistered() {
        lock_guard<mutex> lk(GetMutex());
        vector<pair<Key, MetaEntry>> out;
        for (const auto& kv : GetMap()) {
            out.push_back(kv);
        }
        return out;
    }

private:
    static unordered_map<Key, MetaEntry>& GetMap() {
        static unordered_map<Key, MetaEntry> map;
        return map;
    }

    static mutex& GetMutex() {
        static mutex mtx;
        return mtx;
    }
};

// å®å°è£…ç®€åŒ–æ³¨å†Œ
#define REGISTER_ADVANCED_TYPE(Base, KeyEnum, Derived, keyVal, nameStr, descStr) \
    static struct CONCATENATE(_auto_reg_, __COUNTER__) { \
        CONCATENATE(_auto_reg_, __COUNTER__)() { \
            AdvancedRegistry<Base, KeyEnum, LoggerConfig>::template RegisterType<Derived>(keyVal, nameStr, descStr); \
        } \
    } CONCATENATE(_auto_reg_obj_, __COUNTER__)
```

---

## ğŸ§© ç¬¬ä¸‰æ­¥ï¼šå®šä¹‰å¤šä¸ªå¸¦é…ç½®çš„æ´¾ç”Ÿç±»

```cpp
// logger.hppï¼ˆç»§ç»­ï¼‰
struct ILogger {
    virtual ~ILogger() = default;
    virtual void Log(const std::string& msg) = 0;
};

class ProductLogger : public ILogger {
public:
    explicit ProductLogger(const LoggerConfig& cfg) : prefix_(cfg.prefix) {}
    void Log(const std::string& msg) override {
        std::cout << "[ProductLogger] " << prefix_ << ": " << msg << std::endl;
    }

private:
    std::string prefix_;
};

class DebugLogger : public ILogger {
public:
    explicit DebugLogger(const LoggerConfig& cfg) : prefix_(cfg.prefix) {}
    void Log(const std::string& msg) override {
        std::cout << "[DebugLogger] " << prefix_ << ": " << msg << std::endl;
    }

private:
    std::string prefix_;
};
```

---

## ğŸ§ª ç¬¬å››æ­¥ï¼šmain.cpp ç¤ºä¾‹ä½¿ç”¨

```cpp
#include "registry.hpp"
#include "logger.hpp"

REGISTER_ADVANCED_TYPE(ILogger, LoggerType, ProductLogger, LoggerType::Product, "ProductLogger", "ç”¨äºç”Ÿäº§ç¯å¢ƒçš„æ—¥å¿—å™¨");
REGISTER_ADVANCED_TYPE(ILogger, LoggerType, DebugLogger, LoggerType::Debug, "DebugLogger", "ç”¨äºè°ƒè¯•æ—¥å¿—è¾“å‡º");

int main() {
    LoggerConfig cfg1{"[AppProd]"};
    LoggerConfig cfg2{"[AppDebug]"};

    auto logger1 = AdvancedRegistry<ILogger, LoggerType, LoggerConfig>::Create(LoggerType::Product, cfg1);
    if (logger1) logger1->Log("Hello from production logger");

    auto logger2 = AdvancedRegistry<ILogger, LoggerType, LoggerConfig>::Create(LoggerType::Debug, cfg2);
    if (logger2) logger2->Log("Hello from debug logger");

    std::cout << "\n--- Registered Types ---\n";
    for (const auto& [key, entry] : AdvancedRegistry<ILogger, LoggerType, LoggerConfig>::ListRegistered()) {
        std::cout << static_cast<int>(key) << ": " << entry.name << " - " << entry.description << "\n";
    }

    return 0;
}
```

---

## ğŸ“„ CMakeLists.txtï¼ˆä¸å˜ï¼‰

```cmake
cmake_minimum_required(VERSION 3.14)
project(advanced_registry_demo)
set(CMAKE_CXX_STANDARD 17)

add_executable(advanced_registry_demo
    main.cpp
    logger.hpp
    registry.hpp
)
```

---

## âœ… è¾“å‡ºç»“æœ

```bash
[ProductLogger] [AppProd]: Hello from production logger
[DebugLogger] [AppDebug]: Hello from debug logger

--- Registered Types ---
1: ProductLogger - ç”¨äºç”Ÿäº§ç¯å¢ƒçš„æ—¥å¿—å™¨
2: DebugLogger - ç”¨äºè°ƒè¯•æ—¥å¿—è¾“å‡º
```

---

## ğŸ” æ€»ç»“ï¼šåŠŸèƒ½çŸ©é˜µ

| åŠŸèƒ½               | å®ç°æ–¹å¼                           |
| ---------------- | ------------------------------ |
| è‡ªåŠ¨æ³¨å†Œ             | å®å°è£… + é™æ€å±€éƒ¨åˆå§‹åŒ–                  |
| enum/int æ³¨å†Œ key  | ä½¿ç”¨ `unordered_map<enum, Meta>` |
| ä¼ å…¥é…ç½®å‚æ•°           | lambda æ„é€ å™¨æ”¯æŒ `(const Config&)` |
| ç±»å‹å…ƒä¿¡æ¯ï¼ˆname/descï¼‰ | `MetaEntry` å­˜å‚¨å­—æ®µ               |
| å¤šç±»å‹æŸ¥è¯¢ã€éå†æ³¨å†Œé¡¹      | `ListRegistered()`             |

---

ä¸ºäº†å®ç°ä½ æåˆ°çš„ä¸‰ä¸ªé«˜çº§åŠŸèƒ½ï¼š

> âœ… æ’ä»¶åŠ¨æ€åŠ è½½ï¼ˆdlopenï¼‰
> âœ… æ¨¡å—çº§åˆ«åˆ‡æ¢ï¼ˆIOCå®¹å™¨ï¼‰
> âœ… è·¨æ¨¡å—æ³¨å†Œç»Ÿä¸€ç®¡ç†

æˆ‘ä»¬å¯ä»¥å¯¹å½“å‰æ¡†æ¶åšè¿›ä¸€æ­¥æ¶æ„è®¾è®¡å’Œå®ç°æ‰©å±•ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„æ‹†è§£å’Œè®¾è®¡æ–¹æ¡ˆï¼Œå¹¶é™„ä¸Šæ ¸å¿ƒå®ç°æŒ‡å¯¼ã€‚

---

## ğŸ§± æ•´ä½“æ¶æ„ç›®æ ‡

æˆ‘ä»¬è¦æ„å»ºä¸€ä¸ªå…·æœ‰ä»¥ä¸‹ç‰¹æ€§çš„æ³¨å†Œ + æ’ä»¶ + å®¹å™¨æ¡†æ¶ï¼š

| åŠŸèƒ½                | æè¿°                            |
| ----------------- | ----------------------------- |
| æ’ä»¶åŠ¨æ€åŠ è½½ (`dlopen`) | å°†æ¨¡å—ç¼–è¯‘ä¸º `.so`ï¼ŒåŠ è½½åè‡ªåŠ¨å®Œæˆç±»æ³¨å†Œ       |
| IOC å®¹å™¨æ¨¡å—ç®¡ç†        | é€šè¿‡å®¹å™¨é…ç½®ï¼ŒæŒ‰éœ€åŠ è½½/åˆ‡æ¢æŸä¸€ç±»å®ç°ï¼ˆå¦‚ä¸åŒæ—¥å¿—/ç­–ç•¥ï¼‰ |
| è·¨æ¨¡å—ç»Ÿä¸€æ³¨å†Œä¸ç®¡ç†        | å¤šä¸ª `.so` æ’ä»¶æ¨¡å—æ³¨å†Œåˆ°ç»Ÿä¸€çš„æ³¨å†Œè¡¨ä¸­       |
| è§£è€¦ main ä¸å®ç°é€»è¾‘     | `main` ä¸ä¾èµ–å…·ä½“ç±»ï¼Œä»…è°ƒç”¨æ³¨å†Œè¡¨ä¸å®¹å™¨       |

---

## ğŸ”§ ä¸€ã€æ’ä»¶åŠ¨æ€åŠ è½½æœºåˆ¶ï¼ˆdlopenï¼‰

### 1. æ’ä»¶å®šä¹‰ï¼ˆ`logger_plugin.cpp`ï¼‰

```cpp
// logger_plugin.cpp
#include "registry.hpp"
#include "logger.hpp"

// é™æ€æ³¨å†Œï¼šdlopen æ—¶è‡ªåŠ¨æ‰§è¡Œ
REGISTER_ADVANCED_TYPE(ILogger, LoggerType, ProductLogger, LoggerType::Product, "ProductLogger", "ç”¨äºç”Ÿäº§ç¯å¢ƒ");
REGISTER_ADVANCED_TYPE(ILogger, LoggerType, DebugLogger, LoggerType::Debug, "DebugLogger", "ç”¨äºè°ƒè¯•");

extern "C" void plugin_init() {
    // ä¿è¯é“¾æ¥è¿›æ¥åç¬¦å·ä¸ä¼šè¢«è£å‰ªï¼ŒçœŸå®æ³¨å†Œå·²é€šè¿‡é™æ€å¯¹è±¡å®Œæˆ
}
```

> âœ”ï¸ ç¼–è¯‘ä¸º `liblogger_plugin.so`

```bash
g++ -std=c++17 -fPIC -shared logger_plugin.cpp -o liblogger_plugin.so
```

---

### 2. åŠ¨æ€åŠ è½½ä¸»ç¨‹åºï¼ˆmain.cppï¼‰

```cpp
#include "registry.hpp"
#include "logger.hpp"
#include <dlfcn.h>

void LoadPlugin(const std::string& path) {
    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);
    if (!handle) {
        std::cerr << "Failed to load plugin: " << dlerror() << "\n";
    } else {
        using InitFunc = void(*)();
        auto init = (InitFunc)dlsym(handle, "plugin_init");
        if (init) init();
    }
}
```

---

## ğŸ§© äºŒã€æ¨¡å—çº§ IOC å®¹å™¨æ”¯æŒ

### IOCContainer ç±»è®¾è®¡ï¼š

```cpp
template <typename Base, typename Key, typename Config>
class IOCContainer {
public:
    void Configure(Key key, const Config& config) {
        current_key_ = key;
        config_ = config;
    }

    std::shared_ptr<Base> Get() {
        if (!instance_) {
            instance_ = AdvancedRegistry<Base, Key, Config>::Create(current_key_, config_);
        }
        return instance_;
    }

    void Reset() {
        instance_.reset();
    }

private:
    Key current_key_;
    Config config_;
    std::shared_ptr<Base> instance_;
};
```

### ç”¨æ³•ï¼š

```cpp
IOCContainer<ILogger, LoggerType, LoggerConfig> logger_ioc;

void InitLogger() {
    logger_ioc.Configure(LoggerType::Product, LoggerConfig{"[PROD]"});
    auto logger = logger_ioc.Get();
    logger->Log("IOC logger started.");
}
```

---

## ğŸ“¦ ä¸‰ã€ç»Ÿä¸€è·¨æ¨¡å—æ³¨å†Œä¸­å¿ƒ

å¤šä¸ªæ’ä»¶åŒæ—¶æ³¨å†Œç±»å‹è¿› `AdvancedRegistry`ï¼Œæ¯ä¸ª `.so` åªéœ€ï¼š

* é“¾æ¥å…¬å…±å¤´æ–‡ä»¶å’Œæ³¨å†Œæ¨¡æ¿
* ç¼–å†™ `REGISTER_ADVANCED_TYPE(...)` å®
* æä¾› `plugin_init()` ç©ºå‡½æ•°ç”¨äº `dlopen` å”¤é†’

ä¸»ç¨‹åºé€šè¿‡å¦‚ä¸‹æ–¹å¼ç»Ÿä¸€è®¿é—®æ‰€æœ‰æ¨¡å—æ³¨å†Œç»“æœï¼š

```cpp
for (const auto& [key, entry] : AdvancedRegistry<ILogger, LoggerType, LoggerConfig>::ListRegistered()) {
    std::cout << entry.name << ": " << entry.description << "\n";
}
```

ä½ ç”šè‡³å¯ä»¥å°†æ‰€æœ‰ç±»å‹å°è£…ä¸ºï¼š

```cpp
struct PluginMeta {
    string name;
    string desc;
    shared_ptr<void> object; // å¯ä»¥è½¬æ¢ä¸ºç‰¹å®šç±»å‹
};
```

---

## ğŸ“ å››ã€å·¥ç¨‹ç»“æ„å»ºè®®

```
plugin_framework/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ registry.hpp
â”‚   â”œâ”€â”€ logger.hpp
â”œâ”€â”€ plugins/
â”‚   â””â”€â”€ logger_plugin.cpp â†’ ç¼–è¯‘ä¸º liblogger_plugin.so
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ CMakeLists.txt
```

### æ’ä»¶æ¨¡å—å•ç‹¬ç¼–è¯‘ä¸º `.so`

```cmake
add_library(logger_plugin SHARED plugins/logger_plugin.cpp)
target_include_directories(logger_plugin PUBLIC ${CMAKE_SOURCE_DIR}/include)
```

### ä¸»ç¨‹åºé“¾æ¥ `.so`

```cmake
add_executable(main src/main.cpp)
target_link_libraries(main dl)
target_include_directories(main PUBLIC include)
```

---

## âœ… æ€»ç»“ä¸ä¸‹ä¸€æ­¥æ–¹å‘

| åŠŸèƒ½              | çŠ¶æ€    | æ‰©å±•å»ºè®®             |
| --------------- | ----- | ---------------- |
| `dlopen` æ’ä»¶åŠ¨æ€æ³¨å†Œ | âœ… å·²æ”¯æŒ | å¯åŠ å…¥æ’ä»¶ç­¾åéªŒè¯        |
| IOC å®¹å™¨          | âœ… å·²æ”¯æŒ | æ”¯æŒé…ç½®æ–‡ä»¶æˆ– JSON åˆå§‹åŒ– |
| è·¨æ¨¡å—ç»Ÿä¸€æ³¨å†Œç®¡ç†       | âœ… å·²æ”¯æŒ | å¯åŠ å…¥ç±»å‹åˆ†ç»„ã€æ ‡ç­¾ç­‰å…ƒä¿¡æ¯   |

---

å¤ªå¥½äº†ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥åŸºäºå·²æœ‰æ¡†æ¶ï¼Œè¿›ä¸€æ­¥å®ç°ä»¥ä¸‹ä¸‰ä¸ªé«˜çº§åŠŸèƒ½ï¼š

---

## âœ… åŠŸèƒ½ç›®æ ‡

| åŠŸèƒ½                   | è¯´æ˜                                      |
| -------------------- | --------------------------------------- |
| æ’ä»¶è‡ªåŠ¨å‘ç°ç›®å½•å¹¶åŠ è½½          | æ‰«æ `./plugins/*.so` å¹¶è‡ªåŠ¨è°ƒç”¨ `dlopen` åŠ è½½æ’ä»¶ |
| æ’ä»¶çƒ­æ›´æ–°ï¼ˆåŠ¨æ€å¸è½½/æ›¿æ¢ï¼‰       | é€šè¿‡ `dlclose` å¸è½½æ—§æ’ä»¶å¹¶é‡æ–°åŠ è½½                 |
| å…ƒä¿¡æ¯å¯¼å‡ºä¸º JSONï¼ˆä¾› UI ä½¿ç”¨ï¼‰ | å°†æ‰€æœ‰æ³¨å†Œç±»å‹çš„ `name/desc/key` å†™å…¥ JSON é…ç½®æ–‡ä»¶   |

---

## ğŸ§© ä¸€ã€æ’ä»¶ç›®å½•æ‰«æä¸è‡ªåŠ¨åŠ è½½

### ä½¿ç”¨ C++17 `<filesystem>`

```cpp
#include <filesystem>
#include <dlfcn.h>
#include <iostream>
namespace fs = std::filesystem;

void LoadPluginsFromDirectory(const std::string& dir) {
    for (const auto& entry : fs::directory_iterator(dir)) {
        if (entry.path().extension() == ".so") {
            std::cout << "[PluginLoader] Loading: " << entry.path() << "\n";
            void* handle = dlopen(entry.path().c_str(), RTLD_NOW | RTLD_GLOBAL);
            if (!handle) {
                std::cerr << "Failed to load plugin: " << dlerror() << "\n";
            } else {
                using InitFunc = void(*)();
                if (auto init = (InitFunc)dlsym(handle, "plugin_init")) {
                    init();
                }
                // å¯è®°å½•å¥æŸ„ï¼Œç”¨äºåç»­çƒ­å¸è½½
            }
        }
    }
}
```

### ç¤ºä¾‹è°ƒç”¨ï¼š

```cpp
LoadPluginsFromDirectory("./plugins");
```

---

## ğŸ”„ äºŒã€æ’ä»¶çƒ­æ›´æ–°ï¼ˆå¸è½½å¹¶é‡æ–°åŠ è½½ï¼‰

### è®¾è®¡æ€è·¯

1. ä¿å­˜ `handle` æŒ‡é’ˆï¼ˆdlopen è¿”å›å€¼ï¼‰
2. ä½¿ç”¨ `dlclose(handle)` å¸è½½
3. é‡æ–° `dlopen` è§¦å‘é‡æ–°æ³¨å†Œ

```cpp
std::unordered_map<std::string, void*> plugin_handles;

void ReloadPlugin(const std::string& path) {
    if (plugin_handles.count(path)) {
        std::cout << "Unloading plugin: " << path << "\n";
        dlclose(plugin_handles[path]);
        plugin_handles.erase(path);
    }
    std::cout << "Reloading plugin: " << path << "\n";
    void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);
    if (handle) {
        plugin_handles[path] = handle;
        using InitFunc = void(*)();
        if (auto init = (InitFunc)dlsym(handle, "plugin_init")) {
            init();
        }
    } else {
        std::cerr << "Reload failed: " << dlerror() << "\n";
    }
}
```

> âš ï¸ æ³¨æ„ï¼šçƒ­æ›´æ–°éœ€è¦ç¡®ä¿æ’ä»¶å®ç°æ— çŠ¶æ€æˆ–é‡æ„æ³¨å†Œè¡¨ã€‚

---

## ğŸ“„ ä¸‰ã€å¯¼å‡ºæ³¨å†Œå…ƒä¿¡æ¯ä¸º JSONï¼ˆç”¨äº UIï¼‰

### ä½¿ç”¨ nlohmann/jsonï¼ˆæ¨èè½»é‡ JSON åº“ï¼‰

å®‰è£…ï¼š

```bash
sudo apt install nlohmann-json3-dev
```

æˆ–åœ¨ `CMakeLists.txt` ä¸­æ·»åŠ ï¼š

```cmake
find_package(nlohmann_json REQUIRED)
target_link_libraries(main PRIVATE nlohmann_json::nlohmann_json)
```

### å¯¼å‡ºä»£ç ï¼š

```cpp
#include <nlohmann/json.hpp>
#include <fstream>

using json = nlohmann::json;

void DumpRegistryToJson(const std::string& path) {
    json j;
    for (const auto& [key, meta] : AdvancedRegistry<ILogger, LoggerType, LoggerConfig>::ListRegistered()) {
        j.push_back({
            {"key", static_cast<int>(key)},
            {"name", meta.name},
            {"desc", meta.description}
        });
    }

    std::ofstream ofs(path);
    ofs << std::setw(4) << j << std::endl;
    std::cout << "[MetaExport] Dumped plugin info to " << path << "\n";
}
```

### ç¤ºä¾‹è¾“å‡ºï¼ˆ`plugin_info.json`ï¼‰ï¼š

```json
[
    {
        "key": 1,
        "name": "ProductLogger",
        "desc": "ç”¨äºç”Ÿäº§ç¯å¢ƒ"
    },
    {
        "key": 2,
        "name": "DebugLogger",
        "desc": "ç”¨äºè°ƒè¯•"
    }
]
```

---

## âœ… æ€»ç»“ï¼šåŠŸèƒ½çŸ©é˜µ

| åŠŸèƒ½           | å®ç°æ–¹å¼                                  |
| ------------ | ------------------------------------- |
| æ’ä»¶ç›®å½•è‡ªåŠ¨åŠ è½½     | `filesystem` + `dlopen`               |
| æ’ä»¶çƒ­æ›´æ–°        | ä¿å­˜ handle + `dlclose` + é‡æ–°åŠ è½½          |
| å…ƒä¿¡æ¯å¯¼å‡ºä¸º JSON  | `nlohmann::json` + `ListRegistered()` |
| è·¨æ¨¡å—æ³¨å†Œä¸ç®¡ç†     | `AdvancedRegistry` å…¨å±€æ³¨å†Œè¡¨              |
| UI å¯é›†æˆæ’ä»¶ä¿¡æ¯å±•ç¤º | è¯»å– JSON é…ç½®                            |

---

## ğŸ“Œ ä¸‹ä¸€æ­¥å¯æ‹“å±•æ–¹å‘

| æ–¹å‘                   | å»ºè®®è®¾è®¡                        |
| -------------------- | --------------------------- |
| æ’ä»¶ç‰ˆæœ¬æ ¡éªŒ               | æ’ä»¶ä¸­æ·»åŠ  `version` å­—æ®µè¿›è¡ŒéªŒè¯      |
| æ’ä»¶ä¾èµ–ç®¡ç†               | æ¯ä¸ªæ’ä»¶å£°æ˜ `require("X.so")` ä¾èµ– |
| æ’ä»¶æ¥å£ç‰¹å¾æˆ– capability   | æ’ä»¶å£°æ˜å…¶æ”¯æŒçš„ `capability` å­—æ®µ    |
| UI é…ç½®ç”Ÿæˆå™¨ / Schema ç”Ÿæˆ | å…ƒä¿¡æ¯ + JSON schema           |

---

æ˜¯å¦éœ€è¦æˆ‘ä¸ºä½ æ‰“åŒ…ä¸€ä¸ªå®Œæ•´ CMake å·¥ç¨‹æ¨¡æ¿ï¼ˆåŒ…å« `.so` æ’ä»¶ + main + JSON å¯¼å‡º + IOC å®¹å™¨ï¼‰ï¼Ÿ
æˆ–è€…å¸®åŠ©ä½ å°†è¿™ä¸ªæ¡†æ¶åµŒå…¥å®é™…å·¥ç¨‹ä½¿ç”¨åœºæ™¯ï¼ˆå¦‚ç­–ç•¥å¼•æ“ã€æ—¥å¿—æ¡†æ¶ã€æ¨¡å‹æ‰§è¡Œå™¨ç­‰ï¼‰ï¼Ÿ
